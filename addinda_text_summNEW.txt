affinda-python-master\affinda\models __init__.py{
try:
    from ._models_py3 import Accreditation
    from ._models_py3 import Annotation
    from ._models_py3 import AnnotationBase
    from ._models_py3 import AnnotationBatchUpdate
    from ._models_py3 import AnnotationCreate
    from ._models_py3 import AnnotationUpdate
    from ._models_py3 import AnnotationWithValidationResults
    from ._models_py3 import AnotationDelete
    from ._models_py3 import ApiUserCreate
    from ._models_py3 import ApiUserUpdate
    from ._models_py3 import ApiUserWithKey
    from ._models_py3 import ApiUserWithKeyOrganizationsItem
    from ._models_py3 import ApiUserWithoutKey
    from ._models_py3 import ApiUserWithoutKeyOrganizationsItem
    from ._models_py3 import BaseExtractor
    from ._models_py3 import BatchAddTagRequest
    from ._models_py3 import BatchDeleteAnnotationsResponse
    from ._models_py3 import BatchDeleteValidationResultsRequest
    from ._models_py3 import BatchRemoveTagRequest
    from ._models_py3 import ChangedValidationResults
    from ._models_py3 import Collection
    from ._models_py3 import CollectionCreate
    from ._models_py3 import CollectionField
    from ._models_py3 import CollectionUpdate
    from ._models_py3 import CollectionWorkspace
    from ._models_py3 import (
        Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1,
    )
    from ._models_py3 import (
        Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1,
    )
    from ._models_py3 import (
        Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1,
    )
    from ._models_py3 import (
        Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification,
    )
    from ._models_py3 import (
        ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1,
    )
    from ._models_py3 import (
        ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1,
    )
    from ._models_py3 import (
        ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties,
    )
    from ._models_py3 import (
        ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1,
    )
    from ._models_py3 import CurrencyCodeAnnotation
    from ._models_py3 import CustomFieldConfig
    from ._models_py3 import DataField
    from ._models_py3 import DataFieldCreate
    from ._models_py3 import DataFieldCreateDataPoint
    from ._models_py3 import DataFieldCreateField
    from ._models_py3 import DataFieldDataPoint
    from ._models_py3 import DataFieldField
    from ._models_py3 import DataPoint
    from ._models_py3 import DataPointChoice
    from ._models_py3 import DataPointChoiceCreate
    from ._models_py3 import DataPointChoiceForReplace
    from ._models_py3 import DataPointChoiceReplaceRequest
    from ._models_py3 import DataPointChoiceReplaceResponse
    from ._models_py3 import DataPointChoiceReplaceResponseChoicesItem
    from ._models_py3 import DataPointChoiceUpdate
    from ._models_py3 import DataPointCreate
    from ._models_py3 import DataPointUpdate
    from ._models_py3 import DateAnnotation
    from ._models_py3 import DateAnnotationUpdate
    from ._models_py3 import DateRangeAnnotation
    from ._models_py3 import DateRangeAnnotationParsed
    from ._models_py3 import DateRangeValue
    from ._models_py3 import Document
    from ._models_py3 import DocumentCreate
    from ._models_py3 import DocumentEditRequest
    from ._models_py3 import DocumentError
    from ._models_py3 import DocumentMeta
    from ._models_py3 import DocumentMetaChildDocumentsItem
    from ._models_py3 import DocumentMetaCollection
    from ._models_py3 import DocumentMetaCollectionExtractor
    from ._models_py3 import DocumentMetaParentDocument
    from ._models_py3 import DocumentMetaWorkspace
    from ._models_py3 import DocumentSplit
    from ._models_py3 import DocumentSplitPage
    from ._models_py3 import DocumentSplitter
    from ._models_py3 import DocumentType
    from ._models_py3 import DocumentTypeCreate
    from ._models_py3 import DocumentTypeUpdate
    from ._models_py3 import DocumentUpdate
    from ._models_py3 import DocumentWarning
    from ._models_py3 import Education
    from ._models_py3 import EducationDates
    from ._models_py3 import EducationGrade
    from ._models_py3 import EducationSearchScoreComponent
    from ._models_py3 import ExpectedRemunerationAnnotation
    from ._models_py3 import ExpectedRemunerationAnnotationParsed
    from ._models_py3 import ExpectedRemunerationAnnotationUpdate
    from ._models_py3 import ExpectedRemunerationAnnotationUpdateParsed
    from ._models_py3 import ExperienceSearchScoreComponent
    from ._models_py3 import Extractor
    from ._models_py3 import ExtractorBaseExtractor
    from ._models_py3 import ExtractorConfig
    from ._models_py3 import ExtractorCreate
    from ._models_py3 import ExtractorUpdate
    from ._models_py3 import Field
    from ._models_py3 import FieldCategory
    from ._models_py3 import FieldDeprecated
    from ._models_py3 import FieldGroup
    from ._models_py3 import FieldsLayout
    from ._models_py3 import FloatAnnotation
    from ._models_py3 import Get200ApplicationJsonPropertiesItemsItem
    from ._models_py3 import Index
    from ._models_py3 import IndexCreate
    from ._models_py3 import IndexUpdate
    from ._models_py3 import IndexUser
    from ._models_py3 import Invitation
    from ._models_py3 import InvitationCreate
    from ._models_py3 import InvitationRespondedBy
    from ._models_py3 import InvitationResponse
    from ._models_py3 import InvitationUpdate
    from ._models_py3 import Invoice
    from ._models_py3 import InvoiceData
    from ._models_py3 import JobDescription
    from ._models_py3 import JobDescriptionData
    from ._models_py3 import JobDescriptionDataUpdate
    from ._models_py3 import JobDescriptionSearch
    from ._models_py3 import JobDescriptionSearchConfig
    from ._models_py3 import JobDescriptionSearchConfigSearchToolTheme
    from ._models_py3 import JobDescriptionSearchDetail
    from ._models_py3 import JobDescriptionSearchDetailEducation
    from ._models_py3 import JobDescriptionSearchDetailEducationMissing
    from ._models_py3 import JobDescriptionSearchDetailEducationValue
    from ._models_py3 import JobDescriptionSearchDetailExperience
    from ._models_py3 import JobDescriptionSearchDetailJobTitle
    from ._models_py3 import JobDescriptionSearchDetailJobTitleValue
    from ._models_py3 import JobDescriptionSearchDetailLanguages
    from ._models_py3 import JobDescriptionSearchDetailLanguagesValueItem
    from ._models_py3 import JobDescriptionSearchDetailLocation
    from ._models_py3 import JobDescriptionSearchDetailLocationValue
    from ._models_py3 import JobDescriptionSearchDetailManagementLevel
    from ._models_py3 import JobDescriptionSearchDetailOccupationGroup
    from ._models_py3 import JobDescriptionSearchDetailOccupationGroupValue
    from ._models_py3 import JobDescriptionSearchDetailSearchExpression
    from ._models_py3 import JobDescriptionSearchDetailSkills
    from ._models_py3 import JobDescriptionSearchDetailSkillsValueItem
    from ._models_py3 import JobDescriptionSearchEmbed
    from ._models_py3 import JobDescriptionSearchParameters
    from ._models_py3 import JobDescriptionSearchResult
    from ._models_py3 import JobTitleAnnotation
    from ._models_py3 import JobTitleAnnotationParsed
    from ._models_py3 import JobTitleAnnotationParsedClassification
    from ._models_py3 import JobTitleAnnotationUpdate
    from ._models_py3 import JobTitleParsed
    from ._models_py3 import JobTitleParsedClassification
    from ._models_py3 import JobTitleParsedParsed
    from ._models_py3 import JobTitleSearchScoreComponent
    from ._models_py3 import LanguageAnnotation
    from ._models_py3 import LanguageAnnotationUpdate
    from ._models_py3 import LanguagesSearchScoreComponent
    from ._models_py3 import Location
    from ._models_py3 import LocationAnnotation
    from ._models_py3 import LocationAnnotationUpdate
    from ._models_py3 import LocationAnnotationUpdateParsed
    from ._models_py3 import LocationSearchScoreComponent
    from ._models_py3 import ManagementLevelSearchScoreComponent
    from ._models_py3 import Mapping
    from ._models_py3 import MappingCreate
    from ._models_py3 import MappingDataSource
    from ._models_py3 import MappingDataSourceCreate
    from ._models_py3 import MappingUpdate
    from ._models_py3 import Meta
    from ._models_py3 import MetaChildDocumentsItem
    from ._models_py3 import MetaParentDocument
    from ._models_py3 import OccupationGroup
    from ._models_py3 import OccupationGroupSearchResult
    from ._models_py3 import OccupationGroupSearchScoreComponent
    from ._models_py3 import Organization
    from ._models_py3 import OrganizationCreate
    from ._models_py3 import OrganizationMembership
    from ._models_py3 import OrganizationMembershipUpdate
    from ._models_py3 import OrganizationUpdate
    from ._models_py3 import OrganizationValidationToolConfig
    from ._models_py3 import PageMeta
    from ._models_py3 import PaginatedResponse
    from ._models_py3 import PaletteColorOptions
    from ._models_py3 import (
        Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema
    from ._models_py3 import (
        Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema,
    )
    from ._models_py3 import Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema
    from ._models_py3 import (
        Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema
    from ._models_py3 import (
        Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import (
        Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema
    from ._models_py3 import (
        Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1
    from ._models_py3 import (
        Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema,
    )
    from ._models_py3 import PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema
    from ._models_py3 import (
        PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema,
    )
    from ._models_py3 import (
        PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1,
    )
    from ._models_py3 import (
        PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema,
    )
    from ._models_py3 import (
        PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import (
        PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema
    from ._models_py3 import (
        PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import (
        PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1
    from ._models_py3 import (
        PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema,
    )
    from ._models_py3 import PhoneNumberAnnotation
    from ._models_py3 import PhoneNumberAnnotationParsed
    from ._models_py3 import Rectangle
    from ._models_py3 import RedactConfig
    from ._models_py3 import RegionBias
    from ._models_py3 import RequestError
    from ._models_py3 import RequestErrorErrorsItem
    from ._models_py3 import ResthookSubscription
    from ._models_py3 import ResthookSubscriptionCreate
    from ._models_py3 import ResthookSubscriptionUpdate
    from ._models_py3 import ResthookSubscriptionWorkspace
    from ._models_py3 import Resume
    from ._models_py3 import ResumeData
    from ._models_py3 import ResumeDataName
    from ._models_py3 import ResumeDataPhoneNumberDetailsItem
    from ._models_py3 import ResumeDataRefereesItem
    from ._models_py3 import ResumeDataSectionsItem
    from ._models_py3 import ResumeDataSkillsItem
    from ._models_py3 import ResumeDataSkillsPropertiesItemsItem
    from ._models_py3 import ResumeDataWorkExperienceItem
    from ._models_py3 import ResumeDataWorkExperienceItemDates
    from ._models_py3 import ResumeDataWorkExperienceItemOccupation
    from ._models_py3 import ResumeRedact
    from ._models_py3 import ResumeRedactData
    from ._models_py3 import ResumeSearch
    from ._models_py3 import ResumeSearchConfig
    from ._models_py3 import ResumeSearchConfigSearchToolTheme
    from ._models_py3 import ResumeSearchDetail
    from ._models_py3 import ResumeSearchDetailEducation
    from ._models_py3 import ResumeSearchDetailEducationMissing
    from ._models_py3 import ResumeSearchDetailEducationValueItem
    from ._models_py3 import ResumeSearchDetailExperience
    from ._models_py3 import ResumeSearchDetailJobTitle
    from ._models_py3 import ResumeSearchDetailJobTitleValueItem
    from ._models_py3 import ResumeSearchDetailLanguages
    from ._models_py3 import ResumeSearchDetailLanguagesValueItem
    from ._models_py3 import ResumeSearchDetailLocation
    from ._models_py3 import ResumeSearchDetailLocationValue
    from ._models_py3 import ResumeSearchDetailManagementLevel
    from ._models_py3 import ResumeSearchDetailOccupationGroup
    from ._models_py3 import ResumeSearchDetailSearchExpression
    from ._models_py3 import ResumeSearchDetailSkills
    from ._models_py3 import ResumeSearchDetailSkillsValueItem
    from ._models_py3 import ResumeSearchEmbed
    from ._models_py3 import ResumeSearchMatch
    from ._models_py3 import ResumeSearchMatchDetails
    from ._models_py3 import ResumeSearchParameters
    from ._models_py3 import ResumeSearchParametersCustomData
    from ._models_py3 import ResumeSearchParametersLocation
    from ._models_py3 import ResumeSearchParametersLocationCoordinates
    from ._models_py3 import ResumeSearchParametersSkill
    from ._models_py3 import ResumeSearchResult
    from ._models_py3 import ResumeSkill
    from ._models_py3 import ResumeSkillSourcesItem
    from ._models_py3 import RowAnnotation
    from ._models_py3 import RowAnnotationParsed
    from ._models_py3 import RowBetaAnnotation
    from ._models_py3 import RowBetaAnnotationParsed
    from ._models_py3 import SearchConfigAction
    from ._models_py3 import SearchExpressionSearchScoreComponent
    from ._models_py3 import SearchParametersCustomData
    from ._models_py3 import SkillAnnotation
    from ._models_py3 import SkillAnnotationUpdate
    from ._models_py3 import SkillsSearchScoreComponent
    from ._models_py3 import TableAnnotation
    from ._models_py3 import TableAnnotationParsed
    from ._models_py3 import TableBetaAnnotation
    from ._models_py3 import TableBetaAnnotationParsed
    from ._models_py3 import Tag
    from ._models_py3 import TagCreate
    from ._models_py3 import TagUpdate
    from ._models_py3 import TextAnnotation
    from ._models_py3 import TextAnnotationUpdate
    from ._models_py3 import ThemeConfig
    from ._models_py3 import ThemeConfigPalette
    from ._models_py3 import ThemeConfigPaletteText
    from ._models_py3 import ThemeConfigTypography
    from ._models_py3 import UrlAnnotation
    from ._models_py3 import UrlAnnotationParsed
    from ._models_py3 import UsageByCollection
    from ._models_py3 import UsageByWorkspace
    from ._models_py3 import User
    from ._models_py3 import UserNullable
    from ._models_py3 import ValidationResult
    from ._models_py3 import ValidationResultCreate
    from ._models_py3 import ValidationResultUpdate
    from ._models_py3 import ValidationRule
    from ._models_py3 import ValidationToolConfig
    from ._models_py3 import Workspace
    from ._models_py3 import WorkspaceCollectionsItem
    from ._models_py3 import WorkspaceCollectionsItemExtractor
    from ._models_py3 import WorkspaceCreate
    from ._models_py3 import WorkspaceDocumentSplitter
    from ._models_py3 import WorkspaceMembership
    from ._models_py3 import WorkspaceMembershipCreate
    from ._models_py3 import WorkspaceUpdate
    from ._models_py3 import YearsExperienceAnnotation
    from ._models_py3 import YearsExperienceAnnotationParsed
    from ._models_py3 import YearsExperienceAnnotationUpdate
    from ._models_py3 import YearsExperienceAnnotationUpdateParsed
except (SyntaxError, ImportError):
    from ._models import Accreditation      from ._models import Annotation      from ._models import AnnotationBase      from ._models import AnnotationBatchUpdate      from ._models import AnnotationCreate      from ._models import AnnotationUpdate      from ._models import AnnotationWithValidationResults      from ._models import AnotationDelete      from ._models import ApiUserCreate      from ._models import ApiUserUpdate      from ._models import ApiUserWithKey      from ._models import ApiUserWithKeyOrganizationsItem      from ._models import ApiUserWithoutKey      from ._models import ApiUserWithoutKeyOrganizationsItem      from ._models import BaseExtractor      from ._models import BatchAddTagRequest      from ._models import BatchDeleteAnnotationsResponse      from ._models import BatchDeleteValidationResultsRequest      from ._models import BatchRemoveTagRequest      from ._models import ChangedValidationResults      from ._models import Collection      from ._models import CollectionCreate      from ._models import CollectionField      from ._models import CollectionUpdate      from ._models import CollectionWorkspace      from ._models import (
        Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1,
    )      from ._models import (
        Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1,
    )      from ._models import (
        Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1,
    )      from ._models import (
        Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification,
    )      from ._models import (
        ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1,
    )      from ._models import (
        ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1,
    )      from ._models import ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties      from ._models import (
        ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1,
    )      from ._models import CurrencyCodeAnnotation      from ._models import CustomFieldConfig      from ._models import DataField      from ._models import DataFieldCreate      from ._models import DataFieldCreateDataPoint      from ._models import DataFieldCreateField      from ._models import DataFieldDataPoint      from ._models import DataFieldField      from ._models import DataPoint      from ._models import DataPointChoice      from ._models import DataPointChoiceCreate      from ._models import DataPointChoiceForReplace      from ._models import DataPointChoiceReplaceRequest      from ._models import DataPointChoiceReplaceResponse      from ._models import DataPointChoiceReplaceResponseChoicesItem      from ._models import DataPointChoiceUpdate      from ._models import DataPointCreate      from ._models import DataPointUpdate      from ._models import DateAnnotation      from ._models import DateAnnotationUpdate      from ._models import DateRangeAnnotation      from ._models import DateRangeAnnotationParsed      from ._models import DateRangeValue      from ._models import Document      from ._models import DocumentCreate      from ._models import DocumentEditRequest      from ._models import DocumentError      from ._models import DocumentMeta      from ._models import DocumentMetaChildDocumentsItem      from ._models import DocumentMetaCollection      from ._models import DocumentMetaCollectionExtractor      from ._models import DocumentMetaParentDocument      from ._models import DocumentMetaWorkspace      from ._models import DocumentSplit      from ._models import DocumentSplitPage      from ._models import DocumentSplitter      from ._models import DocumentType      from ._models import DocumentTypeCreate      from ._models import DocumentTypeUpdate      from ._models import DocumentUpdate      from ._models import DocumentWarning      from ._models import Education      from ._models import EducationDates      from ._models import EducationGrade      from ._models import EducationSearchScoreComponent      from ._models import ExpectedRemunerationAnnotation      from ._models import ExpectedRemunerationAnnotationParsed      from ._models import ExpectedRemunerationAnnotationUpdate      from ._models import ExpectedRemunerationAnnotationUpdateParsed      from ._models import ExperienceSearchScoreComponent      from ._models import Extractor      from ._models import ExtractorBaseExtractor      from ._models import ExtractorConfig      from ._models import ExtractorCreate      from ._models import ExtractorUpdate      from ._models import Field      from ._models import FieldCategory      from ._models import FieldDeprecated      from ._models import FieldGroup      from ._models import FieldsLayout      from ._models import FloatAnnotation      from ._models import Get200ApplicationJsonPropertiesItemsItem      from ._models import Index      from ._models import IndexCreate      from ._models import IndexUpdate      from ._models import IndexUser      from ._models import Invitation      from ._models import InvitationCreate      from ._models import InvitationRespondedBy      from ._models import InvitationResponse      from ._models import InvitationUpdate      from ._models import Invoice      from ._models import InvoiceData      from ._models import JobDescription      from ._models import JobDescriptionData      from ._models import JobDescriptionDataUpdate      from ._models import JobDescriptionSearch      from ._models import JobDescriptionSearchConfig      from ._models import JobDescriptionSearchConfigSearchToolTheme      from ._models import JobDescriptionSearchDetail      from ._models import JobDescriptionSearchDetailEducation      from ._models import JobDescriptionSearchDetailEducationMissing      from ._models import JobDescriptionSearchDetailEducationValue      from ._models import JobDescriptionSearchDetailExperience      from ._models import JobDescriptionSearchDetailJobTitle      from ._models import JobDescriptionSearchDetailJobTitleValue      from ._models import JobDescriptionSearchDetailLanguages      from ._models import JobDescriptionSearchDetailLanguagesValueItem      from ._models import JobDescriptionSearchDetailLocation      from ._models import JobDescriptionSearchDetailLocationValue      from ._models import JobDescriptionSearchDetailManagementLevel      from ._models import JobDescriptionSearchDetailOccupationGroup      from ._models import JobDescriptionSearchDetailOccupationGroupValue      from ._models import JobDescriptionSearchDetailSearchExpression      from ._models import JobDescriptionSearchDetailSkills      from ._models import JobDescriptionSearchDetailSkillsValueItem      from ._models import JobDescriptionSearchEmbed      from ._models import JobDescriptionSearchParameters      from ._models import JobDescriptionSearchResult      from ._models import JobTitleAnnotation      from ._models import JobTitleAnnotationParsed      from ._models import JobTitleAnnotationParsedClassification      from ._models import JobTitleAnnotationUpdate      from ._models import JobTitleParsed      from ._models import JobTitleParsedClassification      from ._models import JobTitleParsedParsed      from ._models import JobTitleSearchScoreComponent      from ._models import LanguageAnnotation      from ._models import LanguageAnnotationUpdate      from ._models import LanguagesSearchScoreComponent      from ._models import Location      from ._models import LocationAnnotation      from ._models import LocationAnnotationUpdate      from ._models import LocationAnnotationUpdateParsed      from ._models import LocationSearchScoreComponent      from ._models import ManagementLevelSearchScoreComponent      from ._models import Mapping      from ._models import MappingCreate      from ._models import MappingDataSource      from ._models import MappingDataSourceCreate      from ._models import MappingUpdate      from ._models import Meta      from ._models import MetaChildDocumentsItem      from ._models import MetaParentDocument      from ._models import OccupationGroup      from ._models import OccupationGroupSearchResult      from ._models import OccupationGroupSearchScoreComponent      from ._models import Organization      from ._models import OrganizationCreate      from ._models import OrganizationMembership      from ._models import OrganizationMembershipUpdate      from ._models import OrganizationUpdate      from ._models import OrganizationValidationToolConfig      from ._models import PageMeta      from ._models import PaginatedResponse      from ._models import PaletteColorOptions      from ._models import Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1      from ._models import (
        Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema,
    )      from ._models import Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema      from ._models import Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema      from ._models import Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema      from ._models import Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1      from ._models import Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema      from ._models import (
        Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1,
    )      from ._models import (
        Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1,
    )      from ._models import (
        Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema,
    )      from ._models import (
        Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1,
    )      from ._models import Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema      from ._models import (
        Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
    )      from ._models import (
        Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1,
    )      from ._models import Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1      from ._models import (
        Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
    )      from ._models import PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema      from ._models import PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema      from ._models import (
        PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema,
    )      from ._models import PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1      from ._models import PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1      from ._models import (
        PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema,
    )      from ._models import PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema      from ._models import PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema      from ._models import PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema      from ._models import (
        PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema,
    )      from ._models import (
        PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema,
    )      from ._models import PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1      from ._models import (
        PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema,
    )      from ._models import PhoneNumberAnnotation      from ._models import PhoneNumberAnnotationParsed      from ._models import Rectangle      from ._models import RedactConfig      from ._models import RegionBias      from ._models import RequestError      from ._models import RequestErrorErrorsItem      from ._models import ResthookSubscription      from ._models import ResthookSubscriptionCreate      from ._models import ResthookSubscriptionUpdate      from ._models import ResthookSubscriptionWorkspace      from ._models import Resume      from ._models import ResumeData      from ._models import ResumeDataName      from ._models import ResumeDataPhoneNumberDetailsItem      from ._models import ResumeDataRefereesItem      from ._models import ResumeDataSectionsItem      from ._models import ResumeDataSkillsItem      from ._models import ResumeDataSkillsPropertiesItemsItem      from ._models import ResumeDataWorkExperienceItem      from ._models import ResumeDataWorkExperienceItemDates      from ._models import ResumeDataWorkExperienceItemOccupation      from ._models import ResumeRedact      from ._models import ResumeRedactData      from ._models import ResumeSearch      from ._models import ResumeSearchConfig      from ._models import ResumeSearchConfigSearchToolTheme      from ._models import ResumeSearchDetail      from ._models import ResumeSearchDetailEducation      from ._models import ResumeSearchDetailEducationMissing      from ._models import ResumeSearchDetailEducationValueItem      from ._models import ResumeSearchDetailExperience      from ._models import ResumeSearchDetailJobTitle      from ._models import ResumeSearchDetailJobTitleValueItem      from ._models import ResumeSearchDetailLanguages      from ._models import ResumeSearchDetailLanguagesValueItem      from ._models import ResumeSearchDetailLocation      from ._models import ResumeSearchDetailLocationValue      from ._models import ResumeSearchDetailManagementLevel      from ._models import ResumeSearchDetailOccupationGroup      from ._models import ResumeSearchDetailSearchExpression      from ._models import ResumeSearchDetailSkills      from ._models import ResumeSearchDetailSkillsValueItem      from ._models import ResumeSearchEmbed      from ._models import ResumeSearchMatch      from ._models import ResumeSearchMatchDetails      from ._models import ResumeSearchParameters      from ._models import ResumeSearchParametersCustomData      from ._models import ResumeSearchParametersLocation      from ._models import ResumeSearchParametersLocationCoordinates      from ._models import ResumeSearchParametersSkill      from ._models import ResumeSearchResult      from ._models import ResumeSkill      from ._models import ResumeSkillSourcesItem      from ._models import RowAnnotation      from ._models import RowAnnotationParsed      from ._models import RowBetaAnnotation      from ._models import RowBetaAnnotationParsed      from ._models import SearchConfigAction      from ._models import SearchExpressionSearchScoreComponent      from ._models import SearchParametersCustomData      from ._models import SkillAnnotation      from ._models import SkillAnnotationUpdate      from ._models import SkillsSearchScoreComponent      from ._models import TableAnnotation      from ._models import TableAnnotationParsed      from ._models import TableBetaAnnotation      from ._models import TableBetaAnnotationParsed      from ._models import Tag      from ._models import TagCreate      from ._models import TagUpdate      from ._models import TextAnnotation      from ._models import TextAnnotationUpdate      from ._models import ThemeConfig      from ._models import ThemeConfigPalette      from ._models import ThemeConfigPaletteText      from ._models import ThemeConfigTypography      from ._models import UrlAnnotation      from ._models import UrlAnnotationParsed      from ._models import UsageByCollection      from ._models import UsageByWorkspace      from ._models import User      from ._models import UserNullable      from ._models import ValidationResult      from ._models import ValidationResultCreate      from ._models import ValidationResultUpdate      from ._models import ValidationRule      from ._models import ValidationToolConfig      from ._models import Workspace      from ._models import WorkspaceCollectionsItem      from ._models import WorkspaceCollectionsItemExtractor      from ._models import WorkspaceCreate      from ._models import WorkspaceDocumentSplitter      from ._models import WorkspaceMembership      from ._models import WorkspaceMembershipCreate      from ._models import WorkspaceUpdate      from ._models import YearsExperienceAnnotation      from ._models import YearsExperienceAnnotationParsed      from ._models import YearsExperienceAnnotationUpdate      from ._models import YearsExperienceAnnotationUpdateParsed  
from ._affinda_api_enums import (
    AnnotationContentType,
    CollectionDateFormatPreference,
    DateFormatPreference,
    DateRange,
    DocType,
    DocumentFormat,
    DocumentSplitterType,
    DocumentState,
    EducationLevel,
    Enum22,
    IndexDocType,
    InvitationResponseStatus,
    InvitationStatus,
    JobDescriptionSearchConfigDistanceUnit,
    ManagementLevel,
    OrganizationRole,
    OrganizationUserRole,
    Region,
    ResthookEvent,
    ResthookSubscriptionVersion,
    ResumeDataLanguagesItem,
    ResumeSearchConfigDistanceUnit,
    ResumeSkillSourcesItemSection,
    SearchLocationUnit,
    SearchParametersCustomDataFilterType,
    ThemeConfigPaletteMode,
    Version,
    WorkspaceVisibility,
)
from ._patch import __all__ as _patch_all
from ._patch import *  from ._patch import patch_sdk as _patch_sdk

__all__ = [
    "Accreditation",
    "Annotation",
    "AnnotationBase",
    "AnnotationBatchUpdate",
    "AnnotationCreate",
    "AnnotationUpdate",
    "AnnotationWithValidationResults",
    "AnotationDelete",
    "ApiUserCreate",
    "ApiUserUpdate",
    "ApiUserWithKey",
    "ApiUserWithKeyOrganizationsItem",
    "ApiUserWithoutKey",
    "ApiUserWithoutKeyOrganizationsItem",
    "BaseExtractor",
    "BatchAddTagRequest",
    "BatchDeleteAnnotationsResponse",
    "BatchDeleteValidationResultsRequest",
    "BatchRemoveTagRequest",
    "ChangedValidationResults",
    "Collection",
    "CollectionCreate",
    "CollectionField",
    "CollectionUpdate",
    "CollectionWorkspace",
    "Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1",
    "Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1",
    "Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1",
    "Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification",
    "ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1",
    "ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1",
    "ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties",
    "ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1",
    "CurrencyCodeAnnotation",
    "CustomFieldConfig",
    "DataField",
    "DataFieldCreate",
    "DataFieldCreateDataPoint",
    "DataFieldCreateField",
    "DataFieldDataPoint",
    "DataFieldField",
    "DataPoint",
    "DataPointChoice",
    "DataPointChoiceCreate",
    "DataPointChoiceForReplace",
    "DataPointChoiceReplaceRequest",
    "DataPointChoiceReplaceResponse",
    "DataPointChoiceReplaceResponseChoicesItem",
    "DataPointChoiceUpdate",
    "DataPointCreate",
    "DataPointUpdate",
    "DateAnnotation",
    "DateAnnotationUpdate",
    "DateRangeAnnotation",
    "DateRangeAnnotationParsed",
    "DateRangeValue",
    "Document",
    "DocumentCreate",
    "DocumentEditRequest",
    "DocumentError",
    "DocumentMeta",
    "DocumentMetaChildDocumentsItem",
    "DocumentMetaCollection",
    "DocumentMetaCollectionExtractor",
    "DocumentMetaParentDocument",
    "DocumentMetaWorkspace",
    "DocumentSplit",
    "DocumentSplitPage",
    "DocumentSplitter",
    "DocumentType",
    "DocumentTypeCreate",
    "DocumentTypeUpdate",
    "DocumentUpdate",
    "DocumentWarning",
    "Education",
    "EducationDates",
    "EducationGrade",
    "EducationSearchScoreComponent",
    "ExpectedRemunerationAnnotation",
    "ExpectedRemunerationAnnotationParsed",
    "ExpectedRemunerationAnnotationUpdate",
    "ExpectedRemunerationAnnotationUpdateParsed",
    "ExperienceSearchScoreComponent",
    "Extractor",
    "ExtractorBaseExtractor",
    "ExtractorConfig",
    "ExtractorCreate",
    "ExtractorUpdate",
    "Field",
    "FieldCategory",
    "FieldDeprecated",
    "FieldGroup",
    "FieldsLayout",
    "FloatAnnotation",
    "Get200ApplicationJsonPropertiesItemsItem",
    "Index",
    "IndexCreate",
    "IndexUpdate",
    "IndexUser",
    "Invitation",
    "InvitationCreate",
    "InvitationRespondedBy",
    "InvitationResponse",
    "InvitationUpdate",
    "Invoice",
    "InvoiceData",
    "JobDescription",
    "JobDescriptionData",
    "JobDescriptionDataUpdate",
    "JobDescriptionSearch",
    "JobDescriptionSearchConfig",
    "JobDescriptionSearchConfigSearchToolTheme",
    "JobDescriptionSearchDetail",
    "JobDescriptionSearchDetailEducation",
    "JobDescriptionSearchDetailEducationMissing",
    "JobDescriptionSearchDetailEducationValue",
    "JobDescriptionSearchDetailExperience",
    "JobDescriptionSearchDetailJobTitle",
    "JobDescriptionSearchDetailJobTitleValue",
    "JobDescriptionSearchDetailLanguages",
    "JobDescriptionSearchDetailLanguagesValueItem",
    "JobDescriptionSearchDetailLocation",
    "JobDescriptionSearchDetailLocationValue",
    "JobDescriptionSearchDetailManagementLevel",
    "JobDescriptionSearchDetailOccupationGroup",
    "JobDescriptionSearchDetailOccupationGroupValue",
    "JobDescriptionSearchDetailSearchExpression",
    "JobDescriptionSearchDetailSkills",
    "JobDescriptionSearchDetailSkillsValueItem",
    "JobDescriptionSearchEmbed",
    "JobDescriptionSearchParameters",
    "JobDescriptionSearchResult",
    "JobTitleAnnotation",
    "JobTitleAnnotationParsed",
    "JobTitleAnnotationParsedClassification",
    "JobTitleAnnotationUpdate",
    "JobTitleParsed",
    "JobTitleParsedClassification",
    "JobTitleParsedParsed",
    "JobTitleSearchScoreComponent",
    "LanguageAnnotation",
    "LanguageAnnotationUpdate",
    "LanguagesSearchScoreComponent",
    "Location",
    "LocationAnnotation",
    "LocationAnnotationUpdate",
    "LocationAnnotationUpdateParsed",
    "LocationSearchScoreComponent",
    "ManagementLevelSearchScoreComponent",
    "Mapping",
    "MappingCreate",
    "MappingDataSource",
    "MappingDataSourceCreate",
    "MappingUpdate",
    "Meta",
    "MetaChildDocumentsItem",
    "MetaParentDocument",
    "OccupationGroup",
    "OccupationGroupSearchResult",
    "OccupationGroupSearchScoreComponent",
    "Organization",
    "OrganizationCreate",
    "OrganizationMembership",
    "OrganizationMembershipUpdate",
    "OrganizationUpdate",
    "OrganizationValidationToolConfig",
    "PageMeta",
    "PaginatedResponse",
    "PaletteColorOptions",
    "Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema",
    "Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema",
    "Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema",
    "Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema",
    "Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema",
    "Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema",
    "Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema",
    "Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1",
    "Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1",
    "PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema",
    "PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema",
    "PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema",
    "PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1",
    "PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1",
    "PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema",
    "PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema",
    "PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema",
    "PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema",
    "PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema",
    "PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema",
    "PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1",
    "PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema",
    "PhoneNumberAnnotation",
    "PhoneNumberAnnotationParsed",
    "Rectangle",
    "RedactConfig",
    "RegionBias",
    "RequestError",
    "RequestErrorErrorsItem",
    "ResthookSubscription",
    "ResthookSubscriptionCreate",
    "ResthookSubscriptionUpdate",
    "ResthookSubscriptionWorkspace",
    "Resume",
    "ResumeData",
    "ResumeDataName",
    "ResumeDataPhoneNumberDetailsItem",
    "ResumeDataRefereesItem",
    "ResumeDataSectionsItem",
    "ResumeDataSkillsItem",
    "ResumeDataSkillsPropertiesItemsItem",
    "ResumeDataWorkExperienceItem",
    "ResumeDataWorkExperienceItemDates",
    "ResumeDataWorkExperienceItemOccupation",
    "ResumeRedact",
    "ResumeRedactData",
    "ResumeSearch",
    "ResumeSearchConfig",
    "ResumeSearchConfigSearchToolTheme",
    "ResumeSearchDetail",
    "ResumeSearchDetailEducation",
    "ResumeSearchDetailEducationMissing",
    "ResumeSearchDetailEducationValueItem",
    "ResumeSearchDetailExperience",
    "ResumeSearchDetailJobTitle",
    "ResumeSearchDetailJobTitleValueItem",
    "ResumeSearchDetailLanguages",
    "ResumeSearchDetailLanguagesValueItem",
    "ResumeSearchDetailLocation",
    "ResumeSearchDetailLocationValue",
    "ResumeSearchDetailManagementLevel",
    "ResumeSearchDetailOccupationGroup",
    "ResumeSearchDetailSearchExpression",
    "ResumeSearchDetailSkills",
    "ResumeSearchDetailSkillsValueItem",
    "ResumeSearchEmbed",
    "ResumeSearchMatch",
    "ResumeSearchMatchDetails",
    "ResumeSearchParameters",
    "ResumeSearchParametersCustomData",
    "ResumeSearchParametersLocation",
    "ResumeSearchParametersLocationCoordinates",
    "ResumeSearchParametersSkill",
    "ResumeSearchResult",
    "ResumeSkill",
    "ResumeSkillSourcesItem",
    "RowAnnotation",
    "RowAnnotationParsed",
    "RowBetaAnnotation",
    "RowBetaAnnotationParsed",
    "SearchConfigAction",
    "SearchExpressionSearchScoreComponent",
    "SearchParametersCustomData",
    "SkillAnnotation",
    "SkillAnnotationUpdate",
    "SkillsSearchScoreComponent",
    "TableAnnotation",
    "TableAnnotationParsed",
    "TableBetaAnnotation",
    "TableBetaAnnotationParsed",
    "Tag",
    "TagCreate",
    "TagUpdate",
    "TextAnnotation",
    "TextAnnotationUpdate",
    "ThemeConfig",
    "ThemeConfigPalette",
    "ThemeConfigPaletteText",
    "ThemeConfigTypography",
    "UrlAnnotation",
    "UrlAnnotationParsed",
    "UsageByCollection",
    "UsageByWorkspace",
    "User",
    "UserNullable",
    "ValidationResult",
    "ValidationResultCreate",
    "ValidationResultUpdate",
    "ValidationRule",
    "ValidationToolConfig",
    "Workspace",
    "WorkspaceCollectionsItem",
    "WorkspaceCollectionsItemExtractor",
    "WorkspaceCreate",
    "WorkspaceDocumentSplitter",
    "WorkspaceMembership",
    "WorkspaceMembershipCreate",
    "WorkspaceUpdate",
    "YearsExperienceAnnotation",
    "YearsExperienceAnnotationParsed",
    "YearsExperienceAnnotationUpdate",
    "YearsExperienceAnnotationUpdateParsed",
    "AnnotationContentType",
    "CollectionDateFormatPreference",
    "DateFormatPreference",
    "DateRange",
    "DocType",
    "DocumentFormat",
    "DocumentSplitterType",
    "DocumentState",
    "EducationLevel",
    "Enum22",
    "IndexDocType",
    "InvitationResponseStatus",
    "InvitationStatus",
    "JobDescriptionSearchConfigDistanceUnit",
    "ManagementLevel",
    "OrganizationRole",
    "OrganizationUserRole",
    "Region",
    "ResthookEvent",
    "ResthookSubscriptionVersion",
    "ResumeDataLanguagesItem",
    "ResumeSearchConfigDistanceUnit",
    "ResumeSkillSourcesItemSection",
    "SearchLocationUnit",
    "SearchParametersCustomDataFilterType",
    "ThemeConfigPaletteMode",
    "Version",
    "WorkspaceVisibility",
]
__all__.extend([p for p in _patch_all if p not in __all__])
_patch_sdk()
}
affinda-python-master\affinda\models _models_py3.py{
import datetime
from typing import Any, Dict, IO, List, Optional, TYPE_CHECKING, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

if TYPE_CHECKING:
        import __init__ as _models


class Accreditation(msrest.serialization.Model):
    

    _validation = {
        "input_str": {"readonly": True},
        "match_str": {"readonly": True},
        "education_level": {"readonly": True},
    }

    _attribute_map = {
        "education": {"key": "education", "type": "str"},
        "input_str": {"key": "inputStr", "type": "str"},
        "match_str": {"key": "matchStr", "type": "str"},
        "education_level": {"key": "educationLevel", "type": "str"},
    }

    def __init__(self, *, education: Optional[str] = None, **kwargs):
        
        super(Accreditation, self).__init__(**kwargs)
        self.education = education
        self.input_str = None
        self.match_str = None
        self.education_level = None


class Annotation(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        **kwargs,
    ):
        
        super(Annotation, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.rectangle = rectangle
        self.rectangles = rectangles
        self.document = document
        self.page_index = page_index
        self.raw = raw
        self.confidence = confidence
        self.classification_confidence = classification_confidence
        self.text_extraction_confidence = text_extraction_confidence
        self.is_verified = is_verified
        self.is_client_verified = is_client_verified
        self.is_auto_verified = is_auto_verified
        self.data_point = data_point
        self.content_type = content_type
        self.parent = parent


class AnnotationBase(msrest.serialization.Model):
    

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        **kwargs,
    ):
        
        super(AnnotationBase, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.rectangle = rectangle
        self.rectangles = None
        self.page_index = page_index
        self.raw = raw
        self.confidence = confidence
        self.classification_confidence = classification_confidence
        self.text_extraction_confidence = text_extraction_confidence
        self.is_verified = is_verified
        self.is_client_verified = is_client_verified
        self.is_auto_verified = is_auto_verified
        self.data_point = data_point
        self.content_type = content_type


class AnnotationBatchUpdate(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "page_index": {"minimum": 0},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "parsed": {"key": "parsed", "type": "object"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ChangedValidationResults]"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangles: Optional[List["_models.Rectangle"]] = None,
        document: Optional[str] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        parsed: Optional[Any] = None,
        is_client_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        parent: Optional[int] = None,
        validation_results: Optional[List["_models.ChangedValidationResults"]] = None,
        **kwargs,
    ):
        
        super(AnnotationBatchUpdate, self).__init__(**kwargs)
        self.id = id
        self.rectangles = rectangles
        self.document = document
        self.page_index = page_index
        self.raw = raw
        self.parsed = parsed
        self.is_client_verified = is_client_verified
        self.data_point = data_point
        self.parent = parent
        self.validation_results = validation_results


class AnnotationCreate(msrest.serialization.Model):
    

    _validation = {
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "raw": {"key": "raw", "type": "str"},
        "parsed": {"key": "parsed", "type": "object"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ChangedValidationResults]"},
    }

    def __init__(
        self,
        *,
        document: str,
        page_index: int,
        data_point: str,
        rectangles: Optional[List["_models.Rectangle"]] = None,
        raw: Optional[str] = None,
        parsed: Optional[Any] = None,
        is_client_verified: Optional[bool] = None,
        parent: Optional[int] = None,
        validation_results: Optional[List["_models.ChangedValidationResults"]] = None,
        **kwargs,
    ):
        
        super(AnnotationCreate, self).__init__(**kwargs)
        self.rectangles = rectangles
        self.document = document
        self.page_index = page_index
        self.data_point = data_point
        self.raw = raw
        self.parsed = parsed
        self.is_client_verified = is_client_verified
        self.parent = parent
        self.validation_results = validation_results


class AnnotationUpdate(msrest.serialization.Model):
    

    _validation = {
        "page_index": {"minimum": 0},
    }

    _attribute_map = {
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "parsed": {"key": "parsed", "type": "object"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ChangedValidationResults]"},
    }

    def __init__(
        self,
        *,
        rectangles: Optional[List["_models.Rectangle"]] = None,
        document: Optional[str] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        parsed: Optional[Any] = None,
        is_client_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        parent: Optional[int] = None,
        validation_results: Optional[List["_models.ChangedValidationResults"]] = None,
        **kwargs,
    ):
        
        super(AnnotationUpdate, self).__init__(**kwargs)
        self.rectangles = rectangles
        self.document = document
        self.page_index = page_index
        self.raw = raw
        self.parsed = parsed
        self.is_client_verified = is_client_verified
        self.data_point = data_point
        self.parent = parent
        self.validation_results = validation_results


class AnnotationWithValidationResults(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ValidationResult]"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        validation_results: Optional[List["_models.ValidationResult"]] = None,
        **kwargs,
    ):
        
        super(AnnotationWithValidationResults, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.validation_results = validation_results


class AnotationDelete(msrest.serialization.Model):
    

    _attribute_map = {
        "validation_results": {"key": "validationResults", "type": "object"},
    }

    def __init__(self, *, validation_results: Optional[Any] = None, **kwargs):
        
        super(AnotationDelete, self).__init__(**kwargs)
        self.validation_results = validation_results


class ApiUserCreate(msrest.serialization.Model):
    

    _validation = {
        "organization": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
    }

    def __init__(
        self,
        *,
        organization: str,
        name: Optional[str] = None,
        username: Optional[str] = None,
        email: Optional[str] = None,
        avatar: Optional[str] = None,
        **kwargs,
    ):
        
        super(ApiUserCreate, self).__init__(**kwargs)
        self.name = name
        self.username = username
        self.email = email
        self.avatar = avatar
        self.organization = organization


class ApiUserUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        username: Optional[str] = None,
        email: Optional[str] = None,
        avatar: Optional[str] = None,
        **kwargs,
    ):
        
        super(ApiUserUpdate, self).__init__(**kwargs)
        self.name = name
        self.username = username
        self.email = email
        self.avatar = avatar


class ApiUserWithKey(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "username": {"required": True},
        "email": {"required": True},
        "avatar": {"required": True},
        "organizations": {"required": True},
        "api_key": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "organizations": {"key": "organizations", "type": "[ApiUserWithKeyOrganizationsItem]"},
        "api_key": {"key": "apiKey", "type": "str"},
        "api_key_last_chars": {"key": "apiKeyLastChars", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        name: str,
        username: str,
        email: str,
        avatar: str,
        organizations: List["_models.ApiUserWithKeyOrganizationsItem"],
        api_key: str,
        api_key_last_chars: Optional[str] = None,
        **kwargs,
    ):
        
        super(ApiUserWithKey, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.avatar = avatar
        self.organizations = organizations
        self.api_key = api_key
        self.api_key_last_chars = api_key_last_chars


class ApiUserWithKeyOrganizationsItem(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, *, identifier: str, name: str, **kwargs):
        
        super(ApiUserWithKeyOrganizationsItem, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name


class ApiUserWithoutKey(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "username": {"required": True},
        "email": {"required": True},
        "avatar": {"required": True},
        "organizations": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "organizations": {"key": "organizations", "type": "[ApiUserWithoutKeyOrganizationsItem]"},
        "api_key_last_chars": {"key": "apiKeyLastChars", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        name: str,
        username: str,
        email: str,
        avatar: str,
        organizations: List["_models.ApiUserWithoutKeyOrganizationsItem"],
        api_key_last_chars: Optional[str] = None,
        **kwargs,
    ):
        
        super(ApiUserWithoutKey, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.avatar = avatar
        self.organizations = organizations
        self.api_key_last_chars = api_key_last_chars


class ApiUserWithoutKeyOrganizationsItem(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, *, identifier: str, name: str, **kwargs):
        
        super(ApiUserWithoutKeyOrganizationsItem, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name


class BaseExtractor(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        name_plural: str,
        validatable: bool,
        is_custom: Optional[bool] = None,
        created_dt: Optional[datetime.datetime] = None,
        **kwargs,
    ):
        
        super(BaseExtractor, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.name_plural = name_plural
        self.validatable = validatable
        self.is_custom = is_custom
        self.created_dt = created_dt


class BatchAddTagRequest(msrest.serialization.Model):
    

    _attribute_map = {
        "identifiers": {"key": "identifiers", "type": "[str]"},
        "tag": {"key": "tag", "type": "int"},
    }

    def __init__(
        self, *, identifiers: Optional[List[str]] = None, tag: Optional[int] = None, **kwargs
    ):
        
        super(BatchAddTagRequest, self).__init__(**kwargs)
        self.identifiers = identifiers
        self.tag = tag


class BatchDeleteAnnotationsResponse(msrest.serialization.Model):
    

    _attribute_map = {
        "validation_results": {"key": "validationResults", "type": "object"},
    }

    def __init__(self, *, validation_results: Optional[Any] = None, **kwargs):
        
        super(BatchDeleteAnnotationsResponse, self).__init__(**kwargs)
        self.validation_results = validation_results


class BatchDeleteValidationResultsRequest(msrest.serialization.Model):
    

    _validation = {
        "ids": {"required": True},
    }

    _attribute_map = {
        "ids": {"key": "ids", "type": "[int]"},
    }

    def __init__(self, *, ids: List[int], **kwargs):
        
        super(BatchDeleteValidationResultsRequest, self).__init__(**kwargs)
        self.ids = ids


class BatchRemoveTagRequest(msrest.serialization.Model):
    

    _attribute_map = {
        "identifiers": {"key": "identifiers", "type": "[str]"},
        "tag": {"key": "tag", "type": "int"},
    }

    def __init__(
        self, *, identifiers: Optional[List[str]] = None, tag: Optional[int] = None, **kwargs
    ):
        
        super(BatchRemoveTagRequest, self).__init__(**kwargs)
        self.identifiers = identifiers
        self.tag = tag


class ChangedValidationResults(msrest.serialization.Model):
    

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "created": {"key": "created", "type": "[ValidationResult]"},
        "updated": {"key": "updated", "type": "[ValidationResult]"},
        "deleted": {"key": "deleted", "type": "[ValidationResult]"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        created: Optional[List["_models.ValidationResult"]] = None,
        updated: Optional[List["_models.ValidationResult"]] = None,
        deleted: Optional[List["_models.ValidationResult"]] = None,
        **kwargs,
    ):
        
        super(ChangedValidationResults, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.created = created
        self.updated = updated
        self.deleted = deleted


class Collection(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "unvalidated_docs_count": {"minimum": 0},
        "confirmed_docs_count": {"minimum": 0},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "CollectionWorkspace"},
        "extractor": {"key": "extractor", "type": "Extractor"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "auto_validate_if_validation_rules_pass": {
            "key": "autoValidateIfValidationRulesPass",
            "type": "bool",
        },
        "fields": {"key": "fields", "type": "[FieldGroup]"},
        "fields_layout": {"key": "fieldsLayout", "type": "FieldsLayout"},
        "fields_configured": {"key": "fieldsConfigured", "type": "bool"},
        "date_format_preference": {"key": "dateFormatPreference", "type": "str"},
        "date_format_from_document": {"key": "dateFormatFromDocument", "type": "bool"},
        "extractor_config": {"key": "extractorConfig", "type": "ExtractorConfig"},
        "unvalidated_docs_count": {"key": "unvalidatedDocsCount", "type": "int"},
        "confirmed_docs_count": {"key": "confirmedDocsCount", "type": "int"},
        "ingest_email": {"key": "ingestEmail", "type": "str"},
        "tailored_extractor_requested": {"key": "tailoredExtractorRequested", "type": "bool"},
        "allow_openai": {"key": "allowOpenai", "type": "bool"},
        "trains_extractor": {"key": "trainsExtractor", "type": "bool"},
        "disable_confirmation_if_validation_rules_fail": {
            "key": "disableConfirmationIfValidationRulesFail",
            "type": "bool",
        },
        "auto_refresh_validation_results": {"key": "autoRefreshValidationResults", "type": "bool"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: Optional[str] = None,
        workspace: Optional["_models.CollectionWorkspace"] = None,
        extractor: Optional["_models.Extractor"] = None,
        auto_validation_threshold: Optional[float] = None,
        enable_auto_validation_threshold: Optional[bool] = False,
        auto_validate_if_validation_rules_pass: Optional[bool] = False,
        fields: Optional[List["_models.FieldGroup"]] = None,
        fields_layout: Optional["_models.FieldsLayout"] = None,
        fields_configured: Optional[bool] = None,
        date_format_preference: Optional[
            Union[str, "_models.CollectionDateFormatPreference"]
        ] = None,
        date_format_from_document: Optional[bool] = None,
        extractor_config: Optional["_models.ExtractorConfig"] = None,
        unvalidated_docs_count: Optional[int] = None,
        confirmed_docs_count: Optional[int] = None,
        ingest_email: Optional[str] = None,
        tailored_extractor_requested: Optional[bool] = None,
        allow_openai: Optional[bool] = False,
        trains_extractor: Optional[bool] = None,
        disable_confirmation_if_validation_rules_fail: Optional[bool] = False,
        auto_refresh_validation_results: Optional[bool] = True,
        **kwargs,
    ):
        
        super(Collection, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.workspace = workspace
        self.extractor = extractor
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.auto_validate_if_validation_rules_pass = auto_validate_if_validation_rules_pass
        self.fields = fields
        self.fields_layout = fields_layout
        self.fields_configured = fields_configured
        self.date_format_preference = date_format_preference
        self.date_format_from_document = date_format_from_document
        self.extractor_config = extractor_config
        self.unvalidated_docs_count = unvalidated_docs_count
        self.confirmed_docs_count = confirmed_docs_count
        self.ingest_email = ingest_email
        self.tailored_extractor_requested = tailored_extractor_requested
        self.allow_openai = allow_openai
        self.trains_extractor = trains_extractor
        self.disable_confirmation_if_validation_rules_fail = (
            disable_confirmation_if_validation_rules_fail
        )
        self.auto_refresh_validation_results = auto_refresh_validation_results


class CollectionCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "extractor": {"key": "extractor", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "fields": {"key": "fields", "type": "[FieldGroup]"},
        "fields_layout": {"key": "fieldsLayout", "type": "FieldsLayout"},
        "date_format_preference": {"key": "dateFormatPreference", "type": "str"},
        "date_format_from_document": {"key": "dateFormatFromDocument", "type": "bool"},
        "extractor_config": {"key": "extractorConfig", "type": "ExtractorConfig"},
        "allow_openai": {"key": "allowOpenai", "type": "bool"},
        "trains_extractor": {"key": "trainsExtractor", "type": "bool"},
        "disable_confirmation_if_validation_rules_fail": {
            "key": "disableConfirmationIfValidationRulesFail",
            "type": "bool",
        },
    }

    def __init__(
        self,
        *,
        name: str,
        workspace: str,
        extractor: Optional[str] = None,
        base_extractor: Optional[str] = None,
        auto_validation_threshold: Optional[float] = None,
        enable_auto_validation_threshold: Optional[bool] = False,
        fields: Optional[List["_models.FieldGroup"]] = None,
        fields_layout: Optional["_models.FieldsLayout"] = None,
        date_format_preference: Optional[Union[str, "_models.DateFormatPreference"]] = None,
        date_format_from_document: Optional[bool] = None,
        extractor_config: Optional["_models.ExtractorConfig"] = None,
        allow_openai: Optional[bool] = False,
        trains_extractor: Optional[bool] = None,
        disable_confirmation_if_validation_rules_fail: Optional[bool] = False,
        **kwargs,
    ):
        
        super(CollectionCreate, self).__init__(**kwargs)
        self.name = name
        self.workspace = workspace
        self.extractor = extractor
        self.base_extractor = base_extractor
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.fields = fields
        self.fields_layout = fields_layout
        self.date_format_preference = date_format_preference
        self.date_format_from_document = date_format_from_document
        self.extractor_config = extractor_config
        self.allow_openai = allow_openai
        self.trains_extractor = trains_extractor
        self.disable_confirmation_if_validation_rules_fail = (
            disable_confirmation_if_validation_rules_fail
        )


class CollectionField(msrest.serialization.Model):
    

    _validation = {
        "auto_validation_threshold": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "str"},
    }

    def __init__(
        self,
        *,
        label: Optional[str] = None,
        field_type: Optional[Union[str, "_models.AnnotationContentType"]] = None,
        mandatory: Optional[bool] = None,
        show_dropdown: Optional[bool] = None,
        display_enum_value: Optional[bool] = None,
        auto_validation_threshold: Optional[float] = None,
        enable_auto_validation_threshold: Optional[bool] = None,
        data_source: Optional[str] = None,
        mapping: Optional[str] = None,
        display_raw_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(CollectionField, self).__init__(**kwargs)
        self.label = label
        self.field_type = field_type
        self.mandatory = mandatory
        self.show_dropdown = show_dropdown
        self.display_enum_value = display_enum_value
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.data_source = data_source
        self.mapping = mapping
        self.display_raw_text = display_raw_text


class CollectionUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "fields": {"key": "fields", "type": "[FieldGroup]"},
        "fields_layout": {"key": "fieldsLayout", "type": "FieldsLayout"},
        "date_format_preference": {"key": "dateFormatPreference", "type": "str"},
        "date_format_from_document": {"key": "dateFormatFromDocument", "type": "bool"},
        "extractor_config": {"key": "extractorConfig", "type": "ExtractorConfig"},
        "allow_openai": {"key": "allowOpenai", "type": "bool"},
        "trains_extractor": {"key": "trainsExtractor", "type": "bool"},
        "disable_confirmation_if_validation_rules_fail": {
            "key": "disableConfirmationIfValidationRulesFail",
            "type": "bool",
        },
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        auto_validation_threshold: Optional[float] = None,
        enable_auto_validation_threshold: Optional[bool] = False,
        fields: Optional[List["_models.FieldGroup"]] = None,
        fields_layout: Optional["_models.FieldsLayout"] = None,
        date_format_preference: Optional[Union[str, "_models.DateFormatPreference"]] = None,
        date_format_from_document: Optional[bool] = None,
        extractor_config: Optional["_models.ExtractorConfig"] = None,
        allow_openai: Optional[bool] = False,
        trains_extractor: Optional[bool] = None,
        disable_confirmation_if_validation_rules_fail: Optional[bool] = False,
        **kwargs,
    ):
        
        super(CollectionUpdate, self).__init__(**kwargs)
        self.name = name
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.fields = fields
        self.fields_layout = fields_layout
        self.date_format_preference = date_format_preference
        self.date_format_from_document = date_format_from_document
        self.extractor_config = extractor_config
        self.allow_openai = allow_openai
        self.trains_extractor = trains_extractor
        self.disable_confirmation_if_validation_rules_fail = (
            disable_confirmation_if_validation_rules_fail
        )


class CollectionWorkspace(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        organization: Optional["_models.Organization"] = None,
        name: Optional[str] = None,
        **kwargs,
    ):
        
        super(CollectionWorkspace, self).__init__(**kwargs)
        self.identifier = identifier
        self.organization = organization
        self.name = name


class Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, match: Optional[bool] = None, **kwargs):
        
        super(
            Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1,
            self,
        ).__init__(**kwargs)
        self.match = match


class Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "default": {"key": "default", "type": "str"},
        "paper": {"key": "paper", "type": "str"},
    }

    def __init__(self, *, default: Optional[str] = None, paper: Optional[str] = None, **kwargs):
        
        super(
            Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1, self
        ).__init__(**kwargs)
        self.default = default
        self.paper = paper


class Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, match: Optional[bool] = None, **kwargs):
        
        super(
            Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1,
            self,
        ).__init__(**kwargs)
        self.match = match


class Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification(
    msrest.serialization.Model
):
    

    _validation = {
        "soc_code": {"maximum": 9999, "minimum": 1},
        "minor_group_code": {"maximum": 9999, "minimum": 1},
        "sub_major_group_code": {"maximum": 9999, "minimum": 1},
        "major_group_code": {"maximum": 9999, "minimum": 1},
    }

    _attribute_map = {
        "title": {"key": "title", "type": "str"},
        "minor_group": {"key": "minorGroup", "type": "str"},
        "sub_major_group": {"key": "subMajorGroup", "type": "str"},
        "major_group": {"key": "majorGroup", "type": "str"},
        "soc_code": {"key": "socCode", "type": "int"},
        "minor_group_code": {"key": "minorGroupCode", "type": "int"},
        "sub_major_group_code": {"key": "subMajorGroupCode", "type": "int"},
        "major_group_code": {"key": "majorGroupCode", "type": "int"},
    }

    def __init__(
        self,
        *,
        title: Optional[str] = None,
        minor_group: Optional[str] = None,
        sub_major_group: Optional[str] = None,
        major_group: Optional[str] = None,
        soc_code: Optional[int] = None,
        minor_group_code: Optional[int] = None,
        sub_major_group_code: Optional[int] = None,
        major_group_code: Optional[int] = None,
        **kwargs,
    ):
        
        super(
            Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification,
            self,
        ).__init__(**kwargs)
        self.title = title
        self.minor_group = minor_group
        self.sub_major_group = sub_major_group
        self.major_group = major_group
        self.soc_code = soc_code
        self.minor_group_code = minor_group_code
        self.sub_major_group_code = sub_major_group_code
        self.major_group_code = major_group_code


class ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, match: Optional[bool] = None, **kwargs):
        
        super(
            ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1,
            self,
        ).__init__(**kwargs)
        self.match = match


class ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, match: Optional[bool] = None, **kwargs):
        
        super(
            ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1, self
        ).__init__(**kwargs)
        self.match = match


class ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties(
    msrest.serialization.Model
):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(
            ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties, self
        ).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, match: Optional[bool] = None, **kwargs):
        
        super(
            ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1,
            self,
        ).__init__(**kwargs)
        self.match = match


class CurrencyCodeAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "DataPointChoice"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.DataPointChoice"] = None,
        **kwargs,
    ):
        
        super(CurrencyCodeAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class CustomFieldConfig(msrest.serialization.Model):
    

    _validation = {
        "data_point": {"required": True},
        "weight": {"required": True, "maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "weight": {"key": "weight", "type": "float"},
    }

    def __init__(self, *, data_point: str, weight: float = 0.5, **kwargs):
        
        super(CustomFieldConfig, self).__init__(**kwargs)
        self.data_point = data_point
        self.weight = weight


class DataField(msrest.serialization.Model):
    

    _validation = {
        "field": {"required": True},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "category_label": {"key": "categoryLabel", "type": "str"},
        "field": {"key": "field", "type": "DataFieldField"},
        "data_point": {"key": "dataPoint", "type": "DataFieldDataPoint"},
    }

    def __init__(
        self,
        *,
        field: "_models.DataFieldField",
        data_point: "_models.DataFieldDataPoint",
        category_label: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataField, self).__init__(**kwargs)
        self.category_label = category_label
        self.field = field
        self.data_point = data_point


class DataFieldCreate(msrest.serialization.Model):
    

    _validation = {
        "field": {"required": True},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "category_label": {"key": "categoryLabel", "type": "str"},
        "field": {"key": "field", "type": "DataFieldCreateField"},
        "data_point": {"key": "dataPoint", "type": "DataFieldCreateDataPoint"},
    }

    def __init__(
        self,
        *,
        field: "_models.DataFieldCreateField",
        data_point: "_models.DataFieldCreateDataPoint",
        category_label: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataFieldCreate, self).__init__(**kwargs)
        self.category_label = category_label
        self.field = field
        self.data_point = data_point


class DataFieldCreateDataPoint(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "slug": {"required": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        slug: str,
        type: Union[str, "_models.AnnotationContentType"],
        description: Optional[str] = None,
        multiple: Optional[bool] = None,
        no_rect: Optional[bool] = None,
        parent: Optional[str] = None,
        manual_entry: Optional[bool] = None,
        mapping_data_source: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataFieldCreateDataPoint, self).__init__(**kwargs)
        self.name = name
        self.slug = slug
        self.description = description
        self.type = type
        self.multiple = multiple
        self.no_rect = no_rect
        self.parent = parent
        self.manual_entry = manual_entry
        self.mapping_data_source = mapping_data_source


class DataFieldCreateField(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "auto_validation_threshold": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
    }

    def __init__(
        self,
        *,
        label: str,
        field_type: Optional[Union[str, "_models.AnnotationContentType"]] = None,
        mandatory: Optional[bool] = None,
        show_dropdown: Optional[bool] = None,
        display_enum_value: Optional[bool] = None,
        auto_validation_threshold: Optional[float] = None,
        enable_auto_validation_threshold: Optional[bool] = None,
        data_source: Optional[str] = None,
        mapping: Optional[str] = None,
        display_raw_text: Optional[bool] = None,
        **kwargs,
    ):
        
        super(DataFieldCreateField, self).__init__(**kwargs)
        self.label = label
        self.field_type = field_type
        self.mandatory = mandatory
        self.show_dropdown = show_dropdown
        self.display_enum_value = display_enum_value
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.data_source = data_source
        self.mapping = mapping
        self.display_raw_text = display_raw_text


class DataFieldDataPoint(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "slug": {"required": True},
        "description": {"required": True},
        "type": {"required": True},
        "multiple": {"required": True},
        "no_rect": {"required": True},
        "parent": {"required": True},
        "children": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "children": {"key": "children", "type": "[DataPoint]"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
        "available_data_sources": {"key": "availableDataSources", "type": "[MappingDataSource]"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        slug: str,
        description: str,
        type: Union[str, "_models.AnnotationContentType"],
        multiple: bool,
        no_rect: bool,
        parent: str,
        children: List["_models.DataPoint"],
        manual_entry: Optional[bool] = None,
        available_data_sources: Optional[List["_models.MappingDataSource"]] = None,
        **kwargs,
    ):
        
        super(DataFieldDataPoint, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.slug = slug
        self.description = description
        self.type = type
        self.multiple = multiple
        self.no_rect = no_rect
        self.parent = parent
        self.children = children
        self.manual_entry = manual_entry
        self.available_data_sources = available_data_sources


class DataFieldField(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "mandatory": {"required": True},
        "display_enum_value": {"required": True},
        "auto_validation_threshold": {"required": True, "maximum": 1, "minimum": 0},
        "enabled_child_fields": {"required": True},
        "disabled_child_fields": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "enabled_child_fields": {"key": "enabledChildFields", "type": "[Field]"},
        "disabled_child_fields": {"key": "disabledChildFields", "type": "[Field]"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
    }

    def __init__(
        self,
        *,
        label: str,
        mandatory: bool,
        display_enum_value: bool,
        auto_validation_threshold: float,
        enabled_child_fields: List["_models.Field"],
        disabled_child_fields: List["_models.Field"],
        field_type: Optional[Union[str, "_models.AnnotationContentType"]] = None,
        show_dropdown: Optional[bool] = None,
        enable_auto_validation_threshold: Optional[bool] = None,
        data_source: Optional[str] = None,
        mapping: Optional[str] = None,
        display_raw_text: Optional[bool] = None,
        **kwargs,
    ):
        
        super(DataFieldField, self).__init__(**kwargs)
        self.label = label
        self.field_type = field_type
        self.mandatory = mandatory
        self.show_dropdown = show_dropdown
        self.display_enum_value = display_enum_value
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.enabled_child_fields = enabled_child_fields
        self.disabled_child_fields = disabled_child_fields
        self.data_source = data_source
        self.mapping = mapping
        self.display_raw_text = display_raw_text


class DataPoint(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "slug": {"required": True},
        "annotation_content_type": {"required": True},
        "organization": {"required": True},
        "extractor": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "annotation_content_type": {"key": "annotationContentType", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "extractor": {"key": "extractor", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "children": {"key": "children", "type": "[DataPoint]"},
        "available_data_sources": {"key": "availableDataSources", "type": "[MappingDataSource]"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        slug: str,
        annotation_content_type: Union[str, "_models.AnnotationContentType"],
        organization: "_models.Organization",
        extractor: str,
        description: Optional[str] = None,
        multiple: Optional[bool] = None,
        no_rect: Optional[bool] = None,
        parent: Optional[str] = None,
        children: Optional[List["_models.DataPoint"]] = None,
        available_data_sources: Optional[List["_models.MappingDataSource"]] = None,
        mapping_data_source: Optional[str] = None,
        manual_entry: Optional[bool] = None,
        **kwargs,
    ):
        
        super(DataPoint, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.slug = slug
        self.description = description
        self.annotation_content_type = annotation_content_type
        self.organization = organization
        self.extractor = extractor
        self.multiple = multiple
        self.no_rect = no_rect
        self.parent = parent
        self.children = children
        self.available_data_sources = available_data_sources
        self.mapping_data_source = mapping_data_source
        self.manual_entry = manual_entry


class DataPointChoice(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "label": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        label: str,
        value: str,
        synonyms: Optional[List[str]] = None,
        description: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointChoice, self).__init__(**kwargs)
        self.id = id
        self.label = label
        self.value = value
        self.synonyms = synonyms
        self.description = description


class DataPointChoiceCreate(msrest.serialization.Model):
    

    _validation = {
        "data_point": {"required": True},
        "label": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_point: str,
        label: str,
        value: str,
        organization: Optional[str] = None,
        collection: Optional[str] = None,
        synonyms: Optional[List[str]] = None,
        description: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointChoiceCreate, self).__init__(**kwargs)
        self.data_point = data_point
        self.organization = organization
        self.collection = collection
        self.label = label
        self.value = value
        self.synonyms = synonyms
        self.description = description


class DataPointChoiceForReplace(msrest.serialization.Model):
    

    _validation = {
        "value": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        value: str,
        label: Optional[str] = None,
        synonyms: Optional[List[str]] = None,
        description: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointChoiceForReplace, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.synonyms = synonyms
        self.description = description


class DataPointChoiceReplaceRequest(msrest.serialization.Model):
    

    _validation = {
        "data_point": {"required": True},
        "choices": {"required": True},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "choices": {"key": "choices", "type": "[DataPointChoiceForReplace]"},
    }

    def __init__(
        self,
        *,
        data_point: str,
        choices: List["_models.DataPointChoiceForReplace"],
        collection: Optional[str] = None,
        organization: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointChoiceReplaceRequest, self).__init__(**kwargs)
        self.data_point = data_point
        self.collection = collection
        self.organization = organization
        self.choices = choices


class DataPointChoiceReplaceResponse(msrest.serialization.Model):
    

    _validation = {
        "data_point": {"required": True},
        "collection": {"required": True},
        "organization": {"required": True},
        "choices": {"required": True},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "choices": {"key": "choices", "type": "[DataPointChoiceReplaceResponseChoicesItem]"},
    }

    def __init__(
        self,
        *,
        data_point: str,
        collection: str,
        organization: str,
        choices: List["_models.DataPointChoiceReplaceResponseChoicesItem"],
        **kwargs,
    ):
        
        super(DataPointChoiceReplaceResponse, self).__init__(**kwargs)
        self.data_point = data_point
        self.collection = collection
        self.organization = organization
        self.choices = choices


class DataPointChoiceReplaceResponseChoicesItem(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "value": {"required": True},
        "label": {"required": True},
        "synonyms": {"required": True},
        "description": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self, *, id: int, value: str, label: str, synonyms: List[str], description: str, **kwargs
    ):
        
        super(DataPointChoiceReplaceResponseChoicesItem, self).__init__(**kwargs)
        self.id = id
        self.value = value
        self.label = label
        self.synonyms = synonyms
        self.description = description


class DataPointChoiceUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_point: Optional[str] = None,
        organization: Optional[str] = None,
        collection: Optional[str] = None,
        label: Optional[str] = None,
        value: Optional[str] = None,
        synonyms: Optional[List[str]] = None,
        description: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointChoiceUpdate, self).__init__(**kwargs)
        self.data_point = data_point
        self.organization = organization
        self.collection = collection
        self.label = label
        self.value = value
        self.synonyms = synonyms
        self.description = description


class DataPointCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "slug": {"required": True},
        "annotation_content_type": {"required": True},
        "organization": {"required": True},
        "extractor": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "annotation_content_type": {"key": "annotationContentType", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "extractor": {"key": "extractor", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        slug: str,
        annotation_content_type: Union[str, "_models.AnnotationContentType"],
        organization: str,
        extractor: str,
        description: Optional[str] = None,
        multiple: Optional[bool] = None,
        no_rect: Optional[bool] = None,
        parent: Optional[str] = None,
        manual_entry: Optional[bool] = None,
        mapping_data_source: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointCreate, self).__init__(**kwargs)
        self.name = name
        self.slug = slug
        self.description = description
        self.annotation_content_type = annotation_content_type
        self.organization = organization
        self.extractor = extractor
        self.multiple = multiple
        self.no_rect = no_rect
        self.parent = parent
        self.manual_entry = manual_entry
        self.mapping_data_source = mapping_data_source


class DataPointUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "parent": {"key": "parent", "type": "str"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        slug: Optional[str] = None,
        description: Optional[str] = None,
        parent: Optional[str] = None,
        mapping_data_source: Optional[str] = None,
        **kwargs,
    ):
        
        super(DataPointUpdate, self).__init__(**kwargs)
        self.name = name
        self.slug = slug
        self.description = description
        self.parent = parent
        self.mapping_data_source = mapping_data_source


class DateAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "date"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional[datetime.date] = None,
        **kwargs,
    ):
        
        super(DateAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class DateAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "date"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        parsed: Optional[datetime.date] = None,
        **kwargs,
    ):
        
        super(DateAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = parsed


class DateRangeAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "DateRangeAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.DateRangeAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(DateRangeAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class DateRangeAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "start": {"key": "start", "type": "DateRangeValue"},
        "end": {"key": "end", "type": "DateRangeValue"},
    }

    def __init__(
        self,
        *,
        start: Optional["_models.DateRangeValue"] = None,
        end: Optional["_models.DateRangeValue"] = None,
        **kwargs,
    ):
        
        super(DateRangeAnnotationParsed, self).__init__(**kwargs)
        self.start = start
        self.end = end


class DateRangeValue(msrest.serialization.Model):
    

    _attribute_map = {
        "date": {"key": "date", "type": "date"},
        "is_current": {"key": "isCurrent", "type": "bool"},
        "day": {"key": "day", "type": "int"},
        "month": {"key": "month", "type": "int"},
        "year": {"key": "year", "type": "int"},
    }

    def __init__(
        self,
        *,
        date: Optional[datetime.date] = None,
        is_current: Optional[bool] = None,
        day: Optional[int] = None,
        month: Optional[int] = None,
        year: Optional[int] = None,
        **kwargs,
    ):
        
        super(DateRangeValue, self).__init__(**kwargs)
        self.date = date
        self.is_current = is_current
        self.day = day
        self.month = month
        self.year = year


class Document(msrest.serialization.Model):
    

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "data": {"key": "data", "type": "object"},
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
    }

    _subtype_map = {
        "extractor": {
            "invoice": "Invoice",
            "job-description": "JobDescription",
            "resume": "Resume",
            "resume-redact": "ResumeRedact",
        }
    }

    def __init__(
        self,
        *,
        meta: "_models.DocumentMeta",
        data: Optional[Any] = None,
        error: Optional["_models.DocumentError"] = None,
        warnings: Optional[List["_models.DocumentWarning"]] = None,
        **kwargs,
    ):
        
        super(Document, self).__init__(**kwargs)
        self.data = data
        self.extractor = None          self.meta = meta
        self.error = error
        self.warnings = warnings


class DocumentCreate(msrest.serialization.Model):
    

    _attribute_map = {
        "file": {"key": "file", "type": "IO"},
        "url": {"key": "url", "type": "str"},
        "data": {"key": "data", "type": "object"},
        "collection": {"key": "collection", "type": "str"},
        "document_type": {"key": "documentType", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "wait": {"key": "wait", "type": "bool"},
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "language": {"key": "language", "type": "str"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "region_bias": {"key": "regionBias", "type": "str"},
        "low_priority": {"key": "lowPriority", "type": "bool"},
        "compact": {"key": "compact", "type": "bool"},
        "delete_after_parse": {"key": "deleteAfterParse", "type": "bool"},
        "enable_validation_tool": {"key": "enableValidationTool", "type": "bool"},
        "use_ocr": {"key": "useOcr", "type": "bool"},
        "warning_messages": {"key": "warningMessages", "type": "[DocumentWarning]"},
    }

    def __init__(
        self,
        *,
        file: Optional[IO] = None,
        url: Optional[str] = None,
        data: Optional[Any] = None,
        collection: Optional[str] = None,
        document_type: Optional[str] = None,
        workspace: Optional[str] = None,
        wait: Optional[bool] = True,
        identifier: Optional[str] = None,
        custom_identifier: Optional[str] = None,
        file_name: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        language: Optional[str] = None,
        reject_duplicates: Optional[bool] = None,
        region_bias: Optional[str] = None,
        low_priority: Optional[bool] = None,
        compact: Optional[bool] = None,
        delete_after_parse: Optional[bool] = None,
        enable_validation_tool: Optional[bool] = None,
        use_ocr: Optional[bool] = None,
        warning_messages: Optional[List["_models.DocumentWarning"]] = None,
        **kwargs,
    ):
        
        super(DocumentCreate, self).__init__(**kwargs)
        self.file = file
        self.url = url
        self.data = data
        self.collection = collection
        self.document_type = document_type
        self.workspace = workspace
        self.wait = wait
        self.identifier = identifier
        self.custom_identifier = custom_identifier
        self.file_name = file_name
        self.expiry_time = expiry_time
        self.language = language
        self.reject_duplicates = reject_duplicates
        self.region_bias = region_bias
        self.low_priority = low_priority
        self.compact = compact
        self.delete_after_parse = delete_after_parse
        self.enable_validation_tool = enable_validation_tool
        self.use_ocr = use_ocr
        self.warning_messages = warning_messages


class DocumentEditRequest(msrest.serialization.Model):
    

    _validation = {
        "splits": {"required": True},
    }

    _attribute_map = {
        "splits": {"key": "splits", "type": "[DocumentSplit]"},
    }

    def __init__(self, *, splits: List["_models.DocumentSplit"], **kwargs):
        
        super(DocumentEditRequest, self).__init__(**kwargs)
        self.splits = splits


class DocumentError(msrest.serialization.Model):
    

    _attribute_map = {
        "error_code": {"key": "errorCode", "type": "str"},
        "error_detail": {"key": "errorDetail", "type": "str"},
    }

    def __init__(
        self, *, error_code: Optional[str] = None, error_detail: Optional[str] = None, **kwargs
    ):
        
        super(DocumentError, self).__init__(**kwargs)
        self.error_code = error_code
        self.error_detail = error_detail


class DocumentMeta(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "pages": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "ready": {"key": "ready", "type": "bool"},
        "ready_dt": {"key": "readyDt", "type": "iso-8601"},
        "failed": {"key": "failed", "type": "bool"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "language": {"key": "language", "type": "str"},
        "pdf": {"key": "pdf", "type": "str"},
        "parent_document": {"key": "parentDocument", "type": "DocumentMetaParentDocument"},
        "child_documents": {"key": "childDocuments", "type": "[DocumentMetaChildDocumentsItem]"},
        "pages": {"key": "pages", "type": "[PageMeta]"},
        "is_ocrd": {"key": "isOcrd", "type": "bool"},
        "ocr_confidence": {"key": "ocrConfidence", "type": "float"},
        "review_url": {"key": "reviewUrl", "type": "str"},
        "document_type": {"key": "documentType", "type": "str"},
        "collection": {"key": "collection", "type": "DocumentMetaCollection"},
        "workspace": {"key": "workspace", "type": "DocumentMetaWorkspace"},
        "archived_dt": {"key": "archivedDt", "type": "iso-8601"},
        "is_archived": {"key": "isArchived", "type": "bool"},
        "skip_parse": {"key": "skipParse", "type": "bool"},
        "confirmed_dt": {"key": "confirmedDt", "type": "iso-8601"},
        "confirmed_by": {"key": "confirmedBy", "type": "UserNullable"},
        "is_confirmed": {"key": "isConfirmed", "type": "bool"},
        "rejected_dt": {"key": "rejectedDt", "type": "iso-8601"},
        "rejected_by": {"key": "rejectedBy", "type": "UserNullable"},
        "archived_by": {"key": "archivedBy", "type": "UserNullable"},
        "is_rejected": {"key": "isRejected", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
        "error_code": {"key": "errorCode", "type": "str"},
        "error_detail": {"key": "errorDetail", "type": "str"},
        "file": {"key": "file", "type": "str"},
        "html": {"key": "html", "type": "str"},
        "tags": {"key": "tags", "type": "[Tag]"},
        "created_by": {"key": "createdBy", "type": "User"},
        "source_email": {"key": "sourceEmail", "type": "str"},
        "source_email_address": {"key": "sourceEmailAddress", "type": "str"},
        "region_bias": {"key": "regionBias", "type": "RegionBias"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        pages: List["_models.PageMeta"],
        workspace: "_models.DocumentMetaWorkspace",
        custom_identifier: Optional[str] = None,
        file_name: Optional[str] = None,
        ready: Optional[bool] = None,
        ready_dt: Optional[datetime.datetime] = None,
        failed: Optional[bool] = None,
        expiry_time: Optional[datetime.datetime] = None,
        language: Optional[str] = None,
        pdf: Optional[str] = None,
        parent_document: Optional["_models.DocumentMetaParentDocument"] = None,
        child_documents: Optional[List["_models.DocumentMetaChildDocumentsItem"]] = None,
        is_ocrd: Optional[bool] = None,
        ocr_confidence: Optional[float] = None,
        review_url: Optional[str] = None,
        document_type: Optional[str] = None,
        collection: Optional["_models.DocumentMetaCollection"] = None,
        archived_dt: Optional[datetime.datetime] = None,
        is_archived: Optional[bool] = None,
        skip_parse: Optional[bool] = None,
        confirmed_dt: Optional[datetime.datetime] = None,
        confirmed_by: Optional["_models.UserNullable"] = None,
        is_confirmed: Optional[bool] = None,
        rejected_dt: Optional[datetime.datetime] = None,
        rejected_by: Optional["_models.UserNullable"] = None,
        archived_by: Optional["_models.UserNullable"] = None,
        is_rejected: Optional[bool] = None,
        created_dt: Optional[datetime.datetime] = None,
        error_code: Optional[str] = None,
        error_detail: Optional[str] = None,
        file: Optional[str] = None,
        html: Optional[str] = None,
        tags: Optional[List["_models.Tag"]] = None,
        created_by: Optional["_models.User"] = None,
        source_email: Optional[str] = None,
        source_email_address: Optional[str] = None,
        region_bias: Optional["_models.RegionBias"] = None,
        **kwargs,
    ):
        
        super(DocumentMeta, self).__init__(**kwargs)
        self.identifier = identifier
        self.custom_identifier = custom_identifier
        self.file_name = file_name
        self.ready = ready
        self.ready_dt = ready_dt
        self.failed = failed
        self.expiry_time = expiry_time
        self.language = language
        self.pdf = pdf
        self.parent_document = parent_document
        self.child_documents = child_documents
        self.pages = pages
        self.is_ocrd = is_ocrd
        self.ocr_confidence = ocr_confidence
        self.review_url = review_url
        self.document_type = document_type
        self.collection = collection
        self.workspace = workspace
        self.archived_dt = archived_dt
        self.is_archived = is_archived
        self.skip_parse = skip_parse
        self.confirmed_dt = confirmed_dt
        self.confirmed_by = confirmed_by
        self.is_confirmed = is_confirmed
        self.rejected_dt = rejected_dt
        self.rejected_by = rejected_by
        self.archived_by = archived_by
        self.is_rejected = is_rejected
        self.created_dt = created_dt
        self.error_code = error_code
        self.error_detail = error_detail
        self.file = file
        self.html = html
        self.tags = tags
        self.created_by = created_by
        self.source_email = source_email
        self.source_email_address = source_email_address
        self.region_bias = region_bias


class DocumentMetaChildDocumentsItem(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        custom_identifier: Optional[str] = None,
        **kwargs,
    ):
        
        super(DocumentMetaChildDocumentsItem, self).__init__(**kwargs)
        self.identifier = identifier
        self.custom_identifier = custom_identifier


class DocumentMetaCollection(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "extractor": {"key": "extractor", "type": "DocumentMetaCollectionExtractor"},
        "validation_rules": {"key": "validationRules", "type": "[ValidationRule]"},
        "auto_refresh_validation_results": {"key": "autoRefreshValidationResults", "type": "bool"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: Optional[str] = None,
        extractor: Optional["_models.DocumentMetaCollectionExtractor"] = None,
        validation_rules: Optional[List["_models.ValidationRule"]] = None,
        auto_refresh_validation_results: Optional[bool] = None,
        **kwargs,
    ):
        
        super(DocumentMetaCollection, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.extractor = extractor
        self.validation_rules = validation_rules
        self.auto_refresh_validation_results = auto_refresh_validation_results


class DocumentMetaCollectionExtractor(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        name: Optional[str] = None,
        base_extractor: Optional[str] = None,
        validatable: Optional[bool] = None,
        **kwargs,
    ):
        
        super(DocumentMetaCollectionExtractor, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.base_extractor = base_extractor
        self.validatable = validatable


class DocumentMetaParentDocument(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        custom_identifier: Optional[str] = None,
        **kwargs,
    ):
        
        super(DocumentMetaParentDocument, self).__init__(**kwargs)
        self.identifier = identifier
        self.custom_identifier = custom_identifier


class DocumentMetaWorkspace(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, *, identifier: str, name: Optional[str] = None, **kwargs):
        
        super(DocumentMetaWorkspace, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name


class DocumentSplit(msrest.serialization.Model):
    

    _validation = {
        "pages": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "object"},
        "pages": {"key": "pages", "type": "[DocumentSplitPage]"},
    }

    def __init__(
        self,
        *,
        pages: List["_models.DocumentSplitPage"],
        identifier: Optional[Any] = None,
        **kwargs,
    ):
        
        super(DocumentSplit, self).__init__(**kwargs)
        self.identifier = identifier
        self.pages = pages


class DocumentSplitPage(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rotation": {"maximum": 360, "minimum": -360},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "rotation": {"key": "rotation", "type": "int"},
    }

    def __init__(self, *, id: int, rotation: Optional[int] = None, **kwargs):
        
        super(DocumentSplitPage, self).__init__(**kwargs)
        self.id = id
        self.rotation = rotation


class DocumentSplitter(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "type": {"required": True},
        "organization": {"required": True},
        "extractor": {"required": True},
        "llm_hint": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "extractor": {"key": "extractor", "type": "str"},
        "llm_hint": {"key": "llmHint", "type": "str"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        type: Union[str, "_models.DocumentSplitterType"],
        organization: str,
        extractor: str,
        llm_hint: str,
        **kwargs,
    ):
        
        super(DocumentSplitter, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.type = type
        self.organization = organization
        self.extractor = extractor
        self.llm_hint = llm_hint


class DocumentType(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "organization": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "ingest_email": {"key": "ingest_email", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        organization: str,
        description: Optional[str] = None,
        ingest_email: Optional[str] = None,
        **kwargs,
    ):
        
        super(DocumentType, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.description = description
        self.ingest_email = ingest_email
        self.organization = organization


class DocumentTypeCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "organization": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
    }

    def __init__(
        self, *, name: str, organization: str, description: Optional[str] = None, **kwargs
    ):
        
        super(DocumentTypeCreate, self).__init__(**kwargs)
        self.name = name
        self.description = description
        self.organization = organization


class DocumentTypeUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, *, name: Optional[str] = None, description: Optional[str] = None, **kwargs):
        
        super(DocumentTypeUpdate, self).__init__(**kwargs)
        self.name = name
        self.description = description


class DocumentUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "collection": {"key": "collection", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "is_confirmed": {"key": "isConfirmed", "type": "bool"},
        "is_rejected": {"key": "isRejected", "type": "bool"},
        "is_archived": {"key": "isArchived", "type": "bool"},
        "skip_parse": {"key": "skipParse", "type": "bool"},
        "language": {"key": "language", "type": "str"},
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "warning_messages": {"key": "warningMessages", "type": "[DocumentWarning]"},
    }

    def __init__(
        self,
        *,
        collection: Optional[str] = None,
        file_name: Optional[str] = None,
        expiry_time: Optional[datetime.datetime] = None,
        is_confirmed: Optional[bool] = None,
        is_rejected: Optional[bool] = None,
        is_archived: Optional[bool] = None,
        skip_parse: Optional[bool] = None,
        language: Optional[str] = None,
        identifier: Optional[str] = None,
        custom_identifier: Optional[str] = None,
        warning_messages: Optional[List["_models.DocumentWarning"]] = None,
        **kwargs,
    ):
        
        super(DocumentUpdate, self).__init__(**kwargs)
        self.collection = collection
        self.file_name = file_name
        self.expiry_time = expiry_time
        self.is_confirmed = is_confirmed
        self.is_rejected = is_rejected
        self.is_archived = is_archived
        self.skip_parse = skip_parse
        self.language = language
        self.identifier = identifier
        self.custom_identifier = custom_identifier
        self.warning_messages = warning_messages


class DocumentWarning(msrest.serialization.Model):
    

    _attribute_map = {
        "warning_code": {"key": "warningCode", "type": "str"},
        "warning_detail": {"key": "warningDetail", "type": "str"},
    }

    def __init__(
        self, *, warning_code: Optional[str] = None, warning_detail: Optional[str] = None, **kwargs
    ):
        
        super(DocumentWarning, self).__init__(**kwargs)
        self.warning_code = warning_code
        self.warning_detail = warning_detail


class Education(msrest.serialization.Model):
    

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "organization": {"key": "organization", "type": "str"},
        "accreditation": {"key": "accreditation", "type": "Accreditation"},
        "grade": {"key": "grade", "type": "EducationGrade"},
        "location": {"key": "location", "type": "Location"},
        "dates": {"key": "dates", "type": "EducationDates"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        organization: Optional[str] = None,
        accreditation: Optional["_models.Accreditation"] = None,
        grade: Optional["_models.EducationGrade"] = None,
        location: Optional["_models.Location"] = None,
        dates: Optional["_models.EducationDates"] = None,
        **kwargs,
    ):
        
        super(Education, self).__init__(**kwargs)
        self.id = id
        self.organization = organization
        self.accreditation = accreditation
        self.grade = grade
        self.location = location
        self.dates = dates


class EducationDates(msrest.serialization.Model):
    

    _attribute_map = {
        "completion_date": {"key": "completionDate", "type": "date"},
        "is_current": {"key": "isCurrent", "type": "bool"},
        "start_date": {"key": "startDate", "type": "date"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(
        self,
        *,
        completion_date: Optional[datetime.date] = None,
        is_current: Optional[bool] = None,
        start_date: Optional[datetime.date] = None,
        raw_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(EducationDates, self).__init__(**kwargs)
        self.completion_date = completion_date
        self.is_current = is_current
        self.start_date = start_date
        self.raw_text = raw_text


class EducationGrade(msrest.serialization.Model):
    

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "raw": {"key": "raw", "type": "str"},
        "metric": {"key": "metric", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        raw: Optional[str] = None,
        metric: Optional[str] = None,
        value: Optional[str] = None,
        **kwargs,
    ):
        
        super(EducationGrade, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.raw = raw
        self.metric = metric
        self.value = value


class EducationSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(EducationSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class ExpectedRemunerationAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "ExpectedRemunerationAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.ExpectedRemunerationAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(ExpectedRemunerationAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class ExpectedRemunerationAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
        "currency": {"key": "currency", "type": "str"},
        "unit": {"key": "unit", "type": "str"},
    }

    def __init__(
        self,
        *,
        minimum: Optional[float] = None,
        maximum: Optional[float] = None,
        currency: Optional[str] = None,
        unit: Optional[str] = None,
        **kwargs,
    ):
        
        super(ExpectedRemunerationAnnotationParsed, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
        self.currency = currency
        self.unit = unit


class ExpectedRemunerationAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "ExpectedRemunerationAnnotationUpdateParsed"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        parsed: Optional["_models.ExpectedRemunerationAnnotationUpdateParsed"] = None,
        **kwargs,
    ):
        
        super(ExpectedRemunerationAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = parsed


class ExpectedRemunerationAnnotationUpdateParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
        "currency": {"key": "currency", "type": "str"},
        "unit": {"key": "unit", "type": "str"},
    }

    def __init__(
        self,
        *,
        minimum: Optional[float] = None,
        maximum: Optional[float] = None,
        currency: Optional[str] = None,
        unit: Optional[str] = None,
        **kwargs,
    ):
        
        super(ExpectedRemunerationAnnotationUpdateParsed, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
        self.currency = currency
        self.unit = unit


class ExperienceSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(ExperienceSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class Extractor(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "ExtractorBaseExtractor"},
        "organization": {"key": "organization", "type": "Organization"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "field_groups": {"key": "fieldGroups", "type": "[FieldGroup]"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
        "last_trained_dt": {"key": "lastTrainedDt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        name_plural: str,
        validatable: bool,
        base_extractor: Optional["_models.ExtractorBaseExtractor"] = None,
        organization: Optional["_models.Organization"] = None,
        category: Optional[str] = None,
        is_custom: Optional[bool] = None,
        field_groups: Optional[List["_models.FieldGroup"]] = None,
        created_dt: Optional[datetime.datetime] = None,
        last_trained_dt: Optional[datetime.datetime] = None,
        **kwargs,
    ):
        
        super(Extractor, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.name_plural = name_plural
        self.base_extractor = base_extractor
        self.organization = organization
        self.category = category
        self.validatable = validatable
        self.is_custom = is_custom
        self.field_groups = field_groups
        self.created_dt = created_dt
        self.last_trained_dt = last_trained_dt


class ExtractorBaseExtractor(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        name_plural: str,
        validatable: bool,
        is_custom: Optional[bool] = None,
        created_dt: Optional[datetime.datetime] = None,
        **kwargs,
    ):
        
        super(ExtractorBaseExtractor, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.name_plural = name_plural
        self.validatable = validatable
        self.is_custom = is_custom
        self.created_dt = created_dt


class ExtractorConfig(msrest.serialization.Model):
    

    _attribute_map = {
        "resume_redact": {"key": "resumeRedact", "type": "RedactConfig"},
    }

    def __init__(self, *, resume_redact: Optional["_models.RedactConfig"] = None, **kwargs):
        
        super(ExtractorConfig, self).__init__(**kwargs)
        self.resume_redact = resume_redact


class ExtractorCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "organization": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "field_groups": {"key": "fieldGroups", "type": "[FieldGroup]"},
    }

    def __init__(
        self,
        *,
        name: str,
        organization: str,
        name_plural: Optional[str] = None,
        base_extractor: Optional[str] = None,
        category: Optional[str] = None,
        validatable: Optional[bool] = None,
        field_groups: Optional[List["_models.FieldGroup"]] = None,
        **kwargs,
    ):
        
        super(ExtractorCreate, self).__init__(**kwargs)
        self.name = name
        self.name_plural = name_plural
        self.base_extractor = base_extractor
        self.organization = organization
        self.category = category
        self.validatable = validatable
        self.field_groups = field_groups


class ExtractorUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "field_groups": {"key": "fieldGroups", "type": "[FieldGroup]"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        name_plural: Optional[str] = None,
        base_extractor: Optional[str] = None,
        category: Optional[str] = None,
        validatable: Optional[bool] = None,
        field_groups: Optional[List["_models.FieldGroup"]] = None,
        **kwargs,
    ):
        
        super(ExtractorUpdate, self).__init__(**kwargs)
        self.name = name
        self.name_plural = name_plural
        self.base_extractor = base_extractor
        self.category = category
        self.validatable = validatable
        self.field_groups = field_groups


class Field(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "data_point": {"required": True},
        "field_type": {"required": True},
        "auto_validation_threshold": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "label": {"key": "label", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enable_auto_validation_threshold": {
            "key": "enableAutoValidationThreshold",
            "type": "bool",
        },
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "hide_enum_detail": {"key": "hideEnumDetail", "type": "bool"},
        "drop_null": {"key": "dropNull", "type": "bool"},
        "enabled_child_fields": {"key": "enabledChildFields", "type": "[Field]"},
        "disabled_child_fields": {"key": "disabledChildFields", "type": "[Field]"},
        "slug": {"key": "slug", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
        "fields": {"key": "fields", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        label: str,
        data_point: str,
        field_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        data_source: Optional[str] = None,
        mapping: Optional[str] = None,
        mandatory: Optional[bool] = None,
        auto_validation_threshold: Optional[float] = None,
        enable_auto_validation_threshold: Optional[bool] = None,
        show_dropdown: Optional[bool] = None,
        display_enum_value: Optional[bool] = None,
        hide_enum_detail: Optional[bool] = None,
        drop_null: Optional[bool] = None,
        enabled_child_fields: Optional[List["_models.Field"]] = None,
        disabled_child_fields: Optional[List["_models.Field"]] = None,
        slug: Optional[str] = None,
        display_raw_text: Optional[bool] = None,
        fields: Optional[List[Any]] = None,
        **kwargs,
    ):
        
        super(Field, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.label = label
        self.data_point = data_point
        self.field_type = field_type
        self.data_source = data_source
        self.mapping = mapping
        self.mandatory = mandatory
        self.auto_validation_threshold = auto_validation_threshold
        self.enable_auto_validation_threshold = enable_auto_validation_threshold
        self.show_dropdown = show_dropdown
        self.display_enum_value = display_enum_value
        self.hide_enum_detail = hide_enum_detail
        self.drop_null = drop_null
        self.enabled_child_fields = enabled_child_fields
        self.disabled_child_fields = disabled_child_fields
        self.slug = slug
        self.display_raw_text = display_raw_text
        self.fields = fields


class FieldCategory(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "enabled_fields": {"required": True},
        "disabled_fields": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "enabled_fields": {"key": "enabledFields", "type": "[Field]"},
        "disabled_fields": {"key": "disabledFields", "type": "[Field]"},
    }

    def __init__(
        self,
        *,
        label: str,
        enabled_fields: List["_models.Field"],
        disabled_fields: List["_models.Field"],
        **kwargs,
    ):
        
        super(FieldCategory, self).__init__(**kwargs)
        self.label = label
        self.enabled_fields = enabled_fields
        self.disabled_fields = disabled_fields


class FieldDeprecated(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "field_type": {"required": True},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "label": {"key": "label", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "disabled": {"key": "disabled", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
        "drop_null": {"key": "dropNull", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "fields": {"key": "fields", "type": "[FieldDeprecated]"},
    }

    def __init__(
        self,
        *,
        label: str,
        field_type: Union[str, "_models.AnnotationContentType"],
        data_point: str,
        additional_properties: Optional[Dict[str, Any]] = None,
        slug: Optional[str] = None,
        data_source: Optional[str] = None,
        mapping: Optional[str] = None,
        mandatory: Optional[bool] = None,
        disabled: Optional[bool] = None,
        auto_validation_threshold: Optional[float] = None,
        show_dropdown: Optional[bool] = None,
        display_raw_text: Optional[bool] = None,
        drop_null: Optional[bool] = None,
        display_enum_value: Optional[bool] = None,
        fields: Optional[List["_models.FieldDeprecated"]] = None,
        **kwargs,
    ):
        
        super(FieldDeprecated, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.label = label
        self.slug = slug
        self.field_type = field_type
        self.data_source = data_source
        self.mapping = mapping
        self.data_point = data_point
        self.mandatory = mandatory
        self.disabled = disabled
        self.auto_validation_threshold = auto_validation_threshold
        self.show_dropdown = show_dropdown
        self.display_raw_text = display_raw_text
        self.drop_null = drop_null
        self.display_enum_value = display_enum_value
        self.fields = fields


class FieldGroup(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "fields": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "fields": {"key": "fields", "type": "[FieldDeprecated]"},
    }

    def __init__(self, *, label: str, fields: List["_models.FieldDeprecated"], **kwargs):
        
        super(FieldGroup, self).__init__(**kwargs)
        self.label = label
        self.fields = fields


class FieldsLayout(msrest.serialization.Model):
    

    _validation = {
        "default_category": {"required": True},
        "categories": {"required": True},
    }

    _attribute_map = {
        "default_category": {"key": "defaultCategory", "type": "FieldCategory"},
        "categories": {"key": "categories", "type": "[FieldCategory]"},
    }

    def __init__(
        self,
        *,
        default_category: "_models.FieldCategory",
        categories: List["_models.FieldCategory"],
        **kwargs,
    ):
        
        super(FieldsLayout, self).__init__(**kwargs)
        self.default_category = default_category
        self.categories = categories


class FloatAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "float"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional[float] = None,
        **kwargs,
    ):
        
        super(FloatAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class Get200ApplicationJsonPropertiesItemsItem(msrest.serialization.Model):
    

    _attribute_map = {
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, *, document: Optional[str] = None, **kwargs):
        
        super(Get200ApplicationJsonPropertiesItemsItem, self).__init__(**kwargs)
        self.document = document


class Index(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "doc_type": {"required": True},
        "user": {"required": True, "readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "name": {"key": "name", "type": "str"},
        "doc_type": {"key": "docType", "type": "str"},
        "user": {"key": "user", "type": "IndexUser"},
    }

    def __init__(
        self,
        *,
        name: str,
        doc_type: Union[str, "_models.IndexDocType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        **kwargs,
    ):
        
        super(Index, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.name = name
        self.doc_type = doc_type
        self.user = None


class IndexCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "name": {"key": "name", "type": "str"},
        "doc_type": {"key": "docType", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        additional_properties: Optional[Dict[str, Any]] = None,
        doc_type: Optional[Union[str, "_models.DocType"]] = None,
        **kwargs,
    ):
        
        super(IndexCreate, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.name = name
        self.doc_type = doc_type


class IndexUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, *, name: Optional[str] = None, **kwargs):
        
        super(IndexUpdate, self).__init__(**kwargs)
        self.name = name


class IndexUser(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "email": {"required": True},
        "avatar": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(self, *, id: int, name: str, email: str, avatar: str, **kwargs):
        
        super(IndexUser, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.email = email
        self.avatar = avatar


class Invitation(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "email": {"key": "email", "type": "str"},
        "role": {"key": "role", "type": "str"},
        "status": {"key": "status", "type": "str"},
        "expiry_date": {"key": "expiryDate", "type": "date"},
        "invited_by": {"key": "invitedBy", "type": "User"},
        "responded_by": {"key": "respondedBy", "type": "InvitationRespondedBy"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        organization: Optional["_models.Organization"] = None,
        email: Optional[str] = None,
        role: Optional[Union[str, "_models.OrganizationRole"]] = None,
        status: Optional[Union[str, "_models.InvitationStatus"]] = None,
        expiry_date: Optional[datetime.date] = None,
        invited_by: Optional["_models.User"] = None,
        responded_by: Optional["_models.InvitationRespondedBy"] = None,
        created_dt: Optional[datetime.datetime] = None,
        **kwargs,
    ):
        
        super(Invitation, self).__init__(**kwargs)
        self.identifier = identifier
        self.organization = organization
        self.email = email
        self.role = role
        self.status = status
        self.expiry_date = expiry_date
        self.invited_by = invited_by
        self.responded_by = responded_by
        self.created_dt = created_dt


class InvitationCreate(msrest.serialization.Model):
    

    _validation = {
        "organization": {"required": True},
        "email": {"required": True},
        "role": {"required": True},
    }

    _attribute_map = {
        "organization": {"key": "organization", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "role": {"key": "role", "type": "str"},
    }

    def __init__(
        self,
        *,
        organization: str,
        email: str,
        role: Union[str, "_models.OrganizationRole"],
        **kwargs,
    ):
        
        super(InvitationCreate, self).__init__(**kwargs)
        self.organization = organization
        self.email = email
        self.role = role


class User(msrest.serialization.Model):
    

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        username: Optional[str] = None,
        email: Optional[str] = None,
        avatar: Optional[str] = None,
        **kwargs,
    ):
        
        super(User, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.avatar = avatar


class InvitationRespondedBy(User):
    

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        username: Optional[str] = None,
        email: Optional[str] = None,
        avatar: Optional[str] = None,
        **kwargs,
    ):
        
        super(InvitationRespondedBy, self).__init__(
            id=id, name=name, username=username, email=email, avatar=avatar, **kwargs
        )


class InvitationResponse(msrest.serialization.Model):
    

    _attribute_map = {
        "status": {"key": "status", "type": "str"},
    }

    def __init__(
        self, *, status: Optional[Union[str, "_models.InvitationResponseStatus"]] = None, **kwargs
    ):
        
        super(InvitationResponse, self).__init__(**kwargs)
        self.status = status


class InvitationUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "role": {"key": "role", "type": "str"},
    }

    def __init__(self, *, role: Optional[Union[str, "_models.OrganizationRole"]] = None, **kwargs):
        
        super(InvitationUpdate, self).__init__(**kwargs)
        self.role = role


class Invoice(Document):
    

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "InvoiceData"},
    }

    def __init__(
        self,
        *,
        meta: "_models.DocumentMeta",
        error: Optional["_models.DocumentError"] = None,
        warnings: Optional[List["_models.DocumentWarning"]] = None,
        data: Optional["_models.InvoiceData"] = None,
        **kwargs,
    ):
        
        super(Invoice, self).__init__(meta=meta, error=error, warnings=warnings, **kwargs)
        self.extractor = "invoice"          self.data = data


class InvoiceData(msrest.serialization.Model):
    

    _attribute_map = {
        "tables": {"key": "tables", "type": "[TableAnnotation]"},
        "tables_beta": {"key": "tablesBeta", "type": "[TableBetaAnnotation]"},
        "invoice_date": {"key": "invoiceDate", "type": "DateAnnotation"},
        "invoice_order_date": {"key": "invoiceOrderDate", "type": "DateAnnotation"},
        "payment_date_due": {"key": "paymentDateDue", "type": "DateAnnotation"},
        "payment_amount_base": {"key": "paymentAmountBase", "type": "TextAnnotation"},
        "payment_amount_tax": {"key": "paymentAmountTax", "type": "TextAnnotation"},
        "payment_amount_total": {"key": "paymentAmountTotal", "type": "TextAnnotation"},
        "payment_amount_paid": {"key": "paymentAmountPaid", "type": "TextAnnotation"},
        "payment_amount_due": {"key": "paymentAmountDue", "type": "TextAnnotation"},
        "invoice_number": {"key": "invoiceNumber", "type": "TextAnnotation"},
        "invoice_purchase_order_number": {
            "key": "invoicePurchaseOrderNumber",
            "type": "TextAnnotation",
        },
        "supplier_business_number": {"key": "supplierBusinessNumber", "type": "TextAnnotation"},
        "customer_number": {"key": "customerNumber", "type": "TextAnnotation"},
        "customer_business_number": {"key": "customerBusinessNumber", "type": "TextAnnotation"},
        "payment_reference": {"key": "paymentReference", "type": "TextAnnotation"},
        "bank_account_number": {"key": "bankAccountNumber", "type": "TextAnnotation"},
        "supplier_vat": {"key": "supplierVat", "type": "TextAnnotation"},
        "customer_vat": {"key": "customerVat", "type": "TextAnnotation"},
        "bpay_biller_code": {"key": "bpayBillerCode", "type": "TextAnnotation"},
        "bpay_reference": {"key": "bpayReference", "type": "TextAnnotation"},
        "bank_sort_code": {"key": "bankSortCode", "type": "TextAnnotation"},
        "bank_iban": {"key": "bankIban", "type": "TextAnnotation"},
        "bank_swift": {"key": "bankSwift", "type": "TextAnnotation"},
        "bank_bsb": {"key": "bankBsb", "type": "TextAnnotation"},
        "customer_contact_name": {"key": "customerContactName", "type": "TextAnnotation"},
        "customer_company_name": {"key": "customerCompanyName", "type": "TextAnnotation"},
        "supplier_company_name": {"key": "supplierCompanyName", "type": "TextAnnotation"},
        "customer_billing_address": {
            "key": "customerBillingAddress",
            "type": "LocationAnnotation",
        },
        "customer_delivery_address": {
            "key": "customerDeliveryAddress",
            "type": "LocationAnnotation",
        },
        "supplier_address": {"key": "supplierAddress", "type": "LocationAnnotation"},
        "customer_phone_number": {"key": "customerPhoneNumber", "type": "TextAnnotation"},
        "supplier_phone_number": {"key": "supplierPhoneNumber", "type": "TextAnnotation"},
        "supplier_fax": {"key": "supplierFax", "type": "TextAnnotation"},
        "customer_email": {"key": "customerEmail", "type": "TextAnnotation"},
        "supplier_email": {"key": "supplierEmail", "type": "TextAnnotation"},
        "supplier_website": {"key": "supplierWebsite", "type": "TextAnnotation"},
        "currency_code": {"key": "currencyCode", "type": "CurrencyCodeAnnotation"},
        "custom_fields": {"key": "customFields", "type": "{object}"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(
        self,
        *,
        tables: Optional[List["_models.TableAnnotation"]] = None,
        tables_beta: Optional[List["_models.TableBetaAnnotation"]] = None,
        invoice_date: Optional["_models.DateAnnotation"] = None,
        invoice_order_date: Optional["_models.DateAnnotation"] = None,
        payment_date_due: Optional["_models.DateAnnotation"] = None,
        payment_amount_base: Optional["_models.TextAnnotation"] = None,
        payment_amount_tax: Optional["_models.TextAnnotation"] = None,
        payment_amount_total: Optional["_models.TextAnnotation"] = None,
        payment_amount_paid: Optional["_models.TextAnnotation"] = None,
        payment_amount_due: Optional["_models.TextAnnotation"] = None,
        invoice_number: Optional["_models.TextAnnotation"] = None,
        invoice_purchase_order_number: Optional["_models.TextAnnotation"] = None,
        supplier_business_number: Optional["_models.TextAnnotation"] = None,
        customer_number: Optional["_models.TextAnnotation"] = None,
        customer_business_number: Optional["_models.TextAnnotation"] = None,
        payment_reference: Optional["_models.TextAnnotation"] = None,
        bank_account_number: Optional["_models.TextAnnotation"] = None,
        supplier_vat: Optional["_models.TextAnnotation"] = None,
        customer_vat: Optional["_models.TextAnnotation"] = None,
        bpay_biller_code: Optional["_models.TextAnnotation"] = None,
        bpay_reference: Optional["_models.TextAnnotation"] = None,
        bank_sort_code: Optional["_models.TextAnnotation"] = None,
        bank_iban: Optional["_models.TextAnnotation"] = None,
        bank_swift: Optional["_models.TextAnnotation"] = None,
        bank_bsb: Optional["_models.TextAnnotation"] = None,
        customer_contact_name: Optional["_models.TextAnnotation"] = None,
        customer_company_name: Optional["_models.TextAnnotation"] = None,
        supplier_company_name: Optional["_models.TextAnnotation"] = None,
        customer_billing_address: Optional["_models.LocationAnnotation"] = None,
        customer_delivery_address: Optional["_models.LocationAnnotation"] = None,
        supplier_address: Optional["_models.LocationAnnotation"] = None,
        customer_phone_number: Optional["_models.TextAnnotation"] = None,
        supplier_phone_number: Optional["_models.TextAnnotation"] = None,
        supplier_fax: Optional["_models.TextAnnotation"] = None,
        customer_email: Optional["_models.TextAnnotation"] = None,
        supplier_email: Optional["_models.TextAnnotation"] = None,
        supplier_website: Optional["_models.TextAnnotation"] = None,
        currency_code: Optional["_models.CurrencyCodeAnnotation"] = None,
        custom_fields: Optional[Dict[str, Any]] = None,
        raw_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(InvoiceData, self).__init__(**kwargs)
        self.tables = tables
        self.tables_beta = tables_beta
        self.invoice_date = invoice_date
        self.invoice_order_date = invoice_order_date
        self.payment_date_due = payment_date_due
        self.payment_amount_base = payment_amount_base
        self.payment_amount_tax = payment_amount_tax
        self.payment_amount_total = payment_amount_total
        self.payment_amount_paid = payment_amount_paid
        self.payment_amount_due = payment_amount_due
        self.invoice_number = invoice_number
        self.invoice_purchase_order_number = invoice_purchase_order_number
        self.supplier_business_number = supplier_business_number
        self.customer_number = customer_number
        self.customer_business_number = customer_business_number
        self.payment_reference = payment_reference
        self.bank_account_number = bank_account_number
        self.supplier_vat = supplier_vat
        self.customer_vat = customer_vat
        self.bpay_biller_code = bpay_biller_code
        self.bpay_reference = bpay_reference
        self.bank_sort_code = bank_sort_code
        self.bank_iban = bank_iban
        self.bank_swift = bank_swift
        self.bank_bsb = bank_bsb
        self.customer_contact_name = customer_contact_name
        self.customer_company_name = customer_company_name
        self.supplier_company_name = supplier_company_name
        self.customer_billing_address = customer_billing_address
        self.customer_delivery_address = customer_delivery_address
        self.supplier_address = supplier_address
        self.customer_phone_number = customer_phone_number
        self.supplier_phone_number = supplier_phone_number
        self.supplier_fax = supplier_fax
        self.customer_email = customer_email
        self.supplier_email = supplier_email
        self.supplier_website = supplier_website
        self.currency_code = currency_code
        self.custom_fields = custom_fields
        self.raw_text = raw_text


class JobDescription(Document):
    

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "JobDescriptionData"},
    }

    def __init__(
        self,
        *,
        meta: "_models.DocumentMeta",
        error: Optional["_models.DocumentError"] = None,
        warnings: Optional[List["_models.DocumentWarning"]] = None,
        data: Optional["_models.JobDescriptionData"] = None,
        **kwargs,
    ):
        
        super(JobDescription, self).__init__(meta=meta, error=error, warnings=warnings, **kwargs)
        self.extractor = "job-description"          self.data = data


class JobDescriptionData(msrest.serialization.Model):
    

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "job_title": {"key": "jobTitle", "type": "JobTitleAnnotation"},
        "contact_email": {"key": "contactEmail", "type": "TextAnnotation"},
        "contact_name": {"key": "contactName", "type": "TextAnnotation"},
        "contact_phone": {"key": "contactPhone", "type": "TextAnnotation"},
        "start_date": {"key": "startDate", "type": "DateAnnotation"},
        "end_date": {"key": "endDate", "type": "DateAnnotation"},
        "job_type": {"key": "jobType", "type": "TextAnnotation"},
        "languages": {"key": "languages", "type": "[LanguageAnnotation]"},
        "skills": {"key": "skills", "type": "[SkillAnnotation]"},
        "organization_name": {"key": "organizationName", "type": "TextAnnotation"},
        "organization_website": {"key": "organizationWebsite", "type": "TextAnnotation"},
        "education_level": {"key": "educationLevel", "type": "TextAnnotation"},
        "education_accreditation": {"key": "educationAccreditation", "type": "TextAnnotation"},
        "expected_remuneration": {
            "key": "expectedRemuneration",
            "type": "ExpectedRemunerationAnnotation",
        },
        "location": {"key": "location", "type": "LocationAnnotation"},
        "certifications": {"key": "certifications", "type": "[TextAnnotation]"},
        "years_experience": {"key": "yearsExperience", "type": "YearsExperienceAnnotation"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        job_title: Optional["_models.JobTitleAnnotation"] = None,
        contact_email: Optional["_models.TextAnnotation"] = None,
        contact_name: Optional["_models.TextAnnotation"] = None,
        contact_phone: Optional["_models.TextAnnotation"] = None,
        start_date: Optional["_models.DateAnnotation"] = None,
        end_date: Optional["_models.DateAnnotation"] = None,
        job_type: Optional["_models.TextAnnotation"] = None,
        languages: Optional[List["_models.LanguageAnnotation"]] = None,
        skills: Optional[List["_models.SkillAnnotation"]] = None,
        organization_name: Optional["_models.TextAnnotation"] = None,
        organization_website: Optional["_models.TextAnnotation"] = None,
        education_level: Optional["_models.TextAnnotation"] = None,
        education_accreditation: Optional["_models.TextAnnotation"] = None,
        expected_remuneration: Optional["_models.ExpectedRemunerationAnnotation"] = None,
        location: Optional["_models.LocationAnnotation"] = None,
        certifications: Optional[List["_models.TextAnnotation"]] = None,
        years_experience: Optional["_models.YearsExperienceAnnotation"] = None,
        raw_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(JobDescriptionData, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.job_title = job_title
        self.contact_email = contact_email
        self.contact_name = contact_name
        self.contact_phone = contact_phone
        self.start_date = start_date
        self.end_date = end_date
        self.job_type = job_type
        self.languages = languages
        self.skills = skills
        self.organization_name = organization_name
        self.organization_website = organization_website
        self.education_level = education_level
        self.education_accreditation = education_accreditation
        self.expected_remuneration = expected_remuneration
        self.location = location
        self.certifications = certifications
        self.years_experience = years_experience
        self.raw_text = raw_text


class JobDescriptionDataUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "job_title": {"key": "jobTitle", "type": "JobTitleAnnotationUpdate"},
        "contact_email": {"key": "contactEmail", "type": "TextAnnotationUpdate"},
        "contact_name": {"key": "contactName", "type": "TextAnnotationUpdate"},
        "contact_phone": {"key": "contactPhone", "type": "TextAnnotationUpdate"},
        "start_date": {"key": "startDate", "type": "DateAnnotationUpdate"},
        "end_date": {"key": "endDate", "type": "DateAnnotationUpdate"},
        "job_type": {"key": "jobType", "type": "TextAnnotationUpdate"},
        "languages": {"key": "languages", "type": "[LanguageAnnotationUpdate]"},
        "skills": {"key": "skills", "type": "[SkillAnnotationUpdate]"},
        "organization_name": {"key": "organizationName", "type": "TextAnnotationUpdate"},
        "organization_website": {"key": "organizationWebsite", "type": "TextAnnotationUpdate"},
        "education_level": {"key": "educationLevel", "type": "TextAnnotationUpdate"},
        "education_accreditation": {
            "key": "educationAccreditation",
            "type": "TextAnnotationUpdate",
        },
        "expected_remuneration": {
            "key": "expectedRemuneration",
            "type": "ExpectedRemunerationAnnotationUpdate",
        },
        "location": {"key": "location", "type": "LocationAnnotationUpdate"},
        "certifications": {"key": "certifications", "type": "[TextAnnotationUpdate]"},
        "years_experience": {"key": "yearsExperience", "type": "YearsExperienceAnnotationUpdate"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        job_title: Optional["_models.JobTitleAnnotationUpdate"] = None,
        contact_email: Optional["_models.TextAnnotationUpdate"] = None,
        contact_name: Optional["_models.TextAnnotationUpdate"] = None,
        contact_phone: Optional["_models.TextAnnotationUpdate"] = None,
        start_date: Optional["_models.DateAnnotationUpdate"] = None,
        end_date: Optional["_models.DateAnnotationUpdate"] = None,
        job_type: Optional["_models.TextAnnotationUpdate"] = None,
        languages: Optional[List["_models.LanguageAnnotationUpdate"]] = None,
        skills: Optional[List["_models.SkillAnnotationUpdate"]] = None,
        organization_name: Optional["_models.TextAnnotationUpdate"] = None,
        organization_website: Optional["_models.TextAnnotationUpdate"] = None,
        education_level: Optional["_models.TextAnnotationUpdate"] = None,
        education_accreditation: Optional["_models.TextAnnotationUpdate"] = None,
        expected_remuneration: Optional["_models.ExpectedRemunerationAnnotationUpdate"] = None,
        location: Optional["_models.LocationAnnotationUpdate"] = None,
        certifications: Optional[List["_models.TextAnnotationUpdate"]] = None,
        years_experience: Optional["_models.YearsExperienceAnnotationUpdate"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionDataUpdate, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.job_title = job_title
        self.contact_email = contact_email
        self.contact_name = contact_name
        self.contact_phone = contact_phone
        self.start_date = start_date
        self.end_date = end_date
        self.job_type = job_type
        self.languages = languages
        self.skills = skills
        self.organization_name = organization_name
        self.organization_website = organization_website
        self.education_level = education_level
        self.education_accreditation = education_accreditation
        self.expected_remuneration = expected_remuneration
        self.location = location
        self.certifications = certifications
        self.years_experience = years_experience


class JobDescriptionSearch(msrest.serialization.Model):
    

    _validation = {
        "count": {"minimum": 0},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
        "parameters": {"key": "parameters", "type": "JobDescriptionSearchParameters"},
        "results": {"key": "results", "type": "[JobDescriptionSearchResult]"},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        parameters: Optional["_models.JobDescriptionSearchParameters"] = None,
        results: Optional[List["_models.JobDescriptionSearchResult"]] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearch, self).__init__(**kwargs)
        self.count = count
        self.next = next
        self.previous = previous
        self.parameters = parameters
        self.results = results


class JobDescriptionSearchConfig(msrest.serialization.Model):
    

    _validation = {
        "max_results": {"minimum": 1},
        "user_id": {"readonly": True, "minimum": 1},
        "username": {"readonly": True},
    }

    _attribute_map = {
        "allow_pdf_download": {"key": "allowPdfDownload", "type": "bool"},
        "max_results": {"key": "maxResults", "type": "int"},
        "display_job_title": {"key": "displayJobTitle", "type": "bool"},
        "display_location": {"key": "displayLocation", "type": "bool"},
        "display_years_experience": {"key": "displayYearsExperience", "type": "bool"},
        "display_occupation_group": {"key": "displayOccupationGroup", "type": "bool"},
        "display_education": {"key": "displayEducation", "type": "bool"},
        "display_skills": {"key": "displaySkills", "type": "bool"},
        "display_languages": {"key": "displayLanguages", "type": "bool"},
        "display_management_level": {"key": "displayManagementLevel", "type": "bool"},
        "display_keywords": {"key": "displayKeywords", "type": "bool"},
        "weight_job_title": {"key": "weightJobTitle", "type": "float"},
        "weight_location": {"key": "weightLocation", "type": "float"},
        "weight_years_experience": {"key": "weightYearsExperience", "type": "float"},
        "weight_occupation_group": {"key": "weightOccupationGroup", "type": "float"},
        "weight_education": {"key": "weightEducation", "type": "float"},
        "weight_skills": {"key": "weightSkills", "type": "float"},
        "weight_languages": {"key": "weightLanguages", "type": "float"},
        "weight_management_level": {"key": "weightManagementLevel", "type": "float"},
        "weight_keywords": {"key": "weightKeywords", "type": "float"},
        "indices": {"key": "indices", "type": "[str]"},
        "show_index_dropdown": {"key": "showIndexDropdown", "type": "bool"},
        "search_tool_theme": {
            "key": "searchToolTheme",
            "type": "JobDescriptionSearchConfigSearchToolTheme",
        },
        "user_id": {"key": "userId", "type": "int"},
        "username": {"key": "username", "type": "str"},
        "actions": {"key": "actions", "type": "[SearchConfigAction]"},
        "hide_toolbar": {"key": "hideToolbar", "type": "bool"},
        "hide_side_panel": {"key": "hideSidePanel", "type": "bool"},
        "custom_fields_config": {"key": "customFieldsConfig", "type": "[CustomFieldConfig]"},
        "distance_unit": {"key": "distanceUnit", "type": "str"},
    }

    def __init__(
        self,
        *,
        allow_pdf_download: Optional[bool] = None,
        max_results: Optional[int] = None,
        display_job_title: Optional[bool] = None,
        display_location: Optional[bool] = None,
        display_years_experience: Optional[bool] = None,
        display_occupation_group: Optional[bool] = None,
        display_education: Optional[bool] = None,
        display_skills: Optional[bool] = None,
        display_languages: Optional[bool] = None,
        display_management_level: Optional[bool] = None,
        display_keywords: Optional[bool] = None,
        weight_job_title: Optional[float] = None,
        weight_location: Optional[float] = None,
        weight_years_experience: Optional[float] = None,
        weight_occupation_group: Optional[float] = None,
        weight_education: Optional[float] = None,
        weight_skills: Optional[float] = None,
        weight_languages: Optional[float] = None,
        weight_management_level: Optional[float] = None,
        weight_keywords: Optional[float] = None,
        indices: Optional[List[str]] = None,
        show_index_dropdown: Optional[bool] = None,
        search_tool_theme: Optional["_models.JobDescriptionSearchConfigSearchToolTheme"] = None,
        actions: Optional[List["_models.SearchConfigAction"]] = None,
        hide_toolbar: Optional[bool] = None,
        hide_side_panel: Optional[bool] = None,
        custom_fields_config: Optional[List["_models.CustomFieldConfig"]] = None,
        distance_unit: Optional[
            Union[str, "_models.JobDescriptionSearchConfigDistanceUnit"]
        ] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchConfig, self).__init__(**kwargs)
        self.allow_pdf_download = allow_pdf_download
        self.max_results = max_results
        self.display_job_title = display_job_title
        self.display_location = display_location
        self.display_years_experience = display_years_experience
        self.display_occupation_group = display_occupation_group
        self.display_education = display_education
        self.display_skills = display_skills
        self.display_languages = display_languages
        self.display_management_level = display_management_level
        self.display_keywords = display_keywords
        self.weight_job_title = weight_job_title
        self.weight_location = weight_location
        self.weight_years_experience = weight_years_experience
        self.weight_occupation_group = weight_occupation_group
        self.weight_education = weight_education
        self.weight_skills = weight_skills
        self.weight_languages = weight_languages
        self.weight_management_level = weight_management_level
        self.weight_keywords = weight_keywords
        self.indices = indices
        self.show_index_dropdown = show_index_dropdown
        self.search_tool_theme = search_tool_theme
        self.user_id = None
        self.username = None
        self.actions = actions
        self.hide_toolbar = hide_toolbar
        self.hide_side_panel = hide_side_panel
        self.custom_fields_config = custom_fields_config
        self.distance_unit = distance_unit


class ThemeConfig(msrest.serialization.Model):
    

    _attribute_map = {
        "palette": {"key": "palette", "type": "ThemeConfigPalette"},
        "typography": {"key": "typography", "type": "ThemeConfigTypography"},
        "border_radius": {"key": "borderRadius", "type": "float"},
        "font_url": {"key": "fontUrl", "type": "str"},
    }

    def __init__(
        self,
        *,
        palette: Optional["_models.ThemeConfigPalette"] = None,
        typography: Optional["_models.ThemeConfigTypography"] = None,
        border_radius: Optional[float] = None,
        font_url: Optional[str] = None,
        **kwargs,
    ):
        
        super(ThemeConfig, self).__init__(**kwargs)
        self.palette = palette
        self.typography = typography
        self.border_radius = border_radius
        self.font_url = font_url


class JobDescriptionSearchConfigSearchToolTheme(ThemeConfig):
    

    _attribute_map = {
        "palette": {"key": "palette", "type": "ThemeConfigPalette"},
        "typography": {"key": "typography", "type": "ThemeConfigTypography"},
        "border_radius": {"key": "borderRadius", "type": "float"},
        "font_url": {"key": "fontUrl", "type": "str"},
    }

    def __init__(
        self,
        *,
        palette: Optional["_models.ThemeConfigPalette"] = None,
        typography: Optional["_models.ThemeConfigTypography"] = None,
        border_radius: Optional[float] = None,
        font_url: Optional[str] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchConfigSearchToolTheme, self).__init__(
            palette=palette,
            typography=typography,
            border_radius=border_radius,
            font_url=font_url,
            **kwargs,
        )


class JobDescriptionSearchDetail(msrest.serialization.Model):
    

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "JobDescriptionSearchDetailJobTitle"},
        "location": {"key": "location", "type": "JobDescriptionSearchDetailLocation"},
        "education": {"key": "education", "type": "JobDescriptionSearchDetailEducation"},
        "skills": {"key": "skills", "type": "JobDescriptionSearchDetailSkills"},
        "experience": {"key": "experience", "type": "JobDescriptionSearchDetailExperience"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "JobDescriptionSearchDetailOccupationGroup",
        },
        "languages": {"key": "languages", "type": "JobDescriptionSearchDetailLanguages"},
        "management_level": {
            "key": "managementLevel",
            "type": "JobDescriptionSearchDetailManagementLevel",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "JobDescriptionSearchDetailSearchExpression",
        },
    }

    def __init__(
        self,
        *,
        job_title: Optional["_models.JobDescriptionSearchDetailJobTitle"] = None,
        location: Optional["_models.JobDescriptionSearchDetailLocation"] = None,
        education: Optional["_models.JobDescriptionSearchDetailEducation"] = None,
        skills: Optional["_models.JobDescriptionSearchDetailSkills"] = None,
        experience: Optional["_models.JobDescriptionSearchDetailExperience"] = None,
        occupation_group: Optional["_models.JobDescriptionSearchDetailOccupationGroup"] = None,
        languages: Optional["_models.JobDescriptionSearchDetailLanguages"] = None,
        management_level: Optional["_models.JobDescriptionSearchDetailManagementLevel"] = None,
        search_expression: Optional["_models.JobDescriptionSearchDetailSearchExpression"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetail, self).__init__(**kwargs)
        self.job_title = job_title
        self.location = location
        self.education = education
        self.skills = skills
        self.experience = experience
        self.occupation_group = occupation_group
        self.languages = languages
        self.management_level = management_level
        self.search_expression = search_expression


class JobDescriptionSearchDetailEducation(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "JobDescriptionSearchDetailEducationMissing"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailEducationValue"},
    }

    def __init__(
        self,
        *,
        missing: Optional["_models.JobDescriptionSearchDetailEducationMissing"] = None,
        value: Optional["_models.JobDescriptionSearchDetailEducationValue"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailEducation, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class JobDescriptionSearchDetailEducationMissing(msrest.serialization.Model):
    

    _attribute_map = {
        "degrees": {"key": "degrees", "type": "[str]"},
        "degree_types": {"key": "degreeTypes", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        degrees: Optional[List[str]] = None,
        degree_types: Optional[List[str]] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailEducationMissing, self).__init__(**kwargs)
        self.degrees = degrees
        self.degree_types = degree_types


class JobDescriptionSearchDetailEducationValue(msrest.serialization.Model):
    

    _attribute_map = {
        "degrees": {"key": "degrees", "type": "[str]"},
        "degree_types": {"key": "degreeTypes", "type": "[str]"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(
        self,
        *,
        degrees: Optional[List[str]] = None,
        degree_types: Optional[List[str]] = None,
        match: Optional[bool] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailEducationValue, self).__init__(**kwargs)
        self.degrees = degrees
        self.degree_types = degree_types
        self.match = match


class JobDescriptionSearchDetailExperience(msrest.serialization.Model):
    

    _validation = {
        "minimum_experience": {"minimum": 0},
        "maximum_experience": {"minimum": 0},
    }

    _attribute_map = {
        "minimum_experience": {"key": "minimumExperience", "type": "int"},
        "maximum_experience": {"key": "maximumExperience", "type": "int"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(
        self,
        *,
        minimum_experience: Optional[int] = None,
        maximum_experience: Optional[int] = None,
        match: Optional[bool] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailExperience, self).__init__(**kwargs)
        self.minimum_experience = minimum_experience
        self.maximum_experience = maximum_experience
        self.match = match


class JobDescriptionSearchDetailJobTitle(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailJobTitleValue"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List[str]] = None,
        value: Optional["_models.JobDescriptionSearchDetailJobTitleValue"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailJobTitle, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class JobDescriptionSearchDetailJobTitleValue(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "company_name": {"key": "companyName", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        company_name: Optional[str] = None,
        match: Optional[bool] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailJobTitleValue, self).__init__(**kwargs)
        self.name = name
        self.company_name = company_name
        self.match = match


class JobDescriptionSearchDetailLanguages(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[JobDescriptionSearchDetailLanguagesValueItem]"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        value: Optional[List["_models.JobDescriptionSearchDetailLanguagesValueItem"]] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailLanguages, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class JobDescriptionSearchDetailLanguagesValueItem(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, name: Optional[str] = None, match: Optional[bool] = None, **kwargs):
        
        super(JobDescriptionSearchDetailLanguagesValueItem, self).__init__(**kwargs)
        self.name = name
        self.match = match


class JobDescriptionSearchDetailLocation(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersLocation]"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailLocationValue"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List["_models.ResumeSearchParametersLocation"]] = None,
        value: Optional["_models.JobDescriptionSearchDetailLocationValue"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailLocation, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class Location(msrest.serialization.Model):
    

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, *, raw_input: str, **kwargs):
        
        super(Location, self).__init__(**kwargs)
        self.formatted = None
        self.postal_code = None
        self.state = None
        self.state_code = None
        self.country = None
        self.country_code = None
        self.raw_input = raw_input
        self.street_number = None
        self.street = None
        self.apartment_number = None
        self.city = None
        self.latitude = None
        self.longitude = None
        self.po_box = None


class JobDescriptionSearchDetailLocationValue(
    Location,
    Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1,
):
    

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, *, raw_input: str, match: Optional[bool] = None, **kwargs):
        
        super(JobDescriptionSearchDetailLocationValue, self).__init__(
            raw_input=raw_input, match=match, **kwargs
        )
        self.match = match
        self.formatted = None
        self.postal_code = None
        self.state = None
        self.state_code = None
        self.country = None
        self.country_code = None
        self.raw_input = raw_input
        self.street_number = None
        self.street = None
        self.apartment_number = None
        self.city = None
        self.latitude = None
        self.longitude = None
        self.po_box = None


class JobDescriptionSearchDetailManagementLevel(msrest.serialization.Model):
    

    _attribute_map = {
        "level": {"key": "level", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(
        self,
        *,
        level: Optional[Union[str, "_models.ManagementLevel"]] = None,
        match: Optional[bool] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailManagementLevel, self).__init__(**kwargs)
        self.level = level
        self.match = match


class JobDescriptionSearchDetailOccupationGroup(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[int]"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailOccupationGroupValue"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List[int]] = None,
        value: Optional["_models.JobDescriptionSearchDetailOccupationGroupValue"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailOccupationGroup, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class OccupationGroupSearchResult(msrest.serialization.Model):
    

    _validation = {
        "code": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "code": {"key": "code", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "children": {"key": "children", "type": "[OccupationGroup]"},
        "parents": {"key": "parents", "type": "[OccupationGroup]"},
    }

    def __init__(
        self,
        *,
        code: int,
        name: str,
        match: Optional[bool] = None,
        children: Optional[List["_models.OccupationGroup"]] = None,
        parents: Optional[List["_models.OccupationGroup"]] = None,
        **kwargs,
    ):
        
        super(OccupationGroupSearchResult, self).__init__(**kwargs)
        self.match = match
        self.code = code
        self.name = name
        self.children = children
        self.parents = parents


class JobDescriptionSearchDetailOccupationGroupValue(OccupationGroupSearchResult):
    

    _validation = {
        "code": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "code": {"key": "code", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "children": {"key": "children", "type": "[OccupationGroup]"},
        "parents": {"key": "parents", "type": "[OccupationGroup]"},
    }

    def __init__(
        self,
        *,
        code: int,
        name: str,
        match: Optional[bool] = None,
        children: Optional[List["_models.OccupationGroup"]] = None,
        parents: Optional[List["_models.OccupationGroup"]] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailOccupationGroupValue, self).__init__(
            match=match, code=code, name=name, children=children, parents=parents, **kwargs
        )


class JobDescriptionSearchDetailSearchExpression(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "[str]"},
    }

    def __init__(
        self, *, missing: Optional[List[str]] = None, value: Optional[List[str]] = None, **kwargs
    ):
        
        super(JobDescriptionSearchDetailSearchExpression, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class JobDescriptionSearchDetailSkills(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[JobDescriptionSearchDetailSkillsValueItem]"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        value: Optional[List["_models.JobDescriptionSearchDetailSkillsValueItem"]] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchDetailSkills, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class JobDescriptionSearchDetailSkillsValueItem(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, name: Optional[str] = None, match: Optional[bool] = None, **kwargs):
        
        super(JobDescriptionSearchDetailSkillsValueItem, self).__init__(**kwargs)
        self.name = name
        self.match = match


class JobDescriptionSearchEmbed(msrest.serialization.Model):
    

    _attribute_map = {
        "url": {"key": "url", "type": "str"},
    }

    def __init__(self, *, url: Optional[str] = None, **kwargs):
        
        super(JobDescriptionSearchEmbed, self).__init__(**kwargs)
        self.url = url


class JobDescriptionSearchParameters(msrest.serialization.Model):
    

    _validation = {
        "indices": {"required": True},
        "job_titles_weight": {"maximum": 1, "minimum": 0},
        "years_experience_weight": {"maximum": 1, "minimum": 0},
        "locations_weight": {"maximum": 1, "minimum": 0},
        "skills_weight": {"maximum": 1, "minimum": 0},
        "languages_weight": {"maximum": 1, "minimum": 0},
        "degree_types": {"unique": True},
        "education_weight": {"maximum": 1, "minimum": 0},
        "search_expression_weight": {"maximum": 1, "minimum": 0},
        "soc_codes_weight": {"maximum": 1, "minimum": 0},
        "management_level_weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "indices": {"key": "indices", "type": "[str]"},
        "resume": {"key": "resume", "type": "str"},
        "job_titles": {"key": "jobTitles", "type": "[str]"},
        "job_titles_required": {"key": "jobTitlesRequired", "type": "bool"},
        "job_titles_weight": {"key": "jobTitlesWeight", "type": "float"},
        "total_years_experience": {"key": "totalYearsExperience", "type": "float"},
        "years_experience_required": {"key": "yearsExperienceRequired", "type": "bool"},
        "years_experience_weight": {"key": "yearsExperienceWeight", "type": "float"},
        "locations": {"key": "locations", "type": "[ResumeSearchParametersLocation]"},
        "locations_weight": {"key": "locationsWeight", "type": "float"},
        "locations_required": {"key": "locationsRequired", "type": "bool"},
        "skills": {"key": "skills", "type": "[ResumeSearchParametersSkill]"},
        "skills_weight": {"key": "skillsWeight", "type": "float"},
        "languages": {"key": "languages", "type": "[ResumeSearchParametersSkill]"},
        "languages_weight": {"key": "languagesWeight", "type": "float"},
        "degrees": {"key": "degrees", "type": "[str]"},
        "degrees_required": {"key": "degreesRequired", "type": "bool"},
        "degree_types": {"key": "degreeTypes", "type": "[str]"},
        "degree_types_required": {"key": "degreeTypesRequired", "type": "bool"},
        "education_weight": {"key": "educationWeight", "type": "float"},
        "search_expression": {"key": "searchExpression", "type": "str"},
        "search_expression_required": {"key": "searchExpressionRequired", "type": "bool"},
        "search_expression_weight": {"key": "searchExpressionWeight", "type": "float"},
        "soc_codes": {"key": "socCodes", "type": "[int]"},
        "soc_codes_weight": {"key": "socCodesWeight", "type": "float"},
        "soc_codes_required": {"key": "socCodesRequired", "type": "bool"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "management_level_required": {"key": "managementLevelRequired", "type": "bool"},
        "management_level_weight": {"key": "managementLevelWeight", "type": "float"},
        "custom_data": {"key": "customData", "type": "[SearchParametersCustomData]"},
    }

    def __init__(
        self,
        *,
        indices: List[str],
        resume: Optional[str] = None,
        job_titles: Optional[List[str]] = None,
        job_titles_required: Optional[bool] = None,
        job_titles_weight: Optional[float] = None,
        total_years_experience: Optional[float] = None,
        years_experience_required: Optional[bool] = None,
        years_experience_weight: Optional[float] = None,
        locations: Optional[List["_models.ResumeSearchParametersLocation"]] = None,
        locations_weight: Optional[float] = None,
        locations_required: Optional[bool] = None,
        skills: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        skills_weight: Optional[float] = None,
        languages: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        languages_weight: Optional[float] = None,
        degrees: Optional[List[str]] = None,
        degrees_required: Optional[bool] = None,
        degree_types: Optional[List[Union[str, "_models.EducationLevel"]]] = None,
        degree_types_required: Optional[bool] = None,
        education_weight: Optional[float] = None,
        search_expression: Optional[str] = None,
        search_expression_required: Optional[bool] = None,
        search_expression_weight: Optional[float] = None,
        soc_codes: Optional[List[int]] = None,
        soc_codes_weight: Optional[float] = None,
        soc_codes_required: Optional[bool] = None,
        management_level: Optional[Union[str, "_models.ManagementLevel"]] = None,
        management_level_required: Optional[bool] = None,
        management_level_weight: Optional[float] = None,
        custom_data: Optional[List["_models.SearchParametersCustomData"]] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchParameters, self).__init__(**kwargs)
        self.indices = indices
        self.resume = resume
        self.job_titles = job_titles
        self.job_titles_required = job_titles_required
        self.job_titles_weight = job_titles_weight
        self.total_years_experience = total_years_experience
        self.years_experience_required = years_experience_required
        self.years_experience_weight = years_experience_weight
        self.locations = locations
        self.locations_weight = locations_weight
        self.locations_required = locations_required
        self.skills = skills
        self.skills_weight = skills_weight
        self.languages = languages
        self.languages_weight = languages_weight
        self.degrees = degrees
        self.degrees_required = degrees_required
        self.degree_types = degree_types
        self.degree_types_required = degree_types_required
        self.education_weight = education_weight
        self.search_expression = search_expression
        self.search_expression_required = search_expression_required
        self.search_expression_weight = search_expression_weight
        self.soc_codes = soc_codes
        self.soc_codes_weight = soc_codes_weight
        self.soc_codes_required = soc_codes_required
        self.management_level = management_level
        self.management_level_required = management_level_required
        self.management_level_weight = management_level_weight
        self.custom_data = custom_data


class JobDescriptionSearchResult(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "score": {"required": True},
        "pdf": {"required": True},
        "job_title": {"required": True},
        "management_level": {"required": True},
        "experience": {"required": True},
        "skills": {"required": True},
        "languages": {"required": True},
        "location": {"required": True},
        "education": {"required": True},
        "search_expression": {"required": True},
        "organization_name": {"required": True},
        "custom_data": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "score": {"key": "score", "type": "float"},
        "pdf": {"key": "pdf", "type": "str"},
        "job_title": {"key": "jobTitle", "type": "JobTitleSearchScoreComponent"},
        "management_level": {
            "key": "managementLevel",
            "type": "ManagementLevelSearchScoreComponent",
        },
        "experience": {"key": "experience", "type": "ExperienceSearchScoreComponent"},
        "skills": {"key": "skills", "type": "SkillsSearchScoreComponent"},
        "languages": {"key": "languages", "type": "LanguagesSearchScoreComponent"},
        "location": {"key": "location", "type": "LocationSearchScoreComponent"},
        "education": {"key": "education", "type": "EducationSearchScoreComponent"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "OccupationGroupSearchScoreComponent",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "SearchExpressionSearchScoreComponent",
        },
        "organization_name": {"key": "organizationName", "type": "str"},
        "custom_data": {
            "key": "customData",
            "type": "{ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties}",
        },
    }

    def __init__(
        self,
        *,
        identifier: str,
        score: float,
        pdf: str,
        job_title: "_models.JobTitleSearchScoreComponent",
        management_level: "_models.ManagementLevelSearchScoreComponent",
        experience: "_models.ExperienceSearchScoreComponent",
        skills: "_models.SkillsSearchScoreComponent",
        languages: "_models.LanguagesSearchScoreComponent",
        location: "_models.LocationSearchScoreComponent",
        education: "_models.EducationSearchScoreComponent",
        search_expression: "_models.SearchExpressionSearchScoreComponent",
        organization_name: str,
        custom_data: Dict[
            str,
            "_models.ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties",
        ],
        occupation_group: Optional["_models.OccupationGroupSearchScoreComponent"] = None,
        **kwargs,
    ):
        
        super(JobDescriptionSearchResult, self).__init__(**kwargs)
        self.identifier = identifier
        self.score = score
        self.pdf = pdf
        self.job_title = job_title
        self.management_level = management_level
        self.experience = experience
        self.skills = skills
        self.languages = languages
        self.location = location
        self.education = education
        self.occupation_group = occupation_group
        self.search_expression = search_expression
        self.organization_name = organization_name
        self.custom_data = custom_data


class JobTitleAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "JobTitleAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.JobTitleAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(JobTitleAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class JobTitleAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "classification": {
            "key": "classification",
            "type": "JobTitleAnnotationParsedClassification",
        },
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        management_level: Optional[str] = None,
        classification: Optional["_models.JobTitleAnnotationParsedClassification"] = None,
        **kwargs,
    ):
        
        super(JobTitleAnnotationParsed, self).__init__(**kwargs)
        self.name = name
        self.management_level = management_level
        self.classification = classification


class JobTitleAnnotationParsedClassification(msrest.serialization.Model):
    

    _validation = {
        "minor_group_code": {"maximum": 9999, "minimum": 1},
        "sub_major_group_code": {"maximum": 9999, "minimum": 1},
        "major_group_code": {"maximum": 9999, "minimum": 1},
    }

    _attribute_map = {
        "soc_code": {"key": "socCode", "type": "float"},
        "title": {"key": "title", "type": "str"},
        "minor_group": {"key": "minorGroup", "type": "str"},
        "sub_major_group": {"key": "subMajorGroup", "type": "str"},
        "major_group": {"key": "majorGroup", "type": "str"},
        "minor_group_code": {"key": "minorGroupCode", "type": "int"},
        "sub_major_group_code": {"key": "subMajorGroupCode", "type": "int"},
        "major_group_code": {"key": "majorGroupCode", "type": "int"},
    }

    def __init__(
        self,
        *,
        soc_code: Optional[float] = None,
        title: Optional[str] = None,
        minor_group: Optional[str] = None,
        sub_major_group: Optional[str] = None,
        major_group: Optional[str] = None,
        minor_group_code: Optional[int] = None,
        sub_major_group_code: Optional[int] = None,
        major_group_code: Optional[int] = None,
        **kwargs,
    ):
        
        super(JobTitleAnnotationParsedClassification, self).__init__(**kwargs)
        self.soc_code = soc_code
        self.title = title
        self.minor_group = minor_group
        self.sub_major_group = sub_major_group
        self.major_group = major_group
        self.minor_group_code = minor_group_code
        self.sub_major_group_code = sub_major_group_code
        self.major_group_code = major_group_code


class JobTitleParsed(msrest.serialization.Model):
    

    _validation = {
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "parsed": {"key": "parsed", "type": "JobTitleParsedParsed"},
    }

    def __init__(self, **kwargs):
        
        super(JobTitleParsed, self).__init__(**kwargs)
        self.parsed = None


class JobTitleAnnotationUpdate(AnnotationBase, JobTitleParsed):
    

    _validation = {
        "parsed": {"readonly": True},
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "parsed": {"key": "parsed", "type": "JobTitleParsedParsed"},
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        **kwargs,
    ):
        
        super(JobTitleAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = None
        self.additional_properties = additional_properties
        self.id = id
        self.rectangle = rectangle
        self.rectangles = None
        self.page_index = page_index
        self.raw = raw
        self.confidence = confidence
        self.classification_confidence = classification_confidence
        self.text_extraction_confidence = text_extraction_confidence
        self.is_verified = is_verified
        self.is_client_verified = is_client_verified
        self.is_auto_verified = is_auto_verified
        self.data_point = data_point
        self.content_type = content_type


class JobTitleParsedClassification(msrest.serialization.Model):
    

    _attribute_map = {
        "soc_code": {"key": "socCode", "type": "float"},
        "title": {"key": "title", "type": "str"},
        "minor_group": {"key": "minorGroup", "type": "str"},
        "sub_major_group": {"key": "subMajorGroup", "type": "str"},
        "major_group": {"key": "majorGroup", "type": "str"},
        "minor_group_code": {"key": "minorGroupCode", "type": "int"},
        "sub_major_group_code": {"key": "subMajorGroupCode", "type": "int"},
        "major_group_code": {"key": "majorGroupCode", "type": "int"},
    }

    def __init__(
        self,
        *,
        soc_code: Optional[float] = None,
        title: Optional[str] = None,
        minor_group: Optional[str] = None,
        sub_major_group: Optional[str] = None,
        major_group: Optional[str] = None,
        minor_group_code: Optional[int] = None,
        sub_major_group_code: Optional[int] = None,
        major_group_code: Optional[int] = None,
        **kwargs,
    ):
        
        super(JobTitleParsedClassification, self).__init__(**kwargs)
        self.soc_code = soc_code
        self.title = title
        self.minor_group = minor_group
        self.sub_major_group = sub_major_group
        self.major_group = major_group
        self.minor_group_code = minor_group_code
        self.sub_major_group_code = sub_major_group_code
        self.major_group_code = major_group_code


class JobTitleParsedParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "classification": {"key": "classification", "type": "JobTitleParsedClassification"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        management_level: Optional[str] = None,
        classification: Optional["_models.JobTitleParsedClassification"] = None,
        **kwargs,
    ):
        
        super(JobTitleParsedParsed, self).__init__(**kwargs)
        self.name = name
        self.management_level = management_level
        self.classification = classification


class JobTitleSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(JobTitleSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class LanguageAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        **kwargs,
    ):
        
        super(LanguageAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = None


class LanguageAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        **kwargs,
    ):
        
        super(LanguageAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = None


class LanguagesSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(LanguagesSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class LocationAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "Location"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.Location"] = None,
        **kwargs,
    ):
        
        super(LocationAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class LocationAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "LocationAnnotationUpdateParsed"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        **kwargs,
    ):
        
        super(LocationAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = None


class LocationAnnotationUpdateParsed(Location):
    

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, *, raw_input: str, **kwargs):
        
        super(LocationAnnotationUpdateParsed, self).__init__(raw_input=raw_input, **kwargs)


class LocationSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(LocationSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class ManagementLevelSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(ManagementLevelSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class Mapping(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True, "readonly": True},
        "data_source": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "data_source": {"key": "dataSource", "type": "str"},
        "score_cutoff": {"key": "scoreCutoff", "type": "float"},
        "order_by": {"key": "orderBy", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_source: str,
        organization: Optional[str] = None,
        score_cutoff: Optional[float] = None,
        order_by: Optional[str] = None,
        **kwargs,
    ):
        
        super(Mapping, self).__init__(**kwargs)
        self.identifier = None
        self.organization = organization
        self.data_source = data_source
        self.score_cutoff = score_cutoff
        self.order_by = order_by


class MappingCreate(msrest.serialization.Model):
    

    _validation = {
        "data_source": {"required": True},
    }

    _attribute_map = {
        "data_source": {"key": "dataSource", "type": "str"},
        "score_cutoff": {"key": "scoreCutoff", "type": "float"},
        "organization": {"key": "organization", "type": "str"},
        "order_by": {"key": "orderBy", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_source: str,
        score_cutoff: Optional[float] = None,
        organization: Optional[str] = None,
        order_by: Optional[str] = None,
        **kwargs,
    ):
        
        super(MappingCreate, self).__init__(**kwargs)
        self.data_source = data_source
        self.score_cutoff = score_cutoff
        self.organization = organization
        self.order_by = order_by


class MappingDataSource(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True, "readonly": True},
        "key_property": {"required": True},
        "display_property": {"required": True},
        "organization": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "key_property": {"key": "keyProperty", "type": "str"},
        "display_property": {"key": "displayProperty", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "schema": {"key": "schema", "type": "object"},
    }

    def __init__(
        self,
        *,
        key_property: str,
        display_property: str,
        organization: str,
        workspace: str,
        name: Optional[str] = None,
        schema: Optional[Any] = None,
        **kwargs,
    ):
        
        super(MappingDataSource, self).__init__(**kwargs)
        self.identifier = None
        self.name = name
        self.key_property = key_property
        self.display_property = display_property
        self.organization = organization
        self.workspace = workspace
        self.schema = schema


class MappingDataSourceCreate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "key_property": {"key": "keyProperty", "type": "str"},
        "display_property": {"key": "displayProperty", "type": "str"},
        "values": {"key": "values", "type": "[object]"},
        "schema": {"key": "schema", "type": "object"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        organization: Optional[str] = None,
        workspace: Optional[str] = None,
        key_property: Optional[str] = None,
        display_property: Optional[str] = None,
        values: Optional[List[Any]] = None,
        schema: Optional[Any] = None,
        **kwargs,
    ):
        
        super(MappingDataSourceCreate, self).__init__(**kwargs)
        self.name = name
        self.organization = organization
        self.workspace = workspace
        self.key_property = key_property
        self.display_property = display_property
        self.values = values
        self.schema = schema


class MappingUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "score_cutoff": {"key": "scoreCutoff", "type": "float"},
        "order_by": {"key": "orderBy", "type": "str"},
    }

    def __init__(
        self, *, score_cutoff: Optional[float] = None, order_by: Optional[str] = None, **kwargs
    ):
        
        super(MappingUpdate, self).__init__(**kwargs)
        self.score_cutoff = score_cutoff
        self.order_by = order_by


class Meta(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "ready": {"key": "ready", "type": "bool"},
        "ready_dt": {"key": "readyDt", "type": "iso-8601"},
        "failed": {"key": "failed", "type": "bool"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "language": {"key": "language", "type": "str"},
        "pdf": {"key": "pdf", "type": "str"},
        "parent_document": {"key": "parentDocument", "type": "MetaParentDocument"},
        "child_documents": {"key": "childDocuments", "type": "[MetaChildDocumentsItem]"},
        "pages": {"key": "pages", "type": "[PageMeta]"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "review_url": {"key": "reviewUrl", "type": "str"},
        "ocr_confidence": {"key": "ocrConfidence", "type": "float"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
        "document_type": {"key": "documentType", "type": "str"},
        "region_bias": {"key": "regionBias", "type": "RegionBias"},
        "is_ocrd": {"key": "isOcrd", "type": "bool"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        custom_identifier: Optional[str] = None,
        file_name: Optional[str] = None,
        ready: Optional[bool] = None,
        ready_dt: Optional[datetime.datetime] = None,
        failed: Optional[bool] = None,
        expiry_time: Optional[datetime.datetime] = None,
        language: Optional[str] = None,
        pdf: Optional[str] = None,
        parent_document: Optional["_models.MetaParentDocument"] = None,
        child_documents: Optional[List["_models.MetaChildDocumentsItem"]] = None,
        pages: Optional[List["_models.PageMeta"]] = None,
        is_verified: Optional[bool] = None,
        review_url: Optional[str] = None,
        ocr_confidence: Optional[float] = None,
        created_dt: Optional[datetime.datetime] = None,
        document_type: Optional[str] = None,
        region_bias: Optional["_models.RegionBias"] = None,
        is_ocrd: Optional[bool] = None,
        **kwargs,
    ):
        
        super(Meta, self).__init__(**kwargs)
        self.identifier = identifier
        self.custom_identifier = custom_identifier
        self.file_name = file_name
        self.ready = ready
        self.ready_dt = ready_dt
        self.failed = failed
        self.expiry_time = expiry_time
        self.language = language
        self.pdf = pdf
        self.parent_document = parent_document
        self.child_documents = child_documents
        self.pages = pages
        self.is_verified = is_verified
        self.review_url = review_url
        self.ocr_confidence = ocr_confidence
        self.created_dt = created_dt
        self.document_type = document_type
        self.region_bias = region_bias
        self.is_ocrd = is_ocrd


class MetaChildDocumentsItem(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
    }

    def __init__(self, *, identifier: Optional[str] = None, **kwargs):
        
        super(MetaChildDocumentsItem, self).__init__(**kwargs)
        self.identifier = identifier


class MetaParentDocument(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
    }

    def __init__(self, *, identifier: Optional[str] = None, **kwargs):
        
        super(MetaParentDocument, self).__init__(**kwargs)
        self.identifier = identifier


class OccupationGroup(msrest.serialization.Model):
    

    _validation = {
        "code": {"required": True},
        "name": {"required": True},
        "children": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "children": {"key": "children", "type": "[OccupationGroup]"},
    }

    def __init__(
        self, *, code: int, name: str, children: List["_models.OccupationGroup"], **kwargs
    ):
        
        super(OccupationGroup, self).__init__(**kwargs)
        self.code = code
        self.name = name
        self.children = children


class OccupationGroupSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(OccupationGroupSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class Organization(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "user_role": {"key": "userRole", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "resthook_signature_key": {"key": "resthookSignatureKey", "type": "str"},
        "is_trial": {"key": "isTrial", "type": "bool"},
        "validation_tool_config": {
            "key": "validationToolConfig",
            "type": "OrganizationValidationToolConfig",
        },
        "show_custom_field_creation": {"key": "showCustomFieldCreation", "type": "bool"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        name: Optional[str] = None,
        user_role: Optional[Union[str, "_models.OrganizationUserRole"]] = None,
        avatar: Optional[str] = None,
        resthook_signature_key: Optional[str] = None,
        is_trial: Optional[bool] = None,
        validation_tool_config: Optional["_models.OrganizationValidationToolConfig"] = None,
        show_custom_field_creation: Optional[bool] = None,
        **kwargs,
    ):
        
        super(Organization, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.user_role = user_role
        self.avatar = avatar
        self.resthook_signature_key = resthook_signature_key
        self.is_trial = is_trial
        self.validation_tool_config = validation_tool_config
        self.show_custom_field_creation = show_custom_field_creation


class OrganizationCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "avatar": {"key": "avatar", "type": "IO"},
        "resthook_signature_key": {"key": "resthookSignatureKey", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        avatar: Optional[IO] = None,
        resthook_signature_key: Optional[str] = None,
        **kwargs,
    ):
        
        super(OrganizationCreate, self).__init__(**kwargs)
        self.name = name
        self.avatar = avatar
        self.resthook_signature_key = resthook_signature_key


class OrganizationMembership(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "organization": {"required": True},
        "user": {"required": True},
        "role": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "user": {"key": "user", "type": "User"},
        "role": {"key": "role", "type": "str"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        organization: str,
        user: "_models.User",
        role: Union[str, "_models.OrganizationRole"],
        **kwargs,
    ):
        
        super(OrganizationMembership, self).__init__(**kwargs)
        self.identifier = identifier
        self.organization = organization
        self.user = user
        self.role = role


class OrganizationMembershipUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "role": {"key": "role", "type": "str"},
    }

    def __init__(self, *, role: Optional[Union[str, "_models.OrganizationRole"]] = None, **kwargs):
        
        super(OrganizationMembershipUpdate, self).__init__(**kwargs)
        self.role = role


class OrganizationUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "avatar": {"key": "avatar", "type": "IO"},
        "resthook_signature_key": {"key": "resthookSignatureKey", "type": "str"},
        "validation_tool_config": {"key": "validationToolConfig", "type": "ValidationToolConfig"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        avatar: Optional[IO] = None,
        resthook_signature_key: Optional[str] = None,
        validation_tool_config: Optional["_models.ValidationToolConfig"] = None,
        **kwargs,
    ):
        
        super(OrganizationUpdate, self).__init__(**kwargs)
        self.name = name
        self.avatar = avatar
        self.resthook_signature_key = resthook_signature_key
        self.validation_tool_config = validation_tool_config


class OrganizationValidationToolConfig(msrest.serialization.Model):
    

    _attribute_map = {
        "theme": {"key": "theme", "type": "ThemeConfig"},
        "hide_actions": {"key": "hideActions", "type": "bool"},
        "hide_collection": {"key": "hideCollection", "type": "bool"},
        "hide_edit_pages": {"key": "hideEditPages", "type": "bool"},
        "hide_export": {"key": "hideExport", "type": "bool"},
        "hide_filename": {"key": "hideFilename", "type": "bool"},
        "hide_reject": {"key": "hideReject", "type": "bool"},
        "hide_reparse": {"key": "hideReparse", "type": "bool"},
        "hide_run_ocr": {"key": "hideRunOcr", "type": "bool"},
        "hide_tags": {"key": "hideTags", "type": "bool"},
        "hide_warnings": {"key": "hideWarnings", "type": "bool"},
        "restrict_document_splitting": {"key": "restrictDocumentSplitting", "type": "bool"},
        "disable_currency_formatting": {"key": "disableCurrencyFormatting", "type": "bool"},
        "disable_edit_document_metadata": {"key": "disableEditDocumentMetadata", "type": "bool"},
    }

    def __init__(
        self,
        *,
        theme: Optional["_models.ThemeConfig"] = None,
        hide_actions: Optional[bool] = None,
        hide_collection: Optional[bool] = None,
        hide_edit_pages: Optional[bool] = None,
        hide_export: Optional[bool] = None,
        hide_filename: Optional[bool] = None,
        hide_reject: Optional[bool] = None,
        hide_reparse: Optional[bool] = None,
        hide_run_ocr: Optional[bool] = None,
        hide_tags: Optional[bool] = None,
        hide_warnings: Optional[bool] = None,
        restrict_document_splitting: Optional[bool] = None,
        disable_currency_formatting: Optional[bool] = None,
        disable_edit_document_metadata: Optional[bool] = None,
        **kwargs,
    ):
        
        super(OrganizationValidationToolConfig, self).__init__(**kwargs)
        self.theme = theme
        self.hide_actions = hide_actions
        self.hide_collection = hide_collection
        self.hide_edit_pages = hide_edit_pages
        self.hide_export = hide_export
        self.hide_filename = hide_filename
        self.hide_reject = hide_reject
        self.hide_reparse = hide_reparse
        self.hide_run_ocr = hide_run_ocr
        self.hide_tags = hide_tags
        self.hide_warnings = hide_warnings
        self.restrict_document_splitting = restrict_document_splitting
        self.disable_currency_formatting = disable_currency_formatting
        self.disable_edit_document_metadata = disable_edit_document_metadata


class PageMeta(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "page_index": {"required": True, "minimum": 0},
        "image": {"required": True},
        "height": {"required": True},
        "width": {"required": True},
        "rotation": {"required": True, "maximum": 360, "minimum": -360},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "image": {"key": "image", "type": "str"},
        "image_translated": {"key": "imageTranslated", "type": "str"},
        "height": {"key": "height", "type": "float"},
        "width": {"key": "width", "type": "float"},
        "rotation": {"key": "rotation", "type": "int"},
    }

    def __init__(
        self,
        *,
        id: int,
        page_index: int,
        image: str,
        height: float,
        width: float,
        rotation: int,
        image_translated: Optional[str] = None,
        **kwargs,
    ):
        
        super(PageMeta, self).__init__(**kwargs)
        self.id = id
        self.page_index = page_index
        self.image = image
        self.image_translated = image_translated
        self.height = height
        self.width = width
        self.rotation = rotation


class PaginatedResponse(msrest.serialization.Model):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self, *, count: int, next: Optional[str] = None, previous: Optional[str] = None, **kwargs
    ):
        
        super(PaginatedResponse, self).__init__(**kwargs)
        self.count = count
        self.next = next
        self.previous = previous


class PaletteColorOptions(msrest.serialization.Model):
    

    _validation = {
        "main": {"required": True},
    }

    _attribute_map = {
        "main": {"key": "main", "type": "str"},
        "light": {"key": "light", "type": "str"},
        "dark": {"key": "dark", "type": "str"},
        "contrast_text": {"key": "contrastText", "type": "str"},
    }

    def __init__(
        self,
        *,
        main: str,
        light: Optional[str] = None,
        dark: Optional[str] = None,
        contrast_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(PaletteColorOptions, self).__init__(**kwargs)
        self.main = main
        self.light = light
        self.dark = dark
        self.contrast_text = contrast_text


class Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[ApiUserWithoutKey]"},
    }

    def __init__(self, *, results: Optional[List["_models.ApiUserWithoutKey"]] = None, **kwargs):
        
        super(
            Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[MappingDataSource]"},
    }

    def __init__(self, *, results: Optional[List["_models.MappingDataSource"]] = None, **kwargs):
        
        super(
            Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1,
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[MappingDataSource]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.MappingDataSource"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(
            Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema, self
        ).__init__(count=count, next=next, previous=previous, results=results, **kwargs)
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[Invitation]"},
    }

    def __init__(self, *, results: Optional[List["_models.Invitation"]] = None, **kwargs):
        
        super(
            PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Invitation]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.Invitation"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema, self).__init__(
            count=count, next=next, previous=previous, results=results, **kwargs
        )
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "config_override": {"key": "configOverride", "type": "ResumeSearchConfig"},
    }

    def __init__(
        self, *, config_override: Optional["_models.ResumeSearchConfig"] = None, **kwargs
    ):
        
        super(
            Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.config_override = config_override


class Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[Annotation]"},
    }

    def __init__(self, *, results: Optional[List["_models.Annotation"]] = None, **kwargs):
        
        super(
            Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Annotation]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.Annotation"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema, self).__init__(
            count=count, next=next, previous=previous, results=results, **kwargs
        )
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[Mapping]"},
    }

    def __init__(self, *, results: Optional[List["_models.Mapping"]] = None, **kwargs):
        
        super(
            PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Mapping]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.Mapping"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema, self).__init__(
            count=count, next=next, previous=previous, results=results, **kwargs
        )
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[object]"},
    }

    def __init__(self, *, results: Optional[List[Any]] = None, **kwargs):
        
        super(
            Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = results


class Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[ResthookSubscription]"},
    }

    def __init__(
        self, *, results: Optional[List["_models.ResthookSubscription"]] = None, **kwargs
    ):
        
        super(
            Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = results


class Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1,
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[object]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List[Any]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(
            Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema,
            self,
        ).__init__(count=count, next=next, previous=previous, results=results, **kwargs)
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[ApiUserWithoutKey]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.ApiUserWithoutKey"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema, self).__init__(
            count=count, next=next, previous=previous, results=results, **kwargs
        )
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _validation = {
        "results": {"required": True},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[WorkspaceMembership]"},
    }

    def __init__(self, *, results: List["_models.WorkspaceMembership"], **kwargs):
        
        super(
            Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = results


class Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[DataPointChoice]"},
    }

    def __init__(self, *, results: Optional[List["_models.DataPointChoice"]] = None, **kwargs):
        
        super(
            Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[Index]"},
    }

    def __init__(self, *, results: Optional[List["_models.Index"]] = None, **kwargs):
        
        super(Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1, self).__init__(
            **kwargs
        )
        self.results = results


class Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[OrganizationMembership]"},
    }

    def __init__(
        self, *, results: Optional[List["_models.OrganizationMembership"]] = None, **kwargs
    ):
        
        super(
            Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = results


class PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, *, document: Optional[str] = None, **kwargs):
        
        super(
            PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.document = document


class PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Index]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.Index"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema, self).__init__(
            count=count, next=next, previous=previous, results=results, **kwargs
        )
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, *, document: Optional[str] = None, **kwargs):
        
        super(
            PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.document = document


class PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "results": {"key": "results", "type": "[Document]"},
    }

    def __init__(self, *, results: Optional[List["_models.Document"]] = None, **kwargs):
        
        super(
            PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = results


class PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema(
    msrest.serialization.Model
):
    

    _attribute_map = {
        "config_override": {"key": "configOverride", "type": "JobDescriptionSearchConfig"},
    }

    def __init__(
        self, *, config_override: Optional["_models.JobDescriptionSearchConfig"] = None, **kwargs
    ):
        
        super(
            PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.config_override = config_override


class PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1,
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[DataPointChoice]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.DataPointChoice"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(
            PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema, self
        ).__init__(count=count, next=next, previous=previous, results=results, **kwargs)
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema(
    msrest.serialization.Model
):
    

    _validation = {
        "count": {"minimum": 1},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
        "results": {"key": "results", "type": "[Get200ApplicationJsonPropertiesItemsItem]"},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        results: Optional[List["_models.Get200ApplicationJsonPropertiesItemsItem"]] = None,
        **kwargs,
    ):
        
        super(
            PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.count = count
        self.next = next
        self.previous = previous
        self.results = results


class PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Document]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.Document"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema, self).__init__(
            count=count, next=next, previous=previous, results=results, **kwargs
        )
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[OrganizationMembership]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.OrganizationMembership"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(
            PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(count=count, next=next, previous=previous, results=results, **kwargs)
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1,
):
    

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[ResthookSubscription]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: int,
        results: Optional[List["_models.ResthookSubscription"]] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(
            PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(count=count, next=next, previous=previous, results=results, **kwargs)
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
):
    

    _validation = {
        "results": {"required": True},
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[WorkspaceMembership]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(
        self,
        *,
        results: List["_models.WorkspaceMembership"],
        count: int,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        **kwargs,
    ):
        
        super(
            PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(count=count, next=next, previous=previous, results=results, **kwargs)
        self.results = results
        self.count = count
        self.next = next
        self.previous = previous


class PhoneNumberAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "PhoneNumberAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.PhoneNumberAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(PhoneNumberAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class PhoneNumberAnnotationParsed(msrest.serialization.Model):
    

    _validation = {
        "international_country_code": {"minimum": 1},
    }

    _attribute_map = {
        "raw_text": {"key": "rawText", "type": "str"},
        "formatted_number": {"key": "formattedNumber", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "international_country_code": {"key": "internationalCountryCode", "type": "int"},
        "national_number": {"key": "nationalNumber", "type": "str"},
    }

    def __init__(
        self,
        *,
        raw_text: Optional[str] = None,
        formatted_number: Optional[str] = None,
        country_code: Optional[str] = None,
        international_country_code: Optional[int] = None,
        national_number: Optional[str] = None,
        **kwargs,
    ):
        
        super(PhoneNumberAnnotationParsed, self).__init__(**kwargs)
        self.raw_text = raw_text
        self.formatted_number = formatted_number
        self.country_code = country_code
        self.international_country_code = international_country_code
        self.national_number = national_number


class Rectangle(msrest.serialization.Model):
    

    _validation = {
        "page_index": {"minimum": 0},
        "x0": {"required": True},
        "y0": {"required": True},
        "x1": {"required": True},
        "y1": {"required": True},
    }

    _attribute_map = {
        "page_index": {"key": "pageIndex", "type": "int"},
        "x0": {"key": "x0", "type": "float"},
        "y0": {"key": "y0", "type": "float"},
        "x1": {"key": "x1", "type": "float"},
        "y1": {"key": "y1", "type": "float"},
    }

    def __init__(
        self,
        *,
        x0: float,
        y0: float,
        x1: float,
        y1: float,
        page_index: Optional[int] = None,
        **kwargs,
    ):
        
        super(Rectangle, self).__init__(**kwargs)
        self.page_index = page_index
        self.x0 = x0
        self.y0 = y0
        self.x1 = x1
        self.y1 = y1


class RedactConfig(msrest.serialization.Model):
    

    _attribute_map = {
        "redact_headshot": {"key": "redactHeadshot", "type": "bool"},
        "redact_personal_details": {"key": "redactPersonalDetails", "type": "bool"},
        "redact_work_details": {"key": "redactWorkDetails", "type": "bool"},
        "redact_referees": {"key": "redactReferees", "type": "bool"},
        "redact_education_details": {"key": "redactEducationDetails", "type": "bool"},
        "redact_locations": {"key": "redactLocations", "type": "bool"},
        "redact_dates": {"key": "redactDates", "type": "bool"},
        "redact_gender": {"key": "redactGender", "type": "bool"},
    }

    def __init__(
        self,
        *,
        redact_headshot: Optional[bool] = None,
        redact_personal_details: Optional[bool] = None,
        redact_work_details: Optional[bool] = None,
        redact_referees: Optional[bool] = None,
        redact_education_details: Optional[bool] = None,
        redact_locations: Optional[bool] = None,
        redact_dates: Optional[bool] = None,
        redact_gender: Optional[bool] = None,
        **kwargs,
    ):
        
        super(RedactConfig, self).__init__(**kwargs)
        self.redact_headshot = redact_headshot
        self.redact_personal_details = redact_personal_details
        self.redact_work_details = redact_work_details
        self.redact_referees = redact_referees
        self.redact_education_details = redact_education_details
        self.redact_locations = redact_locations
        self.redact_dates = redact_dates
        self.redact_gender = redact_gender


class RegionBias(msrest.serialization.Model):
    

    _attribute_map = {
        "country": {"key": "country", "type": "str"},
        "countries": {"key": "countries", "type": "[str]"},
        "square_coordinates": {"key": "squareCoordinates", "type": "[float]"},
        "strict": {"key": "strict", "type": "bool"},
    }

    def __init__(
        self,
        *,
        country: Optional[str] = None,
        countries: Optional[List[str]] = None,
        square_coordinates: Optional[List[float]] = None,
        strict: Optional[bool] = None,
        **kwargs,
    ):
        
        super(RegionBias, self).__init__(**kwargs)
        self.country = country
        self.countries = countries
        self.square_coordinates = square_coordinates
        self.strict = strict


class RequestError(msrest.serialization.Model):
    

    _validation = {
        "type": {"required": True},
        "errors": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "errors": {"key": "errors", "type": "[RequestErrorErrorsItem]"},
    }

    def __init__(self, *, type: str, errors: List["_models.RequestErrorErrorsItem"], **kwargs):
        
        super(RequestError, self).__init__(**kwargs)
        self.type = type
        self.errors = errors


class RequestErrorErrorsItem(msrest.serialization.Model):
    

    _validation = {
        "attr": {"required": True},
        "code": {"required": True},
        "detail": {"required": True},
    }

    _attribute_map = {
        "attr": {"key": "attr", "type": "str"},
        "code": {"key": "code", "type": "str"},
        "detail": {"key": "detail", "type": "str"},
    }

    def __init__(self, *, attr: str, code: str, detail: str, **kwargs):
        
        super(RequestErrorErrorsItem, self).__init__(**kwargs)
        self.attr = attr
        self.code = code
        self.detail = detail


class ResthookSubscription(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True},
        "event": {"required": True},
        "organization": {"required": True},
        "workspace": {"required": True},
        "target_url": {"required": True},
        "active": {"required": True},
        "auto_deactivated": {"required": True},
        "auto_deactivate_reason": {"required": True},
        "version": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "event": {"key": "event", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "workspace": {"key": "workspace", "type": "ResthookSubscriptionWorkspace"},
        "target_url": {"key": "targetUrl", "type": "str"},
        "active": {"key": "active", "type": "bool"},
        "auto_deactivated": {"key": "autoDeactivated", "type": "bool"},
        "auto_deactivate_reason": {"key": "autoDeactivateReason", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        event: Union[str, "_models.ResthookEvent"],
        organization: "_models.Organization",
        workspace: "_models.ResthookSubscriptionWorkspace",
        target_url: str,
        active: bool,
        auto_deactivated: bool,
        auto_deactivate_reason: str,
        version: Union[str, "_models.ResthookSubscriptionVersion"],
        **kwargs,
    ):
        
        super(ResthookSubscription, self).__init__(**kwargs)
        self.id = id
        self.event = event
        self.organization = organization
        self.workspace = workspace
        self.target_url = target_url
        self.active = active
        self.auto_deactivated = auto_deactivated
        self.auto_deactivate_reason = auto_deactivate_reason
        self.version = version


class ResthookSubscriptionCreate(msrest.serialization.Model):
    

    _validation = {
        "target_url": {"required": True},
        "event": {"required": True},
    }

    _attribute_map = {
        "target_url": {"key": "targetUrl", "type": "str"},
        "event": {"key": "event", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(
        self,
        *,
        target_url: str,
        event: Union[str, "_models.ResthookEvent"],
        organization: Optional[str] = None,
        workspace: Optional[str] = None,
        version: Optional[Union[str, "_models.Version"]] = None,
        **kwargs,
    ):
        
        super(ResthookSubscriptionCreate, self).__init__(**kwargs)
        self.target_url = target_url
        self.event = event
        self.organization = organization
        self.workspace = workspace
        self.version = version


class ResthookSubscriptionUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "event": {"key": "event", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(
        self,
        *,
        event: Optional[Union[str, "_models.ResthookEvent"]] = None,
        organization: Optional[str] = None,
        workspace: Optional[str] = None,
        version: Optional[Union[str, "_models.Version"]] = None,
        **kwargs,
    ):
        
        super(ResthookSubscriptionUpdate, self).__init__(**kwargs)
        self.event = event
        self.organization = organization
        self.workspace = workspace
        self.version = version


class ResthookSubscriptionWorkspace(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "organization": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
    }

    def __init__(
        self, *, identifier: str, name: str, organization: "_models.Organization", **kwargs
    ):
        
        super(ResthookSubscriptionWorkspace, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.organization = organization


class Resume(Document):
    

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "ResumeData"},
    }

    def __init__(
        self,
        *,
        meta: "_models.DocumentMeta",
        error: Optional["_models.DocumentError"] = None,
        warnings: Optional[List["_models.DocumentWarning"]] = None,
        data: Optional["_models.ResumeData"] = None,
        **kwargs,
    ):
        
        super(Resume, self).__init__(meta=meta, error=error, warnings=warnings, **kwargs)
        self.extractor = "resume"          self.data = data


class ResumeData(msrest.serialization.Model):
    

    _validation = {
        "language_codes": {"readonly": True},
        "total_years_experience": {"minimum": 0},
        "head_shot": {"readonly": True},
        "profession": {"readonly": True},
        "linkedin": {"readonly": True},
        "sections": {"readonly": True},
        "is_resume_probability": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "name": {"key": "name", "type": "ResumeDataName"},
        "phone_numbers": {"key": "phoneNumbers", "type": "[str]"},
        "phone_number_details": {
            "key": "phoneNumberDetails",
            "type": "[ResumeDataPhoneNumberDetailsItem]",
        },
        "websites": {"key": "websites", "type": "[str]"},
        "emails": {"key": "emails", "type": "[str]"},
        "date_of_birth": {"key": "dateOfBirth", "type": "str"},
        "location": {"key": "location", "type": "Location"},
        "objective": {"key": "objective", "type": "str"},
        "languages": {"key": "languages", "type": "[str]"},
        "language_codes": {"key": "languageCodes", "type": "[str]"},
        "summary": {"key": "summary", "type": "str"},
        "total_years_experience": {"key": "totalYearsExperience", "type": "int"},
        "head_shot": {"key": "headShot", "type": "bytearray"},
        "education": {"key": "education", "type": "[Education]"},
        "profession": {"key": "profession", "type": "str"},
        "linkedin": {"key": "linkedin", "type": "str"},
        "work_experience": {"key": "workExperience", "type": "[ResumeDataWorkExperienceItem]"},
        "skills": {"key": "skills", "type": "[ResumeDataSkillsItem]"},
        "certifications": {"key": "certifications", "type": "[str]"},
        "publications": {"key": "publications", "type": "[str]"},
        "referees": {"key": "referees", "type": "[ResumeDataRefereesItem]"},
        "sections": {"key": "sections", "type": "[ResumeDataSectionsItem]"},
        "is_resume_probability": {"key": "isResumeProbability", "type": "int"},
        "raw_text": {"key": "rawText", "type": "str"},
        "redacted_text": {"key": "redactedText", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        name: Optional["_models.ResumeDataName"] = None,
        phone_numbers: Optional[List[str]] = None,
        phone_number_details: Optional[List["_models.ResumeDataPhoneNumberDetailsItem"]] = None,
        websites: Optional[List[str]] = None,
        emails: Optional[List[str]] = None,
        date_of_birth: Optional[str] = None,
        location: Optional["_models.Location"] = None,
        objective: Optional[str] = "",
        languages: Optional[List[Union[str, "_models.ResumeDataLanguagesItem"]]] = None,
        summary: Optional[str] = "",
        total_years_experience: Optional[int] = None,
        education: Optional[List["_models.Education"]] = None,
        work_experience: Optional[List["_models.ResumeDataWorkExperienceItem"]] = None,
        skills: Optional[List["_models.ResumeDataSkillsItem"]] = None,
        certifications: Optional[List[str]] = None,
        publications: Optional[List[str]] = None,
        referees: Optional[List["_models.ResumeDataRefereesItem"]] = None,
        raw_text: Optional[str] = None,
        redacted_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeData, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.name = name
        self.phone_numbers = phone_numbers
        self.phone_number_details = phone_number_details
        self.websites = websites
        self.emails = emails
        self.date_of_birth = date_of_birth
        self.location = location
        self.objective = objective
        self.languages = languages
        self.language_codes = None
        self.summary = summary
        self.total_years_experience = total_years_experience
        self.head_shot = None
        self.education = education
        self.profession = None
        self.linkedin = None
        self.work_experience = work_experience
        self.skills = skills
        self.certifications = certifications
        self.publications = publications
        self.referees = referees
        self.sections = None
        self.is_resume_probability = None
        self.raw_text = raw_text
        self.redacted_text = redacted_text


class ResumeDataName(msrest.serialization.Model):
    

    _attribute_map = {
        "raw": {"key": "raw", "type": "str"},
        "first": {"key": "first", "type": "str"},
        "last": {"key": "last", "type": "str"},
        "middle": {"key": "middle", "type": "str"},
        "title": {"key": "title", "type": "str"},
    }

    def __init__(
        self,
        *,
        raw: Optional[str] = None,
        first: Optional[str] = None,
        last: Optional[str] = None,
        middle: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeDataName, self).__init__(**kwargs)
        self.raw = raw
        self.first = first
        self.last = last
        self.middle = middle
        self.title = title


class ResumeDataPhoneNumberDetailsItem(msrest.serialization.Model):
    

    _validation = {
        "international_country_code": {"minimum": 1},
    }

    _attribute_map = {
        "raw_text": {"key": "rawText", "type": "str"},
        "formatted_number": {"key": "formattedNumber", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "international_country_code": {"key": "internationalCountryCode", "type": "int"},
        "national_number": {"key": "nationalNumber", "type": "str"},
    }

    def __init__(
        self,
        *,
        raw_text: Optional[str] = None,
        formatted_number: Optional[str] = None,
        country_code: Optional[str] = None,
        international_country_code: Optional[int] = None,
        national_number: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeDataPhoneNumberDetailsItem, self).__init__(**kwargs)
        self.raw_text = raw_text
        self.formatted_number = formatted_number
        self.country_code = country_code
        self.international_country_code = international_country_code
        self.national_number = national_number


class ResumeDataRefereesItem(msrest.serialization.Model):
    

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "name": {"key": "name", "type": "str"},
        "text": {"key": "text", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "number": {"key": "number", "type": "str"},
        "position": {"key": "position", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        name: Optional[str] = None,
        text: Optional[str] = None,
        email: Optional[str] = None,
        number: Optional[str] = None,
        position: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeDataRefereesItem, self).__init__(**kwargs)
        self.additional_properties = additional_properties
        self.name = name
        self.text = text
        self.email = email
        self.number = number
        self.position = position


class ResumeDataSectionsItem(msrest.serialization.Model):
    

    _validation = {
        "bbox": {"max_items": 4, "min_items": 4},
    }

    _attribute_map = {
        "section_type": {"key": "sectionType", "type": "str"},
        "bbox": {"key": "bbox", "type": "[float]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "text": {"key": "text", "type": "str"},
    }

    def __init__(
        self,
        *,
        section_type: Optional[str] = None,
        bbox: Optional[List[float]] = None,
        page_index: Optional[int] = None,
        text: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeDataSectionsItem, self).__init__(**kwargs)
        self.section_type = section_type
        self.bbox = bbox
        self.page_index = page_index
        self.text = text


class ResumeDataSkillsItem(msrest.serialization.Model):
    

    _validation = {
        "id": {"minimum": 1},
        "emsi_id": {"readonly": True},
        "number_of_months": {"minimum": 0},
        "type": {"readonly": True},
        "count": {"readonly": True, "minimum": 0},
        "weighting": {"readonly": True},
        "sources": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "emsi_id": {"key": "emsiId", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "count": {"key": "count", "type": "int"},
        "weighting": {"key": "weighting", "type": "float"},
        "sources": {"key": "sources", "type": "[ResumeDataSkillsPropertiesItemsItem]"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        last_used: Optional[str] = None,
        number_of_months: Optional[int] = None,
        **kwargs,
    ):
        
        super(ResumeDataSkillsItem, self).__init__(**kwargs)
        self.id = id
        self.emsi_id = None
        self.name = name
        self.last_used = last_used
        self.number_of_months = number_of_months
        self.type = None
        self.count = None
        self.weighting = None
        self.sources = None


class ResumeDataSkillsPropertiesItemsItem(msrest.serialization.Model):
    

    _attribute_map = {
        "section": {"key": "section", "type": "str"},
        "position": {"key": "position", "type": "int"},
        "work_experience_id": {"key": "workExperienceId", "type": "int"},
    }

    def __init__(
        self,
        *,
        section: Optional[str] = None,
        position: Optional[int] = None,
        work_experience_id: Optional[int] = None,
        **kwargs,
    ):
        
        super(ResumeDataSkillsPropertiesItemsItem, self).__init__(**kwargs)
        self.section = section
        self.position = position
        self.work_experience_id = work_experience_id


class ResumeDataWorkExperienceItem(msrest.serialization.Model):
    

    _validation = {
        "id": {"minimum": 1},
        "soc_code": {"readonly": True},
        "soc_name": {"readonly": True},
        "industry": {"readonly": True},
        "occupation": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "job_title": {"key": "jobTitle", "type": "str"},
        "soc_code": {"key": "socCode", "type": "str"},
        "soc_name": {"key": "socName", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "industry": {"key": "industry", "type": "str"},
        "location": {"key": "location", "type": "Location"},
        "job_description": {"key": "jobDescription", "type": "str"},
        "dates": {"key": "dates", "type": "ResumeDataWorkExperienceItemDates"},
        "occupation": {"key": "occupation", "type": "ResumeDataWorkExperienceItemOccupation"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        job_title: Optional[str] = None,
        organization: Optional[str] = None,
        location: Optional["_models.Location"] = None,
        job_description: Optional[str] = None,
        dates: Optional["_models.ResumeDataWorkExperienceItemDates"] = None,
        **kwargs,
    ):
        
        super(ResumeDataWorkExperienceItem, self).__init__(**kwargs)
        self.id = id
        self.job_title = job_title
        self.soc_code = None
        self.soc_name = None
        self.organization = organization
        self.industry = None
        self.location = location
        self.job_description = job_description
        self.dates = dates
        self.occupation = None


class ResumeDataWorkExperienceItemDates(msrest.serialization.Model):
    

    _validation = {
        "months_in_position": {"minimum": 0},
    }

    _attribute_map = {
        "start_date": {"key": "startDate", "type": "date"},
        "end_date": {"key": "endDate", "type": "date"},
        "months_in_position": {"key": "monthsInPosition", "type": "int"},
        "is_current": {"key": "isCurrent", "type": "bool"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(
        self,
        *,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        months_in_position: Optional[int] = None,
        is_current: Optional[bool] = None,
        raw_text: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeDataWorkExperienceItemDates, self).__init__(**kwargs)
        self.start_date = start_date
        self.end_date = end_date
        self.months_in_position = months_in_position
        self.is_current = is_current
        self.raw_text = raw_text


class ResumeDataWorkExperienceItemOccupation(msrest.serialization.Model):
    

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "str"},
        "job_title_normalized": {"key": "jobTitleNormalized", "type": "str"},
        "emsi_id": {"key": "emsiId", "type": "str"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "classification": {
            "key": "classification",
            "type": "Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification",
        },
    }

    def __init__(
        self,
        *,
        job_title: Optional[str] = None,
        job_title_normalized: Optional[str] = None,
        emsi_id: Optional[str] = None,
        management_level: Optional[Union[str, "_models.ManagementLevel"]] = None,
        classification: Optional[
            "_models.Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification"
        ] = None,
        **kwargs,
    ):
        
        super(ResumeDataWorkExperienceItemOccupation, self).__init__(**kwargs)
        self.job_title = job_title
        self.job_title_normalized = job_title_normalized
        self.emsi_id = emsi_id
        self.management_level = management_level
        self.classification = classification


class ResumeRedact(Document):
    

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "ResumeRedactData"},
    }

    def __init__(
        self,
        *,
        meta: "_models.DocumentMeta",
        error: Optional["_models.DocumentError"] = None,
        warnings: Optional[List["_models.DocumentWarning"]] = None,
        data: Optional["_models.ResumeRedactData"] = None,
        **kwargs,
    ):
        
        super(ResumeRedact, self).__init__(meta=meta, error=error, warnings=warnings, **kwargs)
        self.extractor = "resume-redact"          self.data = data


class ResumeRedactData(msrest.serialization.Model):
    

    _attribute_map = {
        "redacted_pdf": {"key": "redactedPdf", "type": "str"},
    }

    def __init__(self, *, redacted_pdf: Optional[str] = None, **kwargs):
        
        super(ResumeRedactData, self).__init__(**kwargs)
        self.redacted_pdf = redacted_pdf


class ResumeSearch(msrest.serialization.Model):
    

    _validation = {
        "count": {"minimum": 0},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
        "parameters": {"key": "parameters", "type": "ResumeSearchParameters"},
        "results": {"key": "results", "type": "[ResumeSearchResult]"},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        next: Optional[str] = None,
        previous: Optional[str] = None,
        parameters: Optional["_models.ResumeSearchParameters"] = None,
        results: Optional[List["_models.ResumeSearchResult"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearch, self).__init__(**kwargs)
        self.count = count
        self.next = next
        self.previous = previous
        self.parameters = parameters
        self.results = results


class ResumeSearchConfig(msrest.serialization.Model):
    

    _validation = {
        "max_results": {"minimum": 1},
        "user_id": {"readonly": True, "minimum": 1},
        "username": {"readonly": True},
    }

    _attribute_map = {
        "allow_pdf_download": {"key": "allowPdfDownload", "type": "bool"},
        "max_results": {"key": "maxResults", "type": "int"},
        "display_job_title": {"key": "displayJobTitle", "type": "bool"},
        "display_location": {"key": "displayLocation", "type": "bool"},
        "display_years_experience": {"key": "displayYearsExperience", "type": "bool"},
        "display_occupation_group": {"key": "displayOccupationGroup", "type": "bool"},
        "display_education": {"key": "displayEducation", "type": "bool"},
        "display_skills": {"key": "displaySkills", "type": "bool"},
        "display_languages": {"key": "displayLanguages", "type": "bool"},
        "display_management_level": {"key": "displayManagementLevel", "type": "bool"},
        "display_keywords": {"key": "displayKeywords", "type": "bool"},
        "weight_job_title": {"key": "weightJobTitle", "type": "float"},
        "weight_location": {"key": "weightLocation", "type": "float"},
        "weight_years_experience": {"key": "weightYearsExperience", "type": "float"},
        "weight_occupation_group": {"key": "weightOccupationGroup", "type": "float"},
        "weight_education": {"key": "weightEducation", "type": "float"},
        "weight_skills": {"key": "weightSkills", "type": "float"},
        "weight_languages": {"key": "weightLanguages", "type": "float"},
        "weight_management_level": {"key": "weightManagementLevel", "type": "float"},
        "weight_keywords": {"key": "weightKeywords", "type": "float"},
        "indices": {"key": "indices", "type": "[str]"},
        "show_index_dropdown": {"key": "showIndexDropdown", "type": "bool"},
        "search_tool_theme": {
            "key": "searchToolTheme",
            "type": "ResumeSearchConfigSearchToolTheme",
        },
        "user_id": {"key": "userId", "type": "int"},
        "username": {"key": "username", "type": "str"},
        "actions": {"key": "actions", "type": "[SearchConfigAction]"},
        "hide_toolbar": {"key": "hideToolbar", "type": "bool"},
        "hide_side_panel": {"key": "hideSidePanel", "type": "bool"},
        "custom_fields_config": {"key": "customFieldsConfig", "type": "[CustomFieldConfig]"},
        "distance_unit": {"key": "distanceUnit", "type": "str"},
    }

    def __init__(
        self,
        *,
        allow_pdf_download: Optional[bool] = None,
        max_results: Optional[int] = None,
        display_job_title: Optional[bool] = None,
        display_location: Optional[bool] = None,
        display_years_experience: Optional[bool] = None,
        display_occupation_group: Optional[bool] = None,
        display_education: Optional[bool] = None,
        display_skills: Optional[bool] = None,
        display_languages: Optional[bool] = None,
        display_management_level: Optional[bool] = None,
        display_keywords: Optional[bool] = None,
        weight_job_title: Optional[float] = None,
        weight_location: Optional[float] = None,
        weight_years_experience: Optional[float] = None,
        weight_occupation_group: Optional[float] = None,
        weight_education: Optional[float] = None,
        weight_skills: Optional[float] = None,
        weight_languages: Optional[float] = None,
        weight_management_level: Optional[float] = None,
        weight_keywords: Optional[float] = None,
        indices: Optional[List[str]] = None,
        show_index_dropdown: Optional[bool] = None,
        search_tool_theme: Optional["_models.ResumeSearchConfigSearchToolTheme"] = None,
        actions: Optional[List["_models.SearchConfigAction"]] = None,
        hide_toolbar: Optional[bool] = None,
        hide_side_panel: Optional[bool] = None,
        custom_fields_config: Optional[List["_models.CustomFieldConfig"]] = None,
        distance_unit: Optional[Union[str, "_models.ResumeSearchConfigDistanceUnit"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchConfig, self).__init__(**kwargs)
        self.allow_pdf_download = allow_pdf_download
        self.max_results = max_results
        self.display_job_title = display_job_title
        self.display_location = display_location
        self.display_years_experience = display_years_experience
        self.display_occupation_group = display_occupation_group
        self.display_education = display_education
        self.display_skills = display_skills
        self.display_languages = display_languages
        self.display_management_level = display_management_level
        self.display_keywords = display_keywords
        self.weight_job_title = weight_job_title
        self.weight_location = weight_location
        self.weight_years_experience = weight_years_experience
        self.weight_occupation_group = weight_occupation_group
        self.weight_education = weight_education
        self.weight_skills = weight_skills
        self.weight_languages = weight_languages
        self.weight_management_level = weight_management_level
        self.weight_keywords = weight_keywords
        self.indices = indices
        self.show_index_dropdown = show_index_dropdown
        self.search_tool_theme = search_tool_theme
        self.user_id = None
        self.username = None
        self.actions = actions
        self.hide_toolbar = hide_toolbar
        self.hide_side_panel = hide_side_panel
        self.custom_fields_config = custom_fields_config
        self.distance_unit = distance_unit


class ResumeSearchConfigSearchToolTheme(ThemeConfig):
    

    _attribute_map = {
        "palette": {"key": "palette", "type": "ThemeConfigPalette"},
        "typography": {"key": "typography", "type": "ThemeConfigTypography"},
        "border_radius": {"key": "borderRadius", "type": "float"},
        "font_url": {"key": "fontUrl", "type": "str"},
    }

    def __init__(
        self,
        *,
        palette: Optional["_models.ThemeConfigPalette"] = None,
        typography: Optional["_models.ThemeConfigTypography"] = None,
        border_radius: Optional[float] = None,
        font_url: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeSearchConfigSearchToolTheme, self).__init__(
            palette=palette,
            typography=typography,
            border_radius=border_radius,
            font_url=font_url,
            **kwargs,
        )


class ResumeSearchDetail(msrest.serialization.Model):
    

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "ResumeSearchDetailJobTitle"},
        "location": {"key": "location", "type": "ResumeSearchDetailLocation"},
        "education": {"key": "education", "type": "ResumeSearchDetailEducation"},
        "skills": {"key": "skills", "type": "ResumeSearchDetailSkills"},
        "experience": {"key": "experience", "type": "ResumeSearchDetailExperience"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "ResumeSearchDetailOccupationGroup",
        },
        "languages": {"key": "languages", "type": "ResumeSearchDetailLanguages"},
        "management_level": {
            "key": "managementLevel",
            "type": "ResumeSearchDetailManagementLevel",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "ResumeSearchDetailSearchExpression",
        },
    }

    def __init__(
        self,
        *,
        job_title: Optional["_models.ResumeSearchDetailJobTitle"] = None,
        location: Optional["_models.ResumeSearchDetailLocation"] = None,
        education: Optional["_models.ResumeSearchDetailEducation"] = None,
        skills: Optional["_models.ResumeSearchDetailSkills"] = None,
        experience: Optional["_models.ResumeSearchDetailExperience"] = None,
        occupation_group: Optional["_models.ResumeSearchDetailOccupationGroup"] = None,
        languages: Optional["_models.ResumeSearchDetailLanguages"] = None,
        management_level: Optional["_models.ResumeSearchDetailManagementLevel"] = None,
        search_expression: Optional["_models.ResumeSearchDetailSearchExpression"] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetail, self).__init__(**kwargs)
        self.job_title = job_title
        self.location = location
        self.education = education
        self.skills = skills
        self.experience = experience
        self.occupation_group = occupation_group
        self.languages = languages
        self.management_level = management_level
        self.search_expression = search_expression


class ResumeSearchDetailEducation(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "ResumeSearchDetailEducationMissing"},
        "value": {"key": "value", "type": "[ResumeSearchDetailEducationValueItem]"},
    }

    def __init__(
        self,
        *,
        missing: Optional["_models.ResumeSearchDetailEducationMissing"] = None,
        value: Optional[List["_models.ResumeSearchDetailEducationValueItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailEducation, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSearchDetailEducationMissing(msrest.serialization.Model):
    

    _attribute_map = {
        "degrees": {"key": "degrees", "type": "[str]"},
        "highest_degree_types": {"key": "highestDegreeTypes", "type": "[str]"},
        "institutions": {"key": "institutions", "type": "[str]"},
        "current_student": {"key": "currentStudent", "type": "bool"},
        "recent_graduate": {"key": "recentGraduate", "type": "bool"},
    }

    def __init__(
        self,
        *,
        degrees: Optional[List[str]] = None,
        highest_degree_types: Optional[List[str]] = None,
        institutions: Optional[List[str]] = None,
        current_student: Optional[bool] = None,
        recent_graduate: Optional[bool] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailEducationMissing, self).__init__(**kwargs)
        self.degrees = degrees
        self.highest_degree_types = highest_degree_types
        self.institutions = institutions
        self.current_student = current_student
        self.recent_graduate = recent_graduate


class ResumeSearchDetailEducationValueItem(
    Education,
    ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1,
):
    

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "id": {"key": "id", "type": "int"},
        "organization": {"key": "organization", "type": "str"},
        "accreditation": {"key": "accreditation", "type": "Accreditation"},
        "grade": {"key": "grade", "type": "EducationGrade"},
        "location": {"key": "location", "type": "Location"},
        "dates": {"key": "dates", "type": "EducationDates"},
    }

    def __init__(
        self,
        *,
        match: Optional[bool] = None,
        id: Optional[int] = None,
        organization: Optional[str] = None,
        accreditation: Optional["_models.Accreditation"] = None,
        grade: Optional["_models.EducationGrade"] = None,
        location: Optional["_models.Location"] = None,
        dates: Optional["_models.EducationDates"] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailEducationValueItem, self).__init__(
            id=id,
            organization=organization,
            accreditation=accreditation,
            grade=grade,
            location=location,
            dates=dates,
            match=match,
            **kwargs,
        )
        self.match = match
        self.id = id
        self.organization = organization
        self.accreditation = accreditation
        self.grade = grade
        self.location = location
        self.dates = dates


class ResumeSearchDetailExperience(msrest.serialization.Model):
    

    _validation = {
        "years": {"minimum": 0},
    }

    _attribute_map = {
        "years": {"key": "years", "type": "int"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, *, years: Optional[int] = None, match: Optional[bool] = None, **kwargs):
        
        super(ResumeSearchDetailExperience, self).__init__(**kwargs)
        self.years = years
        self.match = match


class ResumeSearchDetailJobTitle(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "[ResumeSearchDetailJobTitleValueItem]"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List[str]] = None,
        value: Optional[List["_models.ResumeSearchDetailJobTitleValueItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailJobTitle, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSearchDetailJobTitleValueItem(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "start_date": {"key": "startDate", "type": "str"},
        "end_date": {"key": "endDate", "type": "str"},
        "company_name": {"key": "companyName", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        company_name: Optional[str] = None,
        match: Optional[bool] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailJobTitleValueItem, self).__init__(**kwargs)
        self.name = name
        self.start_date = start_date
        self.end_date = end_date
        self.company_name = company_name
        self.match = match


class ResumeSearchDetailLanguages(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[ResumeSearchDetailLanguagesValueItem]"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        value: Optional[List["_models.ResumeSearchDetailLanguagesValueItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailLanguages, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSkill(msrest.serialization.Model):
    

    _validation = {
        "number_of_months": {"minimum": 0},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "sources": {"key": "sources", "type": "[ResumeSkillSourcesItem]"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        last_used: Optional[str] = None,
        number_of_months: Optional[int] = None,
        type: Optional[str] = None,
        sources: Optional[List["_models.ResumeSkillSourcesItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSkill, self).__init__(**kwargs)
        self.name = name
        self.last_used = last_used
        self.number_of_months = number_of_months
        self.type = type
        self.sources = sources


class ResumeSearchDetailLanguagesValueItem(
    ResumeSkill,
    Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1,
):
    

    _validation = {
        "number_of_months": {"minimum": 0},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "sources": {"key": "sources", "type": "[ResumeSkillSourcesItem]"},
    }

    def __init__(
        self,
        *,
        match: Optional[bool] = None,
        name: Optional[str] = None,
        last_used: Optional[str] = None,
        number_of_months: Optional[int] = None,
        type: Optional[str] = None,
        sources: Optional[List["_models.ResumeSkillSourcesItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailLanguagesValueItem, self).__init__(
            name=name,
            last_used=last_used,
            number_of_months=number_of_months,
            type=type,
            sources=sources,
            match=match,
            **kwargs,
        )
        self.match = match
        self.name = name
        self.last_used = last_used
        self.number_of_months = number_of_months
        self.type = type
        self.sources = sources


class ResumeSearchDetailLocation(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersLocation]"},
        "value": {"key": "value", "type": "ResumeSearchDetailLocationValue"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List["_models.ResumeSearchParametersLocation"]] = None,
        value: Optional["_models.ResumeSearchDetailLocationValue"] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailLocation, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSearchDetailLocationValue(
    Location, ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1
):
    

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, *, raw_input: str, match: Optional[bool] = None, **kwargs):
        
        super(ResumeSearchDetailLocationValue, self).__init__(
            raw_input=raw_input, match=match, **kwargs
        )
        self.match = match
        self.formatted = None
        self.postal_code = None
        self.state = None
        self.state_code = None
        self.country = None
        self.country_code = None
        self.raw_input = raw_input
        self.street_number = None
        self.street = None
        self.apartment_number = None
        self.city = None
        self.latitude = None
        self.longitude = None
        self.po_box = None


class ResumeSearchDetailManagementLevel(msrest.serialization.Model):
    

    _attribute_map = {
        "level": {"key": "level", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(
        self,
        *,
        level: Optional[Union[str, "_models.ManagementLevel"]] = None,
        match: Optional[bool] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailManagementLevel, self).__init__(**kwargs)
        self.level = level
        self.match = match


class ResumeSearchDetailOccupationGroup(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[int]"},
        "value": {"key": "value", "type": "[OccupationGroupSearchResult]"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List[int]] = None,
        value: Optional[List["_models.OccupationGroupSearchResult"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailOccupationGroup, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSearchDetailSearchExpression(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "[str]"},
    }

    def __init__(
        self, *, missing: Optional[List[str]] = None, value: Optional[List[str]] = None, **kwargs
    ):
        
        super(ResumeSearchDetailSearchExpression, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSearchDetailSkills(msrest.serialization.Model):
    

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[ResumeSearchDetailSkillsValueItem]"},
    }

    def __init__(
        self,
        *,
        missing: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        value: Optional[List["_models.ResumeSearchDetailSkillsValueItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailSkills, self).__init__(**kwargs)
        self.missing = missing
        self.value = value


class ResumeSearchDetailSkillsValueItem(
    ResumeSkill,
    ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1,
):
    

    _validation = {
        "number_of_months": {"minimum": 0},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "sources": {"key": "sources", "type": "[ResumeSkillSourcesItem]"},
    }

    def __init__(
        self,
        *,
        match: Optional[bool] = None,
        name: Optional[str] = None,
        last_used: Optional[str] = None,
        number_of_months: Optional[int] = None,
        type: Optional[str] = None,
        sources: Optional[List["_models.ResumeSkillSourcesItem"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchDetailSkillsValueItem, self).__init__(
            name=name,
            last_used=last_used,
            number_of_months=number_of_months,
            type=type,
            sources=sources,
            match=match,
            **kwargs,
        )
        self.match = match
        self.name = name
        self.last_used = last_used
        self.number_of_months = number_of_months
        self.type = type
        self.sources = sources


class ResumeSearchEmbed(msrest.serialization.Model):
    

    _attribute_map = {
        "url": {"key": "url", "type": "str"},
    }

    def __init__(self, *, url: Optional[str] = None, **kwargs):
        
        super(ResumeSearchEmbed, self).__init__(**kwargs)
        self.url = url


class ResumeSearchMatch(msrest.serialization.Model):
    

    _validation = {
        "score": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "score": {"key": "score", "type": "float"},
        "details": {"key": "details", "type": "ResumeSearchMatchDetails"},
    }

    def __init__(
        self,
        *,
        score: Optional[float] = None,
        details: Optional["_models.ResumeSearchMatchDetails"] = None,
        **kwargs,
    ):
        
        super(ResumeSearchMatch, self).__init__(**kwargs)
        self.score = score
        self.details = details


class ResumeSearchMatchDetails(msrest.serialization.Model):
    

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "JobTitleSearchScoreComponent"},
        "management_level": {
            "key": "managementLevel",
            "type": "ManagementLevelSearchScoreComponent",
        },
        "experience": {"key": "experience", "type": "ExperienceSearchScoreComponent"},
        "skills": {"key": "skills", "type": "SkillsSearchScoreComponent"},
        "languages": {"key": "languages", "type": "LanguagesSearchScoreComponent"},
        "location": {"key": "location", "type": "LocationSearchScoreComponent"},
        "education": {"key": "education", "type": "EducationSearchScoreComponent"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "OccupationGroupSearchScoreComponent",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "SearchExpressionSearchScoreComponent",
        },
    }

    def __init__(
        self,
        *,
        job_title: Optional["_models.JobTitleSearchScoreComponent"] = None,
        management_level: Optional["_models.ManagementLevelSearchScoreComponent"] = None,
        experience: Optional["_models.ExperienceSearchScoreComponent"] = None,
        skills: Optional["_models.SkillsSearchScoreComponent"] = None,
        languages: Optional["_models.LanguagesSearchScoreComponent"] = None,
        location: Optional["_models.LocationSearchScoreComponent"] = None,
        education: Optional["_models.EducationSearchScoreComponent"] = None,
        occupation_group: Optional["_models.OccupationGroupSearchScoreComponent"] = None,
        search_expression: Optional["_models.SearchExpressionSearchScoreComponent"] = None,
        **kwargs,
    ):
        
        super(ResumeSearchMatchDetails, self).__init__(**kwargs)
        self.job_title = job_title
        self.management_level = management_level
        self.experience = experience
        self.skills = skills
        self.languages = languages
        self.location = location
        self.education = education
        self.occupation_group = occupation_group
        self.search_expression = search_expression


class ResumeSearchParameters(msrest.serialization.Model):
    

    _validation = {
        "indices": {"required": True},
        "job_titles_weight": {"maximum": 1, "minimum": 0},
        "years_experience_min": {"minimum": 0},
        "years_experience_max": {"minimum": 0},
        "years_experience_weight": {"maximum": 1, "minimum": 0},
        "locations_weight": {"maximum": 1, "minimum": 0},
        "skills_weight": {"maximum": 1, "minimum": 0},
        "languages_weight": {"maximum": 1, "minimum": 0},
        "highest_degree_types": {"unique": True},
        "education_weight": {"maximum": 1, "minimum": 0},
        "search_expression_weight": {"maximum": 1, "minimum": 0},
        "soc_codes_weight": {"maximum": 1, "minimum": 0},
        "management_level_weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "indices": {"key": "indices", "type": "[str]"},
        "job_description": {"key": "jobDescription", "type": "str"},
        "resume": {"key": "resume", "type": "str"},
        "job_titles": {"key": "jobTitles", "type": "[str]"},
        "job_titles_current_only": {"key": "jobTitlesCurrentOnly", "type": "bool"},
        "job_titles_required": {"key": "jobTitlesRequired", "type": "bool"},
        "job_titles_weight": {"key": "jobTitlesWeight", "type": "float"},
        "years_experience_min": {"key": "yearsExperienceMin", "type": "int"},
        "years_experience_max": {"key": "yearsExperienceMax", "type": "int"},
        "years_experience_required": {"key": "yearsExperienceRequired", "type": "bool"},
        "years_experience_weight": {"key": "yearsExperienceWeight", "type": "float"},
        "locations": {"key": "locations", "type": "[ResumeSearchParametersLocation]"},
        "locations_weight": {"key": "locationsWeight", "type": "float"},
        "locations_required": {"key": "locationsRequired", "type": "bool"},
        "skills": {"key": "skills", "type": "[ResumeSearchParametersSkill]"},
        "skills_weight": {"key": "skillsWeight", "type": "float"},
        "languages": {"key": "languages", "type": "[ResumeSearchParametersSkill]"},
        "languages_weight": {"key": "languagesWeight", "type": "float"},
        "institutions": {"key": "institutions", "type": "[str]"},
        "institutions_required": {"key": "institutionsRequired", "type": "bool"},
        "degrees": {"key": "degrees", "type": "[str]"},
        "degrees_required": {"key": "degreesRequired", "type": "bool"},
        "highest_degree_types": {"key": "highestDegreeTypes", "type": "[str]"},
        "highest_degree_types_required": {"key": "highestDegreeTypesRequired", "type": "bool"},
        "is_current_student": {"key": "isCurrentStudent", "type": "bool"},
        "is_current_student_required": {"key": "isCurrentStudentRequired", "type": "bool"},
        "is_recent_graduate": {"key": "isRecentGraduate", "type": "bool"},
        "is_recent_graduate_required": {"key": "isRecentGraduateRequired", "type": "bool"},
        "education_weight": {"key": "educationWeight", "type": "float"},
        "search_expression": {"key": "searchExpression", "type": "str"},
        "search_expression_required": {"key": "searchExpressionRequired", "type": "bool"},
        "search_expression_weight": {"key": "searchExpressionWeight", "type": "float"},
        "soc_codes": {"key": "socCodes", "type": "[int]"},
        "soc_codes_weight": {"key": "socCodesWeight", "type": "float"},
        "soc_codes_required": {"key": "socCodesRequired", "type": "bool"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "management_level_required": {"key": "managementLevelRequired", "type": "bool"},
        "management_level_weight": {"key": "managementLevelWeight", "type": "float"},
        "custom_data": {"key": "customData", "type": "[ResumeSearchParametersCustomData]"},
    }

    def __init__(
        self,
        *,
        indices: List[str],
        job_description: Optional[str] = None,
        resume: Optional[str] = None,
        job_titles: Optional[List[str]] = None,
        job_titles_current_only: Optional[bool] = None,
        job_titles_required: Optional[bool] = None,
        job_titles_weight: Optional[float] = None,
        years_experience_min: Optional[int] = None,
        years_experience_max: Optional[int] = None,
        years_experience_required: Optional[bool] = None,
        years_experience_weight: Optional[float] = None,
        locations: Optional[List["_models.ResumeSearchParametersLocation"]] = None,
        locations_weight: Optional[float] = None,
        locations_required: Optional[bool] = None,
        skills: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        skills_weight: Optional[float] = None,
        languages: Optional[List["_models.ResumeSearchParametersSkill"]] = None,
        languages_weight: Optional[float] = None,
        institutions: Optional[List[str]] = None,
        institutions_required: Optional[bool] = None,
        degrees: Optional[List[str]] = None,
        degrees_required: Optional[bool] = None,
        highest_degree_types: Optional[List[Union[str, "_models.EducationLevel"]]] = None,
        highest_degree_types_required: Optional[bool] = None,
        is_current_student: Optional[bool] = None,
        is_current_student_required: Optional[bool] = None,
        is_recent_graduate: Optional[bool] = None,
        is_recent_graduate_required: Optional[bool] = None,
        education_weight: Optional[float] = None,
        search_expression: Optional[str] = None,
        search_expression_required: Optional[bool] = None,
        search_expression_weight: Optional[float] = None,
        soc_codes: Optional[List[int]] = None,
        soc_codes_weight: Optional[float] = None,
        soc_codes_required: Optional[bool] = None,
        management_level: Optional[Union[str, "_models.ManagementLevel"]] = None,
        management_level_required: Optional[bool] = None,
        management_level_weight: Optional[float] = None,
        custom_data: Optional[List["_models.ResumeSearchParametersCustomData"]] = None,
        **kwargs,
    ):
        
        super(ResumeSearchParameters, self).__init__(**kwargs)
        self.indices = indices
        self.job_description = job_description
        self.resume = resume
        self.job_titles = job_titles
        self.job_titles_current_only = job_titles_current_only
        self.job_titles_required = job_titles_required
        self.job_titles_weight = job_titles_weight
        self.years_experience_min = years_experience_min
        self.years_experience_max = years_experience_max
        self.years_experience_required = years_experience_required
        self.years_experience_weight = years_experience_weight
        self.locations = locations
        self.locations_weight = locations_weight
        self.locations_required = locations_required
        self.skills = skills
        self.skills_weight = skills_weight
        self.languages = languages
        self.languages_weight = languages_weight
        self.institutions = institutions
        self.institutions_required = institutions_required
        self.degrees = degrees
        self.degrees_required = degrees_required
        self.highest_degree_types = highest_degree_types
        self.highest_degree_types_required = highest_degree_types_required
        self.is_current_student = is_current_student
        self.is_current_student_required = is_current_student_required
        self.is_recent_graduate = is_recent_graduate
        self.is_recent_graduate_required = is_recent_graduate_required
        self.education_weight = education_weight
        self.search_expression = search_expression
        self.search_expression_required = search_expression_required
        self.search_expression_weight = search_expression_weight
        self.soc_codes = soc_codes
        self.soc_codes_weight = soc_codes_weight
        self.soc_codes_required = soc_codes_required
        self.management_level = management_level
        self.management_level_required = management_level_required
        self.management_level_weight = management_level_weight
        self.custom_data = custom_data


class SearchParametersCustomData(msrest.serialization.Model):
    

    _validation = {
        "filter_type": {"required": True},
        "data_point": {"required": True},
        "query": {"required": True},
        "weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "query": {"key": "query", "type": "object"},
        "required": {"key": "required", "type": "bool"},
        "weight": {"key": "weight", "type": "float"},
    }

    def __init__(
        self,
        *,
        filter_type: Union[str, "_models.SearchParametersCustomDataFilterType"],
        data_point: str,
        query: Any,
        required: Optional[bool] = None,
        weight: Optional[float] = None,
        **kwargs,
    ):
        
        super(SearchParametersCustomData, self).__init__(**kwargs)
        self.filter_type = filter_type
        self.data_point = data_point
        self.query = query
        self.required = required
        self.weight = weight


class ResumeSearchParametersCustomData(SearchParametersCustomData):
    

    _validation = {
        "filter_type": {"required": True},
        "data_point": {"required": True},
        "query": {"required": True},
        "weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "query": {"key": "query", "type": "object"},
        "required": {"key": "required", "type": "bool"},
        "weight": {"key": "weight", "type": "float"},
    }

    def __init__(
        self,
        *,
        filter_type: Union[str, "_models.SearchParametersCustomDataFilterType"],
        data_point: str,
        query: Any,
        required: Optional[bool] = None,
        weight: Optional[float] = None,
        **kwargs,
    ):
        
        super(ResumeSearchParametersCustomData, self).__init__(
            filter_type=filter_type,
            data_point=data_point,
            query=query,
            required=required,
            weight=weight,
            **kwargs,
        )


class ResumeSearchParametersLocation(msrest.serialization.Model):
    

    _validation = {
        "distance": {"minimum": 1},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "coordinates": {"key": "coordinates", "type": "ResumeSearchParametersLocationCoordinates"},
        "distance": {"key": "distance", "type": "int"},
        "unit": {"key": "unit", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = "",
        coordinates: Optional["_models.ResumeSearchParametersLocationCoordinates"] = None,
        distance: Optional[int] = 100,
        unit: Optional[Union[str, "_models.SearchLocationUnit"]] = "km",
        **kwargs,
    ):
        
        super(ResumeSearchParametersLocation, self).__init__(**kwargs)
        self.name = name
        self.coordinates = coordinates
        self.distance = distance
        self.unit = unit


class ResumeSearchParametersLocationCoordinates(msrest.serialization.Model):
    

    _attribute_map = {
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
    }

    def __init__(
        self, *, latitude: Optional[float] = None, longitude: Optional[float] = None, **kwargs
    ):
        
        super(ResumeSearchParametersLocationCoordinates, self).__init__(**kwargs)
        self.latitude = latitude
        self.longitude = longitude


class ResumeSearchParametersSkill(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "required": {"key": "required", "type": "bool"},
    }

    def __init__(self, *, name: Optional[str] = None, required: Optional[bool] = None, **kwargs):
        
        super(ResumeSearchParametersSkill, self).__init__(**kwargs)
        self.name = name
        self.required = required


class ResumeSearchResult(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "score": {"required": True},
        "pdf": {"required": True},
        "job_title": {"required": True},
        "management_level": {"required": True},
        "experience": {"required": True},
        "skills": {"required": True},
        "languages": {"required": True},
        "location": {"required": True},
        "education": {"required": True},
        "occupation_group": {"required": True},
        "search_expression": {"required": True},
        "custom_data": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "score": {"key": "score", "type": "float"},
        "pdf": {"key": "pdf", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "job_title": {"key": "jobTitle", "type": "JobTitleSearchScoreComponent"},
        "management_level": {
            "key": "managementLevel",
            "type": "ManagementLevelSearchScoreComponent",
        },
        "experience": {"key": "experience", "type": "ExperienceSearchScoreComponent"},
        "skills": {"key": "skills", "type": "SkillsSearchScoreComponent"},
        "languages": {"key": "languages", "type": "LanguagesSearchScoreComponent"},
        "location": {"key": "location", "type": "LocationSearchScoreComponent"},
        "education": {"key": "education", "type": "EducationSearchScoreComponent"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "OccupationGroupSearchScoreComponent",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "SearchExpressionSearchScoreComponent",
        },
        "custom_data": {
            "key": "customData",
            "type": "{ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties}",
        },
    }

    def __init__(
        self,
        *,
        identifier: str,
        score: float,
        pdf: str,
        job_title: "_models.JobTitleSearchScoreComponent",
        management_level: "_models.ManagementLevelSearchScoreComponent",
        experience: "_models.ExperienceSearchScoreComponent",
        skills: "_models.SkillsSearchScoreComponent",
        languages: "_models.LanguagesSearchScoreComponent",
        location: "_models.LocationSearchScoreComponent",
        education: "_models.EducationSearchScoreComponent",
        occupation_group: "_models.OccupationGroupSearchScoreComponent",
        search_expression: "_models.SearchExpressionSearchScoreComponent",
        custom_data: Dict[
            str,
            "_models.ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties",
        ],
        name: Optional[str] = None,
        **kwargs,
    ):
        
        super(ResumeSearchResult, self).__init__(**kwargs)
        self.identifier = identifier
        self.score = score
        self.pdf = pdf
        self.name = name
        self.job_title = job_title
        self.management_level = management_level
        self.experience = experience
        self.skills = skills
        self.languages = languages
        self.location = location
        self.education = education
        self.occupation_group = occupation_group
        self.search_expression = search_expression
        self.custom_data = custom_data


class ResumeSkillSourcesItem(msrest.serialization.Model):
    

    _validation = {
        "position": {"minimum": 0},
    }

    _attribute_map = {
        "section": {"key": "section", "type": "str"},
        "position": {"key": "position", "type": "int"},
    }

    def __init__(
        self,
        *,
        section: Optional[Union[str, "_models.ResumeSkillSourcesItemSection"]] = None,
        position: Optional[int] = None,
        **kwargs,
    ):
        
        super(ResumeSkillSourcesItem, self).__init__(**kwargs)
        self.section = section
        self.position = position


class RowAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "RowAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.RowAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(RowAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class RowAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "item_code": {"key": "itemCode", "type": "TextAnnotation"},
        "item_date": {"key": "itemDate", "type": "DateAnnotation"},
        "item_description": {"key": "itemDescription", "type": "TextAnnotation"},
        "item_unit": {"key": "itemUnit", "type": "TextAnnotation"},
        "item_unit_price": {"key": "itemUnitPrice", "type": "FloatAnnotation"},
        "item_quantity": {"key": "itemQuantity", "type": "FloatAnnotation"},
        "item_discount": {"key": "itemDiscount", "type": "TextAnnotation"},
        "item_base_total": {"key": "itemBaseTotal", "type": "FloatAnnotation"},
        "item_tax_rate": {"key": "itemTaxRate", "type": "TextAnnotation"},
        "item_tax_total": {"key": "itemTaxTotal", "type": "FloatAnnotation"},
        "item_total": {"key": "itemTotal", "type": "FloatAnnotation"},
        "item_other": {"key": "itemOther", "type": "TextAnnotation"},
    }

    def __init__(
        self,
        *,
        item_code: Optional["_models.TextAnnotation"] = None,
        item_date: Optional["_models.DateAnnotation"] = None,
        item_description: Optional["_models.TextAnnotation"] = None,
        item_unit: Optional["_models.TextAnnotation"] = None,
        item_unit_price: Optional["_models.FloatAnnotation"] = None,
        item_quantity: Optional["_models.FloatAnnotation"] = None,
        item_discount: Optional["_models.TextAnnotation"] = None,
        item_base_total: Optional["_models.FloatAnnotation"] = None,
        item_tax_rate: Optional["_models.TextAnnotation"] = None,
        item_tax_total: Optional["_models.FloatAnnotation"] = None,
        item_total: Optional["_models.FloatAnnotation"] = None,
        item_other: Optional["_models.TextAnnotation"] = None,
        **kwargs,
    ):
        
        super(RowAnnotationParsed, self).__init__(**kwargs)
        self.item_code = item_code
        self.item_date = item_date
        self.item_description = item_description
        self.item_unit = item_unit
        self.item_unit_price = item_unit_price
        self.item_quantity = item_quantity
        self.item_discount = item_discount
        self.item_base_total = item_base_total
        self.item_tax_rate = item_tax_rate
        self.item_tax_total = item_tax_total
        self.item_total = item_total
        self.item_other = item_other


class RowBetaAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "RowBetaAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.RowBetaAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(RowBetaAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class RowBetaAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "item_code_beta": {"key": "itemCodeBeta", "type": "TextAnnotation"},
        "item_date_beta": {"key": "itemDateBeta", "type": "DateAnnotation"},
        "item_description_beta": {"key": "itemDescriptionBeta", "type": "TextAnnotation"},
        "item_unit_beta": {"key": "itemUnitBeta", "type": "TextAnnotation"},
        "item_unit_price_beta": {"key": "itemUnitPriceBeta", "type": "FloatAnnotation"},
        "item_quantity_beta": {"key": "itemQuantityBeta", "type": "FloatAnnotation"},
        "item_discount_beta": {"key": "itemDiscountBeta", "type": "TextAnnotation"},
        "item_base_total_beta": {"key": "itemBaseTotalBeta", "type": "FloatAnnotation"},
        "item_tax_rate_beta": {"key": "itemTaxRateBeta", "type": "TextAnnotation"},
        "item_tax_total_beta": {"key": "itemTaxTotalBeta", "type": "FloatAnnotation"},
        "item_total_beta": {"key": "itemTotalBeta", "type": "FloatAnnotation"},
        "item_other_beta": {"key": "itemOtherBeta", "type": "TextAnnotation"},
    }

    def __init__(
        self,
        *,
        item_code_beta: Optional["_models.TextAnnotation"] = None,
        item_date_beta: Optional["_models.DateAnnotation"] = None,
        item_description_beta: Optional["_models.TextAnnotation"] = None,
        item_unit_beta: Optional["_models.TextAnnotation"] = None,
        item_unit_price_beta: Optional["_models.FloatAnnotation"] = None,
        item_quantity_beta: Optional["_models.FloatAnnotation"] = None,
        item_discount_beta: Optional["_models.TextAnnotation"] = None,
        item_base_total_beta: Optional["_models.FloatAnnotation"] = None,
        item_tax_rate_beta: Optional["_models.TextAnnotation"] = None,
        item_tax_total_beta: Optional["_models.FloatAnnotation"] = None,
        item_total_beta: Optional["_models.FloatAnnotation"] = None,
        item_other_beta: Optional["_models.TextAnnotation"] = None,
        **kwargs,
    ):
        
        super(RowBetaAnnotationParsed, self).__init__(**kwargs)
        self.item_code_beta = item_code_beta
        self.item_date_beta = item_date_beta
        self.item_description_beta = item_description_beta
        self.item_unit_beta = item_unit_beta
        self.item_unit_price_beta = item_unit_price_beta
        self.item_quantity_beta = item_quantity_beta
        self.item_discount_beta = item_discount_beta
        self.item_base_total_beta = item_base_total_beta
        self.item_tax_rate_beta = item_tax_rate_beta
        self.item_tax_total_beta = item_tax_total_beta
        self.item_total_beta = item_total_beta
        self.item_other_beta = item_other_beta


class SearchConfigAction(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
        "event_name": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "event_name": {"key": "eventName", "type": "str"},
    }

    def __init__(self, *, label: str, event_name: str, **kwargs):
        
        super(SearchConfigAction, self).__init__(**kwargs)
        self.label = label
        self.event_name = event_name


class SearchExpressionSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(SearchExpressionSearchScoreComponent, self).__init__(**kwargs)
        self.label = label
        self.value = value
        self.score = score


class SkillAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        **kwargs,
    ):
        
        super(SkillAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = None


class SkillAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        **kwargs,
    ):
        
        super(SkillAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = None


class SkillsSearchScoreComponent(msrest.serialization.Model):
    

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(
        self, *, label: str, value: Optional[str] = None, score: Optional[float] = None, **kwargs
    ):
        
        super(SkillsSearchScoreComponent, self).__init__(**kwargs)
        self.value = value
        self.label = label
        self.score = score


class TableAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "TableAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.TableAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(TableAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class TableAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "rows": {"key": "rows", "type": "[RowAnnotation]"},
    }

    def __init__(self, *, rows: Optional[List["_models.RowAnnotation"]] = None, **kwargs):
        
        super(TableAnnotationParsed, self).__init__(**kwargs)
        self.rows = rows


class TableBetaAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "TableBetaAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.TableBetaAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(TableBetaAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class TableBetaAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "rows": {"key": "rows", "type": "[RowBetaAnnotation]"},
    }

    def __init__(self, *, rows: Optional[List["_models.RowBetaAnnotation"]] = None, **kwargs):
        
        super(TableBetaAnnotationParsed, self).__init__(**kwargs)
        self.rows = rows


class Tag(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "workspace": {"required": True},
        "document_count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "document_count": {"key": "documentCount", "type": "int"},
    }

    def __init__(self, *, id: int, name: str, workspace: str, document_count: int, **kwargs):
        
        super(Tag, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.workspace = workspace
        self.document_count = document_count


class TagCreate(msrest.serialization.Model):
    

    _validation = {
        "name": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
    }

    def __init__(self, *, name: str, workspace: str, **kwargs):
        
        super(TagCreate, self).__init__(**kwargs)
        self.name = name
        self.workspace = workspace


class TagUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
    }

    def __init__(self, *, name: Optional[str] = None, workspace: Optional[str] = None, **kwargs):
        
        super(TagUpdate, self).__init__(**kwargs)
        self.name = name
        self.workspace = workspace


class TextAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional[str] = None,
        **kwargs,
    ):
        
        super(TextAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class TextAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        parsed: Optional[str] = None,
        **kwargs,
    ):
        
        super(TextAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = parsed


class ThemeConfigPalette(msrest.serialization.Model):
    

    _attribute_map = {
        "mode": {"key": "mode", "type": "str"},
        "background": {"key": "background", "type": "object"},
        "text": {"key": "text", "type": "ThemeConfigPaletteText"},
        "divider": {"key": "divider", "type": "str"},
        "primary": {"key": "primary", "type": "PaletteColorOptions"},
        "secondary": {"key": "secondary", "type": "PaletteColorOptions"},
        "success": {"key": "success", "type": "PaletteColorOptions"},
        "annotation": {"key": "annotation", "type": "PaletteColorOptions"},
        "error": {"key": "error", "type": "PaletteColorOptions"},
        "info": {"key": "info", "type": "PaletteColorOptions"},
        "warning": {"key": "warning", "type": "PaletteColorOptions"},
    }

    def __init__(
        self,
        *,
        mode: Optional[Union[str, "_models.ThemeConfigPaletteMode"]] = None,
        background: Optional[Any] = None,
        text: Optional["_models.ThemeConfigPaletteText"] = None,
        divider: Optional[str] = None,
        primary: Optional["_models.PaletteColorOptions"] = None,
        secondary: Optional["_models.PaletteColorOptions"] = None,
        success: Optional["_models.PaletteColorOptions"] = None,
        annotation: Optional["_models.PaletteColorOptions"] = None,
        error: Optional["_models.PaletteColorOptions"] = None,
        info: Optional["_models.PaletteColorOptions"] = None,
        warning: Optional["_models.PaletteColorOptions"] = None,
        **kwargs,
    ):
        
        super(ThemeConfigPalette, self).__init__(**kwargs)
        self.mode = mode
        self.background = background
        self.text = text
        self.divider = divider
        self.primary = primary
        self.secondary = secondary
        self.success = success
        self.annotation = annotation
        self.error = error
        self.info = info
        self.warning = warning


class ThemeConfigPaletteText(msrest.serialization.Model):
    

    _attribute_map = {
        "primary": {"key": "primary", "type": "str"},
        "secondary": {"key": "secondary", "type": "str"},
        "disabled": {"key": "disabled", "type": "str"},
    }

    def __init__(
        self,
        *,
        primary: Optional[str] = None,
        secondary: Optional[str] = None,
        disabled: Optional[str] = None,
        **kwargs,
    ):
        
        super(ThemeConfigPaletteText, self).__init__(**kwargs)
        self.primary = primary
        self.secondary = secondary
        self.disabled = disabled


class ThemeConfigTypography(msrest.serialization.Model):
    

    _attribute_map = {
        "font_family": {"key": "fontFamily", "type": "str"},
        "font_size": {"key": "fontSize", "type": "object"},
        "font_weight_regular": {"key": "fontWeightRegular", "type": "str"},
        "font_weight_medium": {"key": "fontWeightMedium", "type": "str"},
        "font_weight_bold": {"key": "fontWeightBold", "type": "str"},
    }

    def __init__(
        self,
        *,
        font_family: Optional[str] = None,
        font_size: Optional[Any] = None,
        font_weight_regular: Optional[str] = None,
        font_weight_medium: Optional[str] = None,
        font_weight_bold: Optional[str] = None,
        **kwargs,
    ):
        
        super(ThemeConfigTypography, self).__init__(**kwargs)
        self.font_family = font_family
        self.font_size = font_size
        self.font_weight_regular = font_weight_regular
        self.font_weight_medium = font_weight_medium
        self.font_weight_bold = font_weight_bold


class UrlAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "UrlAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.UrlAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(UrlAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class UrlAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "url": {"key": "url", "type": "str"},
        "domain": {"key": "domain", "type": "str"},
    }

    def __init__(self, *, url: Optional[str] = None, domain: Optional[str] = None, **kwargs):
        
        super(UrlAnnotationParsed, self).__init__(**kwargs)
        self.url = url
        self.domain = domain


class UsageByCollection(msrest.serialization.Model):
    

    _validation = {
        "month": {"required": True},
        "count": {"required": True},
    }

    _attribute_map = {
        "month": {"key": "month", "type": "str"},
        "count": {"key": "count", "type": "int"},
    }

    def __init__(self, *, month: str, count: int, **kwargs):
        
        super(UsageByCollection, self).__init__(**kwargs)
        self.month = month
        self.count = count


class UsageByWorkspace(msrest.serialization.Model):
    

    _validation = {
        "month": {"required": True},
        "count": {"required": True},
    }

    _attribute_map = {
        "month": {"key": "month", "type": "str"},
        "count": {"key": "count", "type": "int"},
    }

    def __init__(self, *, month: str, count: int, **kwargs):
        
        super(UsageByWorkspace, self).__init__(**kwargs)
        self.month = month
        self.count = count


class UserNullable(msrest.serialization.Model):
    

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,
        name: Optional[str] = None,
        username: Optional[str] = None,
        email: Optional[str] = None,
        avatar: Optional[str] = None,
        **kwargs,
    ):
        
        super(UserNullable, self).__init__(**kwargs)
        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.avatar = avatar


class ValidationResult(msrest.serialization.Model):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "annotations": {"required": True},
        "passed": {"required": True},
        "rule_slug": {"required": True, "pattern": r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"},
        "message": {"required": True},
        "document": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "annotations": {"key": "annotations", "type": "[int]"},
        "passed": {"key": "passed", "type": "bool"},
        "rule_slug": {"key": "ruleSlug", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "document": {"key": "document", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: int,
        annotations: List[int],
        passed: bool,
        rule_slug: str,
        message: str,
        document: str,
        **kwargs,
    ):
        
        super(ValidationResult, self).__init__(**kwargs)
        self.id = id
        self.annotations = annotations
        self.passed = passed
        self.rule_slug = rule_slug
        self.message = message
        self.document = document


class ValidationResultCreate(msrest.serialization.Model):
    

    _validation = {
        "annotations": {"required": True},
        "rule_slug": {"required": True, "pattern": r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"},
        "message": {"required": True},
        "document": {"required": True},
    }

    _attribute_map = {
        "annotations": {"key": "annotations", "type": "[int]"},
        "passed": {"key": "passed", "type": "bool"},
        "rule_slug": {"key": "ruleSlug", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "document": {"key": "document", "type": "str"},
    }

    def __init__(
        self,
        *,
        annotations: List[int],
        rule_slug: str,
        message: str,
        document: str,
        passed: Optional[bool] = None,
        **kwargs,
    ):
        
        super(ValidationResultCreate, self).__init__(**kwargs)
        self.annotations = annotations
        self.passed = passed
        self.rule_slug = rule_slug
        self.message = message
        self.document = document


class ValidationResultUpdate(msrest.serialization.Model):
    

    _validation = {
        "rule_slug": {"pattern": r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"},
    }

    _attribute_map = {
        "annotations": {"key": "annotations", "type": "[int]"},
        "passed": {"key": "passed", "type": "bool"},
        "rule_slug": {"key": "ruleSlug", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "document": {"key": "document", "type": "str"},
    }

    def __init__(
        self,
        *,
        annotations: Optional[List[int]] = None,
        passed: Optional[bool] = None,
        rule_slug: Optional[str] = None,
        message: Optional[str] = None,
        document: Optional[str] = None,
        **kwargs,
    ):
        
        super(ValidationResultUpdate, self).__init__(**kwargs)
        self.annotations = annotations
        self.passed = passed
        self.rule_slug = rule_slug
        self.message = message
        self.document = document


class ValidationRule(msrest.serialization.Model):
    

    _validation = {
        "slug": {"required": True, "pattern": r"^[a-z0-9_]+$"},
        "data_points": {"required": True},
    }

    _attribute_map = {
        "slug": {"key": "slug", "type": "str"},
        "data_points": {"key": "dataPoints", "type": "[str]"},
    }

    def __init__(self, *, slug: str, data_points: List[str], **kwargs):
        
        super(ValidationRule, self).__init__(**kwargs)
        self.slug = slug
        self.data_points = data_points


class ValidationToolConfig(msrest.serialization.Model):
    

    _attribute_map = {
        "theme": {"key": "theme", "type": "ThemeConfig"},
        "hide_actions": {"key": "hideActions", "type": "bool"},
        "hide_collection": {"key": "hideCollection", "type": "bool"},
        "hide_edit_pages": {"key": "hideEditPages", "type": "bool"},
        "hide_export": {"key": "hideExport", "type": "bool"},
        "hide_filename": {"key": "hideFilename", "type": "bool"},
        "hide_reject": {"key": "hideReject", "type": "bool"},
        "hide_reparse": {"key": "hideReparse", "type": "bool"},
        "hide_run_ocr": {"key": "hideRunOcr", "type": "bool"},
        "hide_tags": {"key": "hideTags", "type": "bool"},
        "hide_warnings": {"key": "hideWarnings", "type": "bool"},
        "restrict_document_splitting": {"key": "restrictDocumentSplitting", "type": "bool"},
        "disable_currency_formatting": {"key": "disableCurrencyFormatting", "type": "bool"},
        "disable_edit_document_metadata": {"key": "disableEditDocumentMetadata", "type": "bool"},
    }

    def __init__(
        self,
        *,
        theme: Optional["_models.ThemeConfig"] = None,
        hide_actions: Optional[bool] = None,
        hide_collection: Optional[bool] = None,
        hide_edit_pages: Optional[bool] = None,
        hide_export: Optional[bool] = None,
        hide_filename: Optional[bool] = None,
        hide_reject: Optional[bool] = None,
        hide_reparse: Optional[bool] = None,
        hide_run_ocr: Optional[bool] = None,
        hide_tags: Optional[bool] = None,
        hide_warnings: Optional[bool] = None,
        restrict_document_splitting: Optional[bool] = None,
        disable_currency_formatting: Optional[bool] = None,
        disable_edit_document_metadata: Optional[bool] = None,
        **kwargs,
    ):
        
        super(ValidationToolConfig, self).__init__(**kwargs)
        self.theme = theme
        self.hide_actions = hide_actions
        self.hide_collection = hide_collection
        self.hide_edit_pages = hide_edit_pages
        self.hide_export = hide_export
        self.hide_filename = hide_filename
        self.hide_reject = hide_reject
        self.hide_reparse = hide_reparse
        self.hide_run_ocr = hide_run_ocr
        self.hide_tags = hide_tags
        self.hide_warnings = hide_warnings
        self.restrict_document_splitting = restrict_document_splitting
        self.disable_currency_formatting = disable_currency_formatting
        self.disable_edit_document_metadata = disable_edit_document_metadata


class Workspace(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "unvalidated_docs_count": {"minimum": 0},
        "confirmed_docs_count": {"minimum": 0},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "name": {"key": "name", "type": "str"},
        "visibility": {"key": "visibility", "type": "str"},
        "collections": {"key": "collections", "type": "[WorkspaceCollectionsItem]"},
        "reject_invalid_documents": {"key": "rejectInvalidDocuments", "type": "bool"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "members": {"key": "members", "type": "[User]"},
        "unvalidated_docs_count": {"key": "unvalidatedDocsCount", "type": "int"},
        "confirmed_docs_count": {"key": "confirmedDocsCount", "type": "int"},
        "ingest_email": {"key": "ingestEmail", "type": "str"},
        "whitelist_ingest_addresses": {"key": "whitelistIngestAddresses", "type": "[str]"},
        "document_splitter": {"key": "documentSplitter", "type": "WorkspaceDocumentSplitter"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        organization: Optional["_models.Organization"] = None,
        name: Optional[str] = None,
        visibility: Optional[Union[str, "_models.WorkspaceVisibility"]] = None,
        collections: Optional[List["_models.WorkspaceCollectionsItem"]] = None,
        reject_invalid_documents: Optional[bool] = None,
        reject_duplicates: Optional[bool] = None,
        members: Optional[List["_models.User"]] = None,
        unvalidated_docs_count: Optional[int] = None,
        confirmed_docs_count: Optional[int] = None,
        ingest_email: Optional[str] = None,
        whitelist_ingest_addresses: Optional[List[str]] = None,
        document_splitter: Optional["_models.WorkspaceDocumentSplitter"] = None,
        **kwargs,
    ):
        
        super(Workspace, self).__init__(**kwargs)
        self.identifier = identifier
        self.organization = organization
        self.name = name
        self.visibility = visibility
        self.collections = collections
        self.reject_invalid_documents = reject_invalid_documents
        self.reject_duplicates = reject_duplicates
        self.members = members
        self.unvalidated_docs_count = unvalidated_docs_count
        self.confirmed_docs_count = confirmed_docs_count
        self.ingest_email = ingest_email
        self.whitelist_ingest_addresses = whitelist_ingest_addresses
        self.document_splitter = document_splitter


class WorkspaceCollectionsItem(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "extractor": {"required": True},
        "unvalidated_docs_count": {"minimum": 0},
        "confirmed_docs_count": {"minimum": 0},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "extractor": {"key": "extractor", "type": "WorkspaceCollectionsItemExtractor"},
        "unvalidated_docs_count": {"key": "unvalidatedDocsCount", "type": "int"},
        "confirmed_docs_count": {"key": "confirmedDocsCount", "type": "int"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        extractor: "_models.WorkspaceCollectionsItemExtractor",
        unvalidated_docs_count: Optional[int] = None,
        confirmed_docs_count: Optional[int] = None,
        **kwargs,
    ):
        
        super(WorkspaceCollectionsItem, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.extractor = extractor
        self.unvalidated_docs_count = unvalidated_docs_count
        self.confirmed_docs_count = confirmed_docs_count


class WorkspaceCollectionsItemExtractor(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "BaseExtractor"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        identifier: str,
        name: str,
        name_plural: str,
        validatable: bool,
        base_extractor: Optional["_models.BaseExtractor"] = None,
        category: Optional[str] = None,
        is_custom: Optional[bool] = None,
        created_dt: Optional[datetime.datetime] = None,
        **kwargs,
    ):
        
        super(WorkspaceCollectionsItemExtractor, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name
        self.name_plural = name_plural
        self.base_extractor = base_extractor
        self.category = category
        self.validatable = validatable
        self.is_custom = is_custom
        self.created_dt = created_dt


class WorkspaceCreate(msrest.serialization.Model):
    

    _validation = {
        "organization": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "organization": {"key": "organization", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "visibility": {"key": "visibility", "type": "str"},
        "reject_invalid_documents": {"key": "rejectInvalidDocuments", "type": "bool"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "whitelist_ingest_addresses": {"key": "whitelistIngestAddresses", "type": "[str]"},
        "document_splitter": {"key": "documentSplitter", "type": "str"},
    }

    def __init__(
        self,
        *,
        organization: str,
        name: str,
        visibility: Optional[Union[str, "_models.WorkspaceVisibility"]] = None,
        reject_invalid_documents: Optional[bool] = None,
        reject_duplicates: Optional[bool] = None,
        whitelist_ingest_addresses: Optional[List[str]] = None,
        document_splitter: Optional[str] = None,
        **kwargs,
    ):
        
        super(WorkspaceCreate, self).__init__(**kwargs)
        self.organization = organization
        self.name = name
        self.visibility = visibility
        self.reject_invalid_documents = reject_invalid_documents
        self.reject_duplicates = reject_duplicates
        self.whitelist_ingest_addresses = whitelist_ingest_addresses
        self.document_splitter = document_splitter


class WorkspaceDocumentSplitter(msrest.serialization.Model):
    

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, *, identifier: str, name: str, **kwargs):
        
        super(WorkspaceDocumentSplitter, self).__init__(**kwargs)
        self.identifier = identifier
        self.name = name


class WorkspaceMembership(msrest.serialization.Model):
    

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "user": {"key": "user", "type": "User"},
    }

    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        workspace: Optional[str] = None,
        user: Optional["_models.User"] = None,
        **kwargs,
    ):
        
        super(WorkspaceMembership, self).__init__(**kwargs)
        self.identifier = identifier
        self.workspace = workspace
        self.user = user


class WorkspaceMembershipCreate(msrest.serialization.Model):
    

    _validation = {
        "user": {"minimum": 1},
    }

    _attribute_map = {
        "workspace": {"key": "workspace", "type": "str"},
        "user": {"key": "user", "type": "int"},
    }

    def __init__(self, *, workspace: Optional[str] = None, user: Optional[int] = None, **kwargs):
        
        super(WorkspaceMembershipCreate, self).__init__(**kwargs)
        self.workspace = workspace
        self.user = user


class WorkspaceUpdate(msrest.serialization.Model):
    

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "visibility": {"key": "visibility", "type": "str"},
        "reject_invalid_documents": {"key": "rejectInvalidDocuments", "type": "bool"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "whitelist_ingest_addresses": {"key": "whitelistIngestAddresses", "type": "[str]"},
        "document_splitter": {"key": "documentSplitter", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        visibility: Optional[Union[str, "_models.WorkspaceVisibility"]] = None,
        reject_invalid_documents: Optional[bool] = None,
        reject_duplicates: Optional[bool] = None,
        whitelist_ingest_addresses: Optional[List[str]] = None,
        document_splitter: Optional[str] = None,
        **kwargs,
    ):
        
        super(WorkspaceUpdate, self).__init__(**kwargs)
        self.name = name
        self.visibility = visibility
        self.reject_invalid_documents = reject_invalid_documents
        self.reject_duplicates = reject_duplicates
        self.whitelist_ingest_addresses = whitelist_ingest_addresses
        self.document_splitter = document_splitter


class YearsExperienceAnnotation(Annotation):
    

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "YearsExperienceAnnotationParsed"},
    }

    def __init__(
        self,
        *,
        id: int,
        rectangle: "_models.Rectangle",
        rectangles: List["_models.Rectangle"],
        document: str,
        page_index: int,
        raw: str,
        confidence: float,
        classification_confidence: float,
        text_extraction_confidence: float,
        is_verified: bool,
        is_client_verified: bool,
        is_auto_verified: bool,
        data_point: str,
        content_type: Union[str, "_models.AnnotationContentType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        parent: Optional[int] = None,
        parsed: Optional["_models.YearsExperienceAnnotationParsed"] = None,
        **kwargs,
    ):
        
        super(YearsExperienceAnnotation, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            rectangles=rectangles,
            document=document,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            parent=parent,
            **kwargs,
        )
        self.parsed = parsed


class YearsExperienceAnnotationParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
    }

    def __init__(
        self, *, minimum: Optional[float] = None, maximum: Optional[float] = None, **kwargs
    ):
        
        super(YearsExperienceAnnotationParsed, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum


class YearsExperienceAnnotationUpdate(AnnotationBase):
    

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "YearsExperienceAnnotationUpdateParsed"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[int] = None,
        rectangle: Optional["_models.Rectangle"] = None,
        page_index: Optional[int] = None,
        raw: Optional[str] = None,
        confidence: Optional[float] = None,
        classification_confidence: Optional[float] = None,
        text_extraction_confidence: Optional[float] = None,
        is_verified: Optional[bool] = None,
        is_client_verified: Optional[bool] = None,
        is_auto_verified: Optional[bool] = None,
        data_point: Optional[str] = None,
        content_type: Optional[str] = None,
        parsed: Optional["_models.YearsExperienceAnnotationUpdateParsed"] = None,
        **kwargs,
    ):
        
        super(YearsExperienceAnnotationUpdate, self).__init__(
            additional_properties=additional_properties,
            id=id,
            rectangle=rectangle,
            page_index=page_index,
            raw=raw,
            confidence=confidence,
            classification_confidence=classification_confidence,
            text_extraction_confidence=text_extraction_confidence,
            is_verified=is_verified,
            is_client_verified=is_client_verified,
            is_auto_verified=is_auto_verified,
            data_point=data_point,
            content_type=content_type,
            **kwargs,
        )
        self.parsed = parsed


class YearsExperienceAnnotationUpdateParsed(msrest.serialization.Model):
    

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
    }

    def __init__(
        self, *, minimum: Optional[float] = None, maximum: Optional[float] = None, **kwargs
    ):
        
        super(YearsExperienceAnnotationUpdateParsed, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
}
affinda-python-master\affinda\models _affinda_api_enums.py{from enum import Enum
from azure.core import CaseInsensitiveEnumMeta


class AnnotationContentType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    TEXT = "text"
    INTEGER = "integer"
    FLOAT = "float"
    DECIMAL = "decimal"
    DATE = "date"
    DATETIME = "datetime"
    DATERANGE = "daterange"
    BOOLEAN = "boolean"
    ENUM = "enum"
    LOCATION = "location"
    PHONENUMBER = "phonenumber"
    JSON = "json"
    TABLE = "table"
    EXPECTEDREMUNERATION = "expectedremuneration"
    JOBTITLE = "jobtitle"
    LANGUAGE = "language"
    SKILL = "skill"
    YEARSEXPERIENCE = "yearsexperience"
    GROUP = "group"
    TABLE_DEPRECATED = "table_deprecated"
    URL = "url"
    IMAGE = "image"
    DOCCLF = "docclf"


class CollectionDateFormatPreference(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    DMY = "DMY"
    MDY = "MDY"
    YMD = "YMD"


class DateFormatPreference(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    DMY = "DMY"
    MDY = "MDY"
    YMD = "YMD"


class DateRange(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    TODAY = "today"
    YESTERDAY = "yesterday"
    WEEK = "week"
    MONTH = "month"
    YEAR = "year"


class DocType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    RESUMES = "resumes"
    JOB_DESCRIPTIONS = "job_descriptions"


class DocumentFormat(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    JSON = "json"
    XML = "xml"
    HR_XML = "hr-xml"


class DocumentSplitterType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    LLM = "llm"
    EXTRACTOR = "extractor"
    KEYWORD = "keyword"


class DocumentState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    UPLOADED = "uploaded"
    REVIEW = "review"
    VALIDATED = "validated"
    ARCHIVED = "archived"
    REJECTED = "rejected"


class EducationLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    SCHOOL = "school"
    CERTIFICATE = "certificate"
    BACHELORS = "bachelors"
    MASTERS = "masters"
    DOCTORAL = "doctoral"


class Enum22(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    RESUMES = "resumes"
    JOB_DESCRIPTIONS = "job_descriptions"


class IndexDocType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    RESUMES = "resumes"
    JOB_DESCRIPTIONS = "job_descriptions"


class InvitationResponseStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    ACCEPTED = "accepted"
    DECLINED = "declined"


class InvitationStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"


class JobDescriptionSearchConfigDistanceUnit(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    MI = "mi"
    KM = "km"


class ManagementLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    NONE = "None"
    LOW = "Low"
    MID = "Mid"
    UPPER = "Upper"


class OrganizationRole(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    ADMIN = "admin"
    MEMBER = "member"


class OrganizationUserRole(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    ADMIN = "admin"
    MEMBER = "member"


class Region(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    API = "api"
    API_EU1 = "api.eu1"
    API_US1 = "api.us1"


class ResthookEvent(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    RESUME_PARSE_SUCCEEDED = "resume.parse.succeeded"
    RESUME_PARSE_FAILED = "resume.parse.failed"
    RESUME_PARSE_COMPLETED = "resume.parse.completed"
    INVOICE_PARSE_SUCCEEDED = "invoice.parse.succeeded"
    INVOICE_PARSE_FAILED = "invoice.parse.failed"
    INVOICE_PARSE_COMPLETED = "invoice.parse.completed"
    INVOICE_VALIDATE_COMPLETED = "invoice.validate.completed"
    DOCUMENT_PARSE_SUCCEEDED = "document.parse.succeeded"
    DOCUMENT_PARSE_FAILED = "document.parse.failed"
    DOCUMENT_PARSE_COMPLETED = "document.parse.completed"
    DOCUMENT_VALIDATE_COMPLETED = "document.validate.completed"
    DOCUMENT_CLASSIFY_SUCCEEDED = "document.classify.succeeded"
    DOCUMENT_CLASSIFY_FAILED = "document.classify.failed"
    DOCUMENT_CLASSIFY_COMPLETED = "document.classify.completed"
    DOCUMENT_REJECTED = "document.rejected"
    ANNOTATION_VALIDATED = "annotation.validated"


class ResthookSubscriptionVersion(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    V1 = "v1"
    V2 = "v2"
    V3 = "v3"


class ResumeDataLanguagesItem(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    AINU = "Ainu"
    AKAN = "Akan"
    AKKADIAN = "Akkadian"
    AMHARIC = "Amharic"
    ANAM = "Anam"
    ARABIC = "Arabic"
    ARAMAIC = "Aramaic"
    AREM = "Arem"
    ARMENIAN = "Armenian"
    AWADHI = "Awadhi"
    AYMARA = "Aymara"
    AZARI = "Azari"
    BAGHELI = "Bagheli"
    BAGRI = "Bagri"
    BAHASA = "Bahasa"
    BAHASA_INDONESIAN = "Bahasa Indonesian"
    BAMBARA = "Bambara"
    BANGALA = "Bangala"
    BARDI = "Bardi"
    BASSA = "Bassa"
    BATAK = "Batak"
    BELARUSIAN = "Belarusian"
    BEMBA = "Bemba"
    BENGA = "Benga"
    BENGALI = "Bengali"
    BERBER = "Berber"
    BHOJPURI = "Bhojpuri"
    BISLAMA = "Bislama"
    BRAHUI = "Brahui"
    BULGARIAN = "Bulgarian"
    BUNU = "Bunu"
    CAMBODIAN = "Cambodian"
    CAREW = "Carew"
    CARIB = "Carib"
    CATALAN = "Catalan"
    CEBUANO = "Cebuano"
    CHAKMA = "Chakma"
    CHAMORRO = "Chamorro"
    CHANGO = "Chango"
    CHEWA = "Chewa"
    CROATIAN = "Croatian"
    CZECH = "Czech"
    DAGBANI = "Dagbani"
    DANISH = "Danish"
    DARI = "Dari"
    DAYI = "Dayi"
    DHATKI = "Dhatki"
    DHIVEHI = "Dhivehi"
    DINKA = "Dinka"
    DOGRI = "Dogri"
    DUALA = "Duala"
    DUTCH = "Dutch"
    ENGLISH = "English"
    ESPERANTO = "Esperanto"
    ESTONIAN = "Estonian"
    EWONDO = "Ewondo"
    FAROESE = "Faroese"
    FILIPINO = "Filipino"
    FINNISH = "Finnish"
    FORMULA = "Formula"
    FRENCH = "French"
    FRISIAN = "Frisian"
    FRIULIAN = "Friulian"
    FULA = "Fula"
    GAELIC = "Gaelic"
    GALO = "Galo"
    GARHWALI = "Garhwali"
    GARIFUNA = "Garifuna"
    GERMAN = "German"
    GIKUYU = "Gikuyu"
    GUJARATI = "Gujarati"
    GUJERATI = "Gujerati"
    GWERE = "Gwere"
    HAWAIIAN = "Hawaiian"
    HAYA = "Haya"
    HEBREW = "Hebrew"
    HINDI = "Hindi"
    HMU = "Hmu"
    HOKKIEN = "Hokkien"
    HOPI = "Hopi"
    HUNGARIAN = "Hungarian"
    HUP = "Hup"
    IBANAG = "Ibanag"
    IGBO = "Igbo"
    ILOKANO = "Ilokano"
    INDONESIAN = "Indonesian"
    INTERMEDIATE = "Intermediate"
    IRISH = "Irish"
    ITALIAN = "Italian"
    JAPANESE = "Japanese"
    JIBA = "Jiba"
    KACHIN = "Kachin"
    KALENJIN = "Kalenjin"
    KAMAYO = "Kamayo"
    KANNADA = "Kannada"
    KAONDE = "Kaonde"
    KAYAN = "Kayan"
    KHANDESHI = "Khandeshi"
    KHMER = "Khmer"
    KIKUYU = "Kikuyu"
    KODAVA = "Kodava"
    KOMA = "Koma"
    KONGO = "Kongo"
    KONKANI = "Konkani"
    KOREAN = "Korean"
    KORWA = "Korwa"
    KREYOL = "Kreyol"
    KRIO = "Krio"
    KUMAONI = "Kumaoni"
    KURDISH = "Kurdish"
    KURUKH = "Kurukh"
    KWA = "Kwa"
    LADINO = "Ladino"
    LANGO = "Lango"
    LATVIAN = "Latvian"
    LAWA = "Lawa"
    LINGALA = "Lingala"
    LITHUANIAN = "Lithuanian"
    LULE = "Lule"
    LUXEMBOURGISH = "Luxembourgish"
    MAGAHI = "Magahi"
    MAITHILI = "Maithili"
    MALAY = "Malay"
    MALAYALAM = "Malayalam"
    MALAYSIAN = "Malaysian"
    MALVI = "Malvi"
    MANINKA = "Maninka"
    MANIPURI = "Manipuri"
    MANX = "Manx"
    MARATHI = "Marathi"
    MAYAN = "Mayan"
    MEDUMBA = "Medumba"
    MEMONI = "Memoni"
    MEWARI = "Mewari"
    MIZO = "Mizo"
    MONTENEGRIN = "Montenegrin"
    MWAN = "Mwan"
    MWANGA = "Mwanga"
    NDEBELE = "Ndebele"
    NEPALI = "Nepali"
    NIMADI = "Nimadi"
    ORIYA = "Oriya"
    OROMO = "Oromo"
    OVAMBO = "Ovambo"
    PAMONA = "Pamona"
    PANGASINAN = "Pangasinan"
    PASHTO = "Pashto"
    PHOENICIAN = "Phoenician"
    POLISH = "Polish"
    PORTUGUESE = "Portuguese"
    PULAAR = "Pulaar"
    PULAR = "Pular"
    PUNJABI = "Punjabi"
    QUECHA = "Quecha"
    RAJASTHANI = "Rajasthani"
    ROMANIAN = "Romanian"
    RUSSIAN = "Russian"
    SAKHA = "Sakha"
    SANGO = "Sango"
    SANTHALI = "Santhali"
    SARAIKI = "Saraiki"
    SEIM = "Seim"
    SHADING = "Shading"
    SHAMA = "Shama"
    SHAN = "Shan"
    SHONA = "Shona"
    SILESIAN = "Silesian"
    SINDHI = "Sindhi"
    SLOVAK = "Slovak"
    SLOVENE = "Slovene"
    SOGA = "Soga"
    SOGDIAN = "Sogdian"
    SOTHO = "Sotho"
    SPANISH = "Spanish"
    SUDANESE = "Sudanese"
    SUMERIAN = "Sumerian"
    SURAJPURI = "Surajpuri"
    SURIGAONON = "Surigaonon"
    SWATI = "Swati"
    SWAZI = "Swazi"
    SWEDISH = "Swedish"
    TAGALOG = "Tagalog"
    TAMIL = "Tamil"
    TAUSUG = "Tausug"
    TELUGU = "Telugu"
    TETUM = "Tetum"
    THARU = "Tharu"
    TIBETAN = "Tibetan"
    TIGRINYA = "Tigrinya"
    TRIPURI = "Tripuri"
    TSWANA = "Tswana"
    TULU = "Tulu"
    TURKISH = "Turkish"
    TUWALI = "Tuwali"
    UBI = "Ubi"
    UKRAINIAN = "Ukrainian"
    URDU = "Urdu"
    VEPS = "Veps"
    VIETNAMESE = "Vietnamese"
    WAGDI = "Wagdi"
    WAZIRI = "Waziri"
    XHOSA = "Xhosa"
    YIDDISH = "Yiddish"
    YORUBA = "Yoruba"


class ResumeSearchConfigDistanceUnit(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    MI = "mi"
    KM = "km"


class ResumeSkillSourcesItemSection(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    ACHIEVEMENTS = "Achievements"
    ADDITIONAL_INFORMATION = "AdditionalInformation"
    EDUCATION = "Education"
    EXTRACURRICULARS = "Extracurriculars"
    ORGANISATIONS = "Organisations"
    OTHER = "Other"
    PERSONAL_DETAILS = "PersonalDetails"
    PROJECTS = "Projects"
    PUBLICATIONS = "Publications"
    REFEREES = "Referees"
    SKILLS = "Skills"
    SUMMARY = "Summary"
    TRAINING = "Training"
    WORK_EXPERIENCE = "WorkExperience"
    NOT_POPULATED = "NotPopulated"
    HEADER = "Header"
    FOOTER = "Footer"
    SKILLS_INTERESTS_LANGUAGES = "Skills/Interests/Languages"
    TRAINING_CERTIFICATIONS = "Training/Certifications"
    EXTRACURRICULARS_LEADERSHIP = "Extracurriculars/Leadership"


class SearchLocationUnit(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    KM = "km"
    MI = "mi"


class SearchParametersCustomDataFilterType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    EQUALS = "equals"
    RANGE = "range"


class ThemeConfigPaletteMode(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    LIGHT = "light"
    DARK = "dark"


class Version(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    V1 = "v1"
    V2 = "v2"
    V3 = "v3"


class WorkspaceVisibility(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    

    ORGANIZATION = "organization"
    PRIVATE = "private"
}
affinda-python-master\affinda\models _patch.py{
from typing import TYPE_CHECKING

if TYPE_CHECKING:
        from typing import List

__all__ = []  

def patch_sdk():}

affinda-python-master\affinda\operations __init__.py{from ._affinda_api_operations import AffindaAPIOperationsMixin

from ._patch import __all__ as _patch_all
from ._patch import *  from ._patch import patch_sdk as _patch_sdk

__all__ = [
    "AffindaAPIOperationsMixin",
]
__all__.extend([p for p in _patch_all if p not in __all__])
_patch_sdk()}
affinda-python-master\affinda\operations _affinda_api_operations.py{import datetime
from typing import TYPE_CHECKING

from msrest import Serializer

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
        from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union

    T = TypeVar("T")
    ClsType = Optional[
        Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]
    ]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False

def build_get_all_workspaces_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    organization = kwargs.pop('organization')      name = kwargs.pop('name', _params.pop('name', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspaces")

        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if name is not None:
        _params['name'] = _SERIALIZER.query("name", name, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_workspace_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspaces")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_workspace_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspaces/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_workspace_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspaces/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_workspace_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspaces/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_usage_by_workspace_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    start = kwargs.pop('start', _params.pop('start', None))      end = kwargs.pop('end', _params.pop('end', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspaces/{identifier}/usage")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if start is not None:
        _params['start'] = _SERIALIZER.query("start", start, 'str')
    if end is not None:
        _params['end'] = _SERIALIZER.query("end", end, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_all_workspace_memberships_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      workspace = kwargs.pop('workspace', _params.pop('workspace', None))      user = kwargs.pop('user', _params.pop('user', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspace_memberships")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if workspace is not None:
        _params['workspace'] = _SERIALIZER.query("workspace", workspace, 'str')
    if user is not None:
        _params['user'] = _SERIALIZER.query("user", user, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_workspace_membership_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspace_memberships")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_workspace_membership_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspace_memberships/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_workspace_membership_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/workspace_memberships/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_collections_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    workspace = kwargs.pop('workspace')      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections")

        _params['workspace'] = _SERIALIZER.query("workspace", workspace, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_collection_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_collection_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_collection_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_collection_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_data_field_for_collection_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}/create_data_field")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_data_field_for_collection_request(
    identifier,      datapoint_identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}/fields/{datapoint_identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
        "datapoint_identifier": _SERIALIZER.url("datapoint_identifier", datapoint_identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_data_field_for_collection_request(
    identifier,      datapoint_identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}/fields/{datapoint_identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
        "datapoint_identifier": _SERIALIZER.url("datapoint_identifier", datapoint_identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_usage_by_collection_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    start = kwargs.pop('start', _params.pop('start', None))      end = kwargs.pop('end', _params.pop('end', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/collections/{identifier}/usage")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if start is not None:
        _params['start'] = _SERIALIZER.query("start", start, 'str')
    if end is not None:
        _params['end'] = _SERIALIZER.query("end", end, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_all_documents_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      workspace = kwargs.pop('workspace', _params.pop('workspace', None))      collection = kwargs.pop('collection', _params.pop('collection', None))      state = kwargs.pop('state', _params.pop('state', None))      tags = kwargs.pop('tags', _params.pop('tags', None))      created_dt = kwargs.pop('created_dt', _params.pop('created_dt', None))      search = kwargs.pop('search', _params.pop('search', None))      ordering = kwargs.pop('ordering', _params.pop('ordering', None))      include_data = kwargs.pop('include_data', _params.pop('include_data', None))      exclude = kwargs.pop('exclude', _params.pop('exclude', None))      in_review = kwargs.pop('in_review', _params.pop('in_review', None))      failed = kwargs.pop('failed', _params.pop('failed', None))      ready = kwargs.pop('ready', _params.pop('ready', None))      validatable = kwargs.pop('validatable', _params.pop('validatable', None))      has_challenges = kwargs.pop('has_challenges', _params.pop('has_challenges', None))      custom_identifier = kwargs.pop('custom_identifier', _params.pop('custom_identifier', None))      compact = kwargs.pop('compact', _params.pop('compact', None))      count = kwargs.pop('count', _params.pop('count', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if workspace is not None:
        _params['workspace'] = _SERIALIZER.query("workspace", workspace, 'str')
    if collection is not None:
        _params['collection'] = _SERIALIZER.query("collection", collection, 'str')
    if state is not None:
        _params['state'] = _SERIALIZER.query("state", state, 'str')
    if tags is not None:
        _params['tags'] = _SERIALIZER.query("tags", tags, '[int]')
    if created_dt is not None:
        _params['created_dt'] = _SERIALIZER.query("created_dt", created_dt, 'str')
    if search is not None:
        _params['search'] = _SERIALIZER.query("search", search, 'str')
    if ordering is not None:
        _params['ordering'] = _SERIALIZER.query("ordering", ordering, '[str]')
    if include_data is not None:
        _params['include_data'] = _SERIALIZER.query("include_data", include_data, 'bool')
    if exclude is not None:
        _params['exclude'] = _SERIALIZER.query("exclude", exclude, '[str]')
    if in_review is not None:
        _params['in_review'] = _SERIALIZER.query("in_review", in_review, 'bool')
    if failed is not None:
        _params['failed'] = _SERIALIZER.query("failed", failed, 'bool')
    if ready is not None:
        _params['ready'] = _SERIALIZER.query("ready", ready, 'bool')
    if validatable is not None:
        _params['validatable'] = _SERIALIZER.query("validatable", validatable, 'bool')
    if has_challenges is not None:
        _params['has_challenges'] = _SERIALIZER.query("has_challenges", has_challenges, 'bool')
    if custom_identifier is not None:
        _params['custom_identifier'] = _SERIALIZER.query("custom_identifier", custom_identifier, 'str')
    if compact is not None:
        _params['compact'] = _SERIALIZER.query("compact", compact, 'bool')
    if count is not None:
        _params['count'] = _SERIALIZER.query("count", count, 'bool')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_document_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_document_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    format = kwargs.pop('format', _params.pop('format', None))      compact = kwargs.pop('compact', _params.pop('compact', None))      accept = _headers.pop('Accept', "application/json, application/xml")

        _url = kwargs.pop("template_url", "/v3/documents/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if format is not None:
        _params['format'] = _SERIALIZER.query("format", format, 'str')
    if compact is not None:
        _params['compact'] = _SERIALIZER.query("compact", compact, 'bool')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_update_document_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_document_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_document_data_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents/{identifier}/update_data")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_redacted_document_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/pdf, application/json")

        _url = kwargs.pop("template_url", "/v3/documents/{identifier}/redacted")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_add_tag_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents/batch_add_tag")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_remove_tag_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/documents/batch_remove_tag")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_validation_results_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    document = kwargs.pop('document')      offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    _params['document'] = _SERIALIZER.query("document", document, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_validation_result_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_validation_result_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_validation_result_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_validation_result_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_create_validation_results_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results/batch_create")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_delete_validation_results_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validation_results/batch_delete")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_document_splitters_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      organization = kwargs.pop('organization', _params.pop('organization', None))      include_public = kwargs.pop('include_public', _params.pop('include_public', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_splitters")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if include_public is not None:
        _params['include_public'] = _SERIALIZER.query("include_public", include_public, 'bool')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_document_splitter_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_splitters/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_edit_document_pages_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/validate/{identifier}/split")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_extractors_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    organization = kwargs.pop('organization')      include_public_extractors = kwargs.pop('include_public_extractors', _params.pop('include_public_extractors', None))      name = kwargs.pop('name', _params.pop('name', None))      validatable = kwargs.pop('validatable', _params.pop('validatable', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/extractors")

        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if include_public_extractors is not None:
        _params['include_public_extractors'] = _SERIALIZER.query("include_public_extractors", include_public_extractors, 'bool')
    if name is not None:
        _params['name'] = _SERIALIZER.query("name", name, 'str')
    if validatable is not None:
        _params['validatable'] = _SERIALIZER.query("validatable", validatable, 'bool')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_extractor_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/extractors")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_extractor_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/extractors/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_extractor_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/extractors/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_extractor_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/extractors/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_data_points_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      organization = kwargs.pop('organization', _params.pop('organization', None))      include_public = kwargs.pop('include_public', _params.pop('include_public', None))      extractor = kwargs.pop('extractor', _params.pop('extractor', None))      slug = kwargs.pop('slug', _params.pop('slug', None))      description = kwargs.pop('description', _params.pop('description', None))      annotation_content_type = kwargs.pop('annotation_content_type', _params.pop('annotation_content_type', None))      identifier = kwargs.pop('identifier', _params.pop('identifier', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_points")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if include_public is not None:
        _params['include_public'] = _SERIALIZER.query("include_public", include_public, 'bool')
    if extractor is not None:
        _params['extractor'] = _SERIALIZER.query("extractor", extractor, 'str')
    if slug is not None:
        _params['slug'] = _SERIALIZER.query("slug", slug, 'str')
    if description is not None:
        _params['description'] = _SERIALIZER.query("description", description, 'str')
    if annotation_content_type is not None:
        _params['annotation_content_type'] = _SERIALIZER.query("annotation_content_type", annotation_content_type, 'str')
    if identifier is not None:
        _params['identifier'] = _SERIALIZER.query("identifier", identifier, '[str]')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_data_point_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_points")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_data_point_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_points/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_data_point_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_points/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_data_point_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_points/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_data_point_choices_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    data_point = kwargs.pop('data_point')      collection = kwargs.pop('collection')      offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      search = kwargs.pop('search', _params.pop('search', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_point_choices")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    _params['data_point'] = _SERIALIZER.query("data_point", data_point, 'str')
    _params['collection'] = _SERIALIZER.query("collection", collection, 'str')
    if search is not None:
        _params['search'] = _SERIALIZER.query("search", search, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_data_point_choice_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_point_choices")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_data_point_choice_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_point_choices/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_data_point_choice_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_point_choices/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_data_point_choice_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_point_choices/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_replace_data_point_choices_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/data_point_choices/replace")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_annotations_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    document = kwargs.pop('document')      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations")

        _params['document'] = _SERIALIZER.query("document", document, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_annotation_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_annotation_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_annotation_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_annotation_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_create_annotations_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations/batch_create")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_update_annotations_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations/batch_update")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_batch_delete_annotations_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/annotations/batch_delete")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_mapping_data_source_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_list_mapping_data_sources_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      name = kwargs.pop('name', _params.pop('name', None))      organization = kwargs.pop('organization', _params.pop('organization', None))      workspace = kwargs.pop('workspace', _params.pop('workspace', None))      identifier = kwargs.pop('identifier', _params.pop('identifier', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if name is not None:
        _params['name'] = _SERIALIZER.query("name", name, 'str')
    if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if workspace is not None:
        _params['workspace'] = _SERIALIZER.query("workspace", workspace, 'str')
    if identifier is not None:
        _params['identifier'] = _SERIALIZER.query("identifier", identifier, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_mapping_data_source_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_mapping_data_source_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_list_mapping_data_source_values_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    limit = kwargs.pop('limit', _params.pop('limit', None))      offset = kwargs.pop('offset', _params.pop('offset', None))      search = kwargs.pop('search', _params.pop('search', None))      annotation = kwargs.pop('annotation', _params.pop('annotation', None))      document = kwargs.pop('document', _params.pop('document', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}/values")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if search is not None:
        _params['search'] = _SERIALIZER.query("search", search, 'str')
    if annotation is not None:
        _params['annotation'] = _SERIALIZER.query("annotation", annotation, 'int')
    if document is not None:
        _params['document'] = _SERIALIZER.query("document", document, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_replace_mapping_data_source_values_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}/values")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_add_mapping_data_source_value_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}/values")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_mapping_data_source_value_request(
    identifier,      value,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}/values/{value}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
        "value": _SERIALIZER.url("value", value, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_mapping_data_source_value_request(
    identifier,      value,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}/values/{value}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
        "value": _SERIALIZER.url("value", value, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_mapping_data_source_value_request(
    identifier,      value,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mapping_data_sources/{identifier}/values/{value}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
        "value": _SERIALIZER.url("value", value, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_mapping_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mappings")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_list_mappings_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    mapping_data_source = kwargs.pop('mapping_data_source')      offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mappings")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    _params['mapping_data_source'] = _SERIALIZER.query("mapping_data_source", mapping_data_source, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_mapping_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mappings/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_mapping_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mappings/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_mapping_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/mappings/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_tags_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    limit = kwargs.pop('limit', _params.pop('limit', None))      offset = kwargs.pop('offset', _params.pop('offset', None))      workspace = kwargs.pop('workspace', _params.pop('workspace', None))      name = kwargs.pop('name', _params.pop('name', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/tags")

        if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if workspace is not None:
        _params['workspace'] = _SERIALIZER.query("workspace", workspace, 'str')
    if name is not None:
        _params['name'] = _SERIALIZER.query("name", name, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_tag_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/tags")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_tag_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/tags/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_tag_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/tags/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_tag_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/tags/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_document_types_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    organization = kwargs.pop('organization', _params.pop('organization', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_types")

        if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_document_type_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_types")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_document_type_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_types/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_document_type_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_types/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_document_type_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/document_types/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_organizations_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organizations")

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_organization_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organizations")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_organization_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organizations/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_organization_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organizations/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_organization_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organizations/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_organization_memberships_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      organization = kwargs.pop('organization', _params.pop('organization', None))      role = kwargs.pop('role', _params.pop('role', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organization_memberships")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if role is not None:
        _params['role'] = _SERIALIZER.query("role", role, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_organization_membership_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organization_memberships/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_organization_membership_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organization_memberships/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_organization_membership_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/organization_memberships/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_invitations_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      organization = kwargs.pop('organization', _params.pop('organization', None))      status = kwargs.pop('status', _params.pop('status', None))      role = kwargs.pop('role', _params.pop('role', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')
    if status is not None:
        _params['status'] = _SERIALIZER.query("status", status, 'str')
    if role is not None:
        _params['role'] = _SERIALIZER.query("role", role, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_invitation_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_invitation_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_invitation_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_invitation_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_invitation_by_token_request(
    token,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations/token/{token}")
    path_format_arguments = {
        "token": _SERIALIZER.url("token", token, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_respond_to_invitation_request(
    token,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/invitations/token/{token}")
    path_format_arguments = {
        "token": _SERIALIZER.url("token", token, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_api_users_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    organization = kwargs.pop('organization', _params.pop('organization', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/api_users")

        if organization is not None:
        _params['organization'] = _SERIALIZER.query("organization", organization, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_api_user_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/api_users")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_api_user_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/api_users/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_api_user_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/api_users/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_api_user_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/api_users/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_regenerate_api_key_for_api_user_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/api_users/{id}/regenerate_api_key")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int', minimum=1),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_resthook_subscriptions_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resthook_subscriptions")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_resthook_subscription_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resthook_subscriptions")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_resthook_subscription_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resthook_subscriptions/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_resthook_subscription_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resthook_subscriptions/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_resthook_subscription_request(
    id,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resthook_subscriptions/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'int'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_activate_resthook_subscription_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    x_hook_secret = kwargs.pop('x_hook_secret')      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resthook_subscriptions/activate")

        _headers['X-Hook-Secret'] = _SERIALIZER.header("x_hook_secret", x_hook_secret, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_list_occupation_groups_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/occupation_groups")

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_resume_search_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=50, minimum=1)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_resume_search_detail_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/details/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_resume_search_config_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/config")

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_resume_search_config_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/config")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_resume_search_embed_url_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/embed")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_resume_search_match_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    resume = kwargs.pop('resume')      job_description = kwargs.pop('job_description')      index = kwargs.pop('index', _params.pop('index', None))      search_expression = kwargs.pop('search_expression', _params.pop('search_expression', None))      job_titles_weight = kwargs.pop('job_titles_weight', _params.pop('job_titles_weight', None))      years_experience_weight = kwargs.pop('years_experience_weight', _params.pop('years_experience_weight', None))      locations_weight = kwargs.pop('locations_weight', _params.pop('locations_weight', None))      languages_weight = kwargs.pop('languages_weight', _params.pop('languages_weight', None))      skills_weight = kwargs.pop('skills_weight', _params.pop('skills_weight', None))      education_weight = kwargs.pop('education_weight', _params.pop('education_weight', None))      search_expression_weight = kwargs.pop('search_expression_weight', _params.pop('search_expression_weight', None))      soc_codes_weight = kwargs.pop('soc_codes_weight', _params.pop('soc_codes_weight', None))      management_level_weight = kwargs.pop('management_level_weight', _params.pop('management_level_weight', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/match")

        _params['resume'] = _SERIALIZER.query("resume", resume, 'str')
    _params['job_description'] = _SERIALIZER.query("job_description", job_description, 'str')
    if index is not None:
        _params['index'] = _SERIALIZER.query("index", index, 'str')
    if search_expression is not None:
        _params['search_expression'] = _SERIALIZER.query("search_expression", search_expression, 'str')
    if job_titles_weight is not None:
        _params['job_titles_weight'] = _SERIALIZER.query("job_titles_weight", job_titles_weight, 'float', maximum=1, minimum=0)
    if years_experience_weight is not None:
        _params['years_experience_weight'] = _SERIALIZER.query("years_experience_weight", years_experience_weight, 'float', maximum=1, minimum=0)
    if locations_weight is not None:
        _params['locations_weight'] = _SERIALIZER.query("locations_weight", locations_weight, 'float', maximum=1, minimum=0)
    if languages_weight is not None:
        _params['languages_weight'] = _SERIALIZER.query("languages_weight", languages_weight, 'float', maximum=1, minimum=0)
    if skills_weight is not None:
        _params['skills_weight'] = _SERIALIZER.query("skills_weight", skills_weight, 'float', maximum=1, minimum=0)
    if education_weight is not None:
        _params['education_weight'] = _SERIALIZER.query("education_weight", education_weight, 'float', maximum=1, minimum=0)
    if search_expression_weight is not None:
        _params['search_expression_weight'] = _SERIALIZER.query("search_expression_weight", search_expression_weight, 'float', maximum=1, minimum=0)
    if soc_codes_weight is not None:
        _params['soc_codes_weight'] = _SERIALIZER.query("soc_codes_weight", soc_codes_weight, 'float', maximum=1, minimum=0)
    if management_level_weight is not None:
        _params['management_level_weight'] = _SERIALIZER.query("management_level_weight", management_level_weight, 'float', maximum=1, minimum=0)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_resume_search_suggestion_job_title_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    job_titles = kwargs.pop('job_titles')      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/suggestion_job_title")

        _params['job_titles'] = [_SERIALIZER.query("job_titles", q, 'str') if q is not None else '' for q in job_titles]

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_resume_search_suggestion_skill_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    skills = kwargs.pop('skills')      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/resume_search/suggestion_skill")

        _params['skills'] = [_SERIALIZER.query("skills", q, 'str') if q is not None else '' for q in skills]

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_job_description_search_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/job_description_search")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_job_description_search_detail_request(
    identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/job_description_search/details/{identifier}")
    path_format_arguments = {
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_job_description_search_config_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/job_description_search/config")

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_job_description_search_config_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/job_description_search/config")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_create_job_description_search_embed_url_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/job_description_search/embed")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_indexes_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      document_type = kwargs.pop('document_type', _params.pop('document_type', None))      name = kwargs.pop('name', _params.pop('name', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index")

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)
    if document_type is not None:
        _params['document_type'] = _SERIALIZER.query("document_type", document_type, 'str')
    if name is not None:
        _params['name'] = _SERIALIZER.query("name", name, 'str')

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_index_request(
    **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index")

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_update_index_request(
    name,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index/{name}")
    path_format_arguments = {
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_index_request(
    name,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index/{name}")
    path_format_arguments = {
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_get_all_index_documents_request(
    name,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    offset = kwargs.pop('offset', _params.pop('offset', None))      limit = kwargs.pop('limit', _params.pop('limit', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index/{name}/documents")
    path_format_arguments = {
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if offset is not None:
        _params['offset'] = _SERIALIZER.query("offset", offset, 'int', minimum=0)
    if limit is not None:
        _params['limit'] = _SERIALIZER.query("limit", limit, 'int', maximum=100, minimum=1)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_create_index_document_request(
    name,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))      accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index/{name}/documents")
    path_format_arguments = {
        "name": _SERIALIZER.url("name", name, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_delete_index_document_request(
    name,      identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index/{name}/documents/{identifier}")
    path_format_arguments = {
        "name": _SERIALIZER.url("name", name, 'str'),
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        headers=_headers,
        **kwargs
    )


def build_re_index_document_request(
    name,      identifier,      **kwargs  ):
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop('Accept', "application/json")

        _url = kwargs.pop("template_url", "/v3/index/{name}/documents/{identifier}/re_index")
    path_format_arguments = {
        "name": _SERIALIZER.url("name", name, 'str'),
        "identifier": _SERIALIZER.url("identifier", identifier, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

        _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        headers=_headers,
        **kwargs
    )

class AffindaAPIOperationsMixin(object):      def get_all_workspaces(
        self,
        organization,          name=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_workspaces_request(
            organization=organization,
            name=name,
            template_url=self.get_all_workspaces.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Workspace]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_workspaces.metadata = {"url": "/v3/workspaces"}  
    def create_workspace(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "WorkspaceCreate")

        request = build_create_workspace_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_workspace.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Workspace", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_workspace.metadata = {"url": "/v3/workspaces"}  
    def get_workspace(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_workspace_request(
            identifier=identifier,
            template_url=self.get_workspace.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Workspace", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_workspace.metadata = {"url": "/v3/workspaces/{identifier}"}  
    def update_workspace(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "WorkspaceUpdate")

        request = build_update_workspace_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_workspace.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Workspace", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_workspace.metadata = {"url": "/v3/workspaces/{identifier}"}  
    def delete_workspace(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_workspace_request(
            identifier=identifier,
            template_url=self.delete_workspace.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_workspace.metadata = {"url": "/v3/workspaces/{identifier}"}  
    def get_usage_by_workspace(
        self,
        identifier,          start=None,          end=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_usage_by_workspace_request(
            identifier=identifier,
            start=start,
            end=end,
            template_url=self.get_usage_by_workspace.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[UsageByWorkspace]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_usage_by_workspace.metadata = {"url": "/v3/workspaces/{identifier}/usage"}  
    def get_all_workspace_memberships(
        self,
        offset=None,          limit=None,          workspace=None,          user=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_workspace_memberships_request(
            offset=offset,
            limit=limit,
            workspace=workspace,
            user=user,
            template_url=self.get_all_workspace_memberships.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_workspace_memberships.metadata = {"url": "/v3/workspace_memberships"}  
    def create_workspace_membership(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "WorkspaceMembershipCreate")

        request = build_create_workspace_membership_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_workspace_membership.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("WorkspaceMembership", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_workspace_membership.metadata = {"url": "/v3/workspace_memberships"}  
    def get_workspace_membership(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_workspace_membership_request(
            identifier=identifier,
            template_url=self.get_workspace_membership.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("WorkspaceMembership", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_workspace_membership.metadata = {"url": "/v3/workspace_memberships/{identifier}"}  
    def delete_workspace_membership(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_workspace_membership_request(
            identifier=identifier,
            template_url=self.delete_workspace_membership.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_workspace_membership.metadata = {"url": "/v3/workspace_memberships/{identifier}"}  
    def get_all_collections(
        self,
        workspace,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_collections_request(
            workspace=workspace,
            template_url=self.get_all_collections.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Collection]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_collections.metadata = {"url": "/v3/collections"}  
    def create_collection(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "CollectionCreate")

        request = build_create_collection_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_collection.metadata = {"url": "/v3/collections"}  
    def get_collection(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_collection_request(
            identifier=identifier,
            template_url=self.get_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_collection.metadata = {"url": "/v3/collections/{identifier}"}  
    def update_collection(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "CollectionUpdate")

        request = build_update_collection_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_collection.metadata = {"url": "/v3/collections/{identifier}"}  
    def delete_collection(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_collection_request(
            identifier=identifier,
            template_url=self.delete_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_collection.metadata = {"url": "/v3/collections/{identifier}"}  
    def create_data_field_for_collection(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DataFieldCreate")

        request = build_create_data_field_for_collection_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.create_data_field_for_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataField", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_data_field_for_collection.metadata = {
        "url": "/v3/collections/{identifier}/create_data_field"
    }  
    def get_data_field_for_collection(
        self,
        identifier,          datapoint_identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_data_field_for_collection_request(
            identifier=identifier,
            datapoint_identifier=datapoint_identifier,
            template_url=self.get_data_field_for_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("CollectionField", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_field_for_collection.metadata = {
        "url": "/v3/collections/{identifier}/fields/{datapoint_identifier}"
    }  
    def update_data_field_for_collection(
        self,
        identifier,          datapoint_identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "CollectionField")

        request = build_update_data_field_for_collection_request(
            identifier=identifier,
            datapoint_identifier=datapoint_identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_data_field_for_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("CollectionField", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_data_field_for_collection.metadata = {
        "url": "/v3/collections/{identifier}/fields/{datapoint_identifier}"
    }  
    def get_usage_by_collection(
        self,
        identifier,          start=None,          end=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_usage_by_collection_request(
            identifier=identifier,
            start=start,
            end=end,
            template_url=self.get_usage_by_collection.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[UsageByCollection]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_usage_by_collection.metadata = {"url": "/v3/collections/{identifier}/usage"}  
    def get_all_documents(
        self,
        offset=None,          limit=None,          workspace=None,          collection=None,          state=None,          tags=None,          created_dt=None,          search=None,          ordering=None,          include_data=None,          exclude=None,          in_review=None,          failed=None,          ready=None,          validatable=None,          has_challenges=None,          custom_identifier=None,          compact=None,          count=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            403: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_documents_request(
            offset=offset,
            limit=limit,
            workspace=workspace,
            collection=collection,
            state=state,
            tags=tags,
            created_dt=created_dt,
            search=search,
            ordering=ordering,
            include_data=include_data,
            exclude=exclude,
            in_review=in_review,
            failed=failed,
            ready=ready,
            validatable=validatable,
            has_challenges=has_challenges,
            custom_identifier=custom_identifier,
            compact=compact,
            count=count,
            template_url=self.get_all_documents.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema", pipeline_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_documents.metadata = {"url": "/v3/documents"}  
    def create_document(
        self,
        file=None,          url=None,          data=None,          collection=None,          document_type=None,          workspace=None,          wait=True,          identifier=None,          custom_identifier=None,          file_name=None,          expiry_time=None,          language=None,          reject_duplicates=None,          region_bias=None,          low_priority=None,          compact=None,          delete_after_parse=None,          enable_validation_tool=None,          use_ocr=None,          warning_messages=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            403: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))          cls = kwargs.pop("cls", None)  
                _files = {
            "file": file,
            "url": url,
            "data": data,
            "collection": collection,
            "documentType": document_type,
            "workspace": workspace,
            "wait": wait,
            "identifier": identifier,
            "customIdentifier": custom_identifier,
            "fileName": file_name,
            "expiryTime": expiry_time,
            "language": language,
            "rejectDuplicates": reject_duplicates,
            "regionBias": region_bias,
            "lowPriority": low_priority,
            "compact": compact,
            "deleteAfterParse": delete_after_parse,
            "enableValidationTool": enable_validation_tool,
            "useOcr": use_ocr,
            "warningMessages": warning_messages,
        }

        request = build_create_document_request(
            content_type=content_type,
            files=_files,
            template_url=self.create_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request, _files)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if response.status_code == 200:
            deserialized = self._deserialize("Document", pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize("Document", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_document.metadata = {"url": "/v3/documents"}  
    def get_document(
        self,
        identifier,          format=None,          compact=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_document_request(
            identifier=identifier,
            format=format,
            compact=compact,
            template_url=self.get_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if response.status_code == 200:
            deserialized = self._deserialize("Document", pipeline_response)

        if response.status_code == 200:
            deserialized = self._deserialize("Document", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_document.metadata = {"url": "/v3/documents/{identifier}"}  
    def update_document(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DocumentUpdate")

        request = build_update_document_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Document", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_document.metadata = {"url": "/v3/documents/{identifier}"}  
    def delete_document(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_document_request(
            identifier=identifier,
            template_url=self.delete_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_document.metadata = {"url": "/v3/documents/{identifier}"}  
    def update_document_data(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "object")

        request = build_update_document_data_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_document_data.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Document", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_document_data.metadata = {"url": "/v3/documents/{identifier}/update_data"}  
    def get_redacted_document(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_redacted_document_request(
            identifier=identifier,
            template_url=self.get_redacted_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=True, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_redacted_document.metadata = {"url": "/v3/documents/{identifier}/redacted"}  
    def batch_add_tag(          self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "BatchAddTagRequest")

        request = build_batch_add_tag_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_add_tag.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    batch_add_tag.metadata = {"url": "/v3/documents/batch_add_tag"}  
    def batch_remove_tag(          self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "BatchRemoveTagRequest")

        request = build_batch_remove_tag_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_remove_tag.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    batch_remove_tag.metadata = {"url": "/v3/documents/batch_remove_tag"}  
    def get_all_validation_results(
        self,
        document,          offset=None,          limit=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_validation_results_request(
            document=document,
            offset=offset,
            limit=limit,
            template_url=self.get_all_validation_results.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[ValidationResult]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_validation_results.metadata = {"url": "/v3/validation_results"}  
    def create_validation_result(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ValidationResultCreate")

        request = build_create_validation_result_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_validation_result.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ValidationResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_validation_result.metadata = {"url": "/v3/validation_results"}  
    def get_validation_result(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_validation_result_request(
            id=id,
            template_url=self.get_validation_result.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ValidationResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_validation_result.metadata = {"url": "/v3/validation_results/{id}"}  
    def update_validation_result(
        self,
        id,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ValidationResultUpdate")

        request = build_update_validation_result_request(
            id=id,
            content_type=content_type,
            json=_json,
            template_url=self.update_validation_result.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ValidationResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_validation_result.metadata = {"url": "/v3/validation_results/{id}"}  
    def delete_validation_result(          self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_validation_result_request(
            id=id,
            template_url=self.delete_validation_result.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_validation_result.metadata = {"url": "/v3/validation_results/{id}"}  
    def batch_create_validation_results(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "[ValidationResultCreate]")

        request = build_batch_create_validation_results_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_create_validation_results.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[ValidationResult]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    batch_create_validation_results.metadata = {"url": "/v3/validation_results/batch_create"}  
    def batch_delete_validation_results(          self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "BatchDeleteValidationResultsRequest")

        request = build_batch_delete_validation_results_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_delete_validation_results.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    batch_delete_validation_results.metadata = {"url": "/v3/validation_results/batch_delete"}  
    def get_all_document_splitters(
        self,
        offset=None,          limit=None,          organization=None,          include_public=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_document_splitters_request(
            offset=offset,
            limit=limit,
            organization=organization,
            include_public=include_public,
            template_url=self.get_all_document_splitters.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[DocumentSplitter]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_document_splitters.metadata = {"url": "/v3/document_splitters"}  
    def get_document_splitter(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_document_splitter_request(
            identifier=identifier,
            template_url=self.get_document_splitter.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DocumentSplitter", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_document_splitter.metadata = {"url": "/v3/document_splitters/{identifier}"}  
    def edit_document_pages(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DocumentEditRequest")

        request = build_edit_document_pages_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.edit_document_pages.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Meta]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    edit_document_pages.metadata = {"url": "/v3/validate/{identifier}/split"}  
    def get_all_extractors(
        self,
        organization,          include_public_extractors=None,          name=None,          validatable=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_extractors_request(
            organization=organization,
            include_public_extractors=include_public_extractors,
            name=name,
            validatable=validatable,
            template_url=self.get_all_extractors.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Extractor]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_extractors.metadata = {"url": "/v3/extractors"}  
    def create_extractor(
        self,
        body=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        if body is not None:
            _json = self._serialize.body(body, "ExtractorCreate")
        else:
            _json = None

        request = build_create_extractor_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_extractor.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Extractor", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_extractor.metadata = {"url": "/v3/extractors"}  
    def get_extractor(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_extractor_request(
            identifier=identifier,
            template_url=self.get_extractor.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Extractor", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_extractor.metadata = {"url": "/v3/extractors/{identifier}"}  
    def update_extractor(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ExtractorUpdate")

        request = build_update_extractor_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_extractor.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Extractor", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_extractor.metadata = {"url": "/v3/extractors/{identifier}"}  
    def delete_extractor(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_extractor_request(
            identifier=identifier,
            template_url=self.delete_extractor.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_extractor.metadata = {"url": "/v3/extractors/{identifier}"}  
    def get_all_data_points(
        self,
        offset=None,          limit=None,          organization=None,          include_public=None,          extractor=None,          slug=None,          description=None,          annotation_content_type=None,          identifier=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_data_points_request(
            offset=offset,
            limit=limit,
            organization=organization,
            include_public=include_public,
            extractor=extractor,
            slug=slug,
            description=description,
            annotation_content_type=annotation_content_type,
            identifier=identifier,
            template_url=self.get_all_data_points.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[DataPoint]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_data_points.metadata = {"url": "/v3/data_points"}  
    def create_data_point(
        self,
        body=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        if body is not None:
            _json = self._serialize.body(body, "DataPointCreate")
        else:
            _json = None

        request = build_create_data_point_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_data_point.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPoint", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_data_point.metadata = {"url": "/v3/data_points"}  
    def get_data_point(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_data_point_request(
            identifier=identifier,
            template_url=self.get_data_point.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPoint", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_point.metadata = {"url": "/v3/data_points/{identifier}"}  
    def update_data_point(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DataPointUpdate")

        request = build_update_data_point_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_data_point.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPoint", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_data_point.metadata = {"url": "/v3/data_points/{identifier}"}  
    def delete_data_point(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_data_point_request(
            identifier=identifier,
            template_url=self.delete_data_point.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_data_point.metadata = {"url": "/v3/data_points/{identifier}"}  
    def get_data_point_choices(
        self,
        data_point,          collection,          offset=None,          limit=None,          search=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_data_point_choices_request(
            data_point=data_point,
            collection=collection,
            offset=offset,
            limit=limit,
            search=search,
            template_url=self.get_data_point_choices.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_point_choices.metadata = {"url": "/v3/data_point_choices"}  
    def create_data_point_choice(
        self,
        body=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        if body is not None:
            _json = self._serialize.body(body, "DataPointChoiceCreate")
        else:
            _json = None

        request = build_create_data_point_choice_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_data_point_choice.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPointChoice", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_data_point_choice.metadata = {"url": "/v3/data_point_choices"}  
    def get_data_point_choice(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_data_point_choice_request(
            id=id,
            template_url=self.get_data_point_choice.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPointChoice", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_point_choice.metadata = {"url": "/v3/data_point_choices/{id}"}  
    def update_data_point_choice(
        self,
        id,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DataPointChoiceUpdate")

        request = build_update_data_point_choice_request(
            id=id,
            content_type=content_type,
            json=_json,
            template_url=self.update_data_point_choice.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPointChoice", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_data_point_choice.metadata = {"url": "/v3/data_point_choices/{id}"}  
    def delete_data_point_choice(          self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_data_point_choice_request(
            id=id,
            template_url=self.delete_data_point_choice.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_data_point_choice.metadata = {"url": "/v3/data_point_choices/{id}"}  
    def replace_data_point_choices(
        self,
        body=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        if body is not None:
            _json = self._serialize.body(body, "DataPointChoiceReplaceRequest")
        else:
            _json = None

        request = build_replace_data_point_choices_request(
            content_type=content_type,
            json=_json,
            template_url=self.replace_data_point_choices.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DataPointChoiceReplaceResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    replace_data_point_choices.metadata = {"url": "/v3/data_point_choices/replace"}  
    def get_all_annotations(
        self,
        document,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_annotations_request(
            document=document,
            template_url=self.get_all_annotations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_annotations.metadata = {"url": "/v3/annotations"}  
    def create_annotation(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "AnnotationCreate")

        request = build_create_annotation_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_annotation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("AnnotationWithValidationResults", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_annotation.metadata = {"url": "/v3/annotations"}  
    def get_annotation(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_annotation_request(
            id=id,
            template_url=self.get_annotation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Annotation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_annotation.metadata = {"url": "/v3/annotations/{id}"}  
    def update_annotation(
        self,
        id,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "AnnotationUpdate")

        request = build_update_annotation_request(
            id=id,
            content_type=content_type,
            json=_json,
            template_url=self.update_annotation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Annotation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_annotation.metadata = {"url": "/v3/annotations/{id}"}  
    def delete_annotation(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_annotation_request(
            id=id,
            template_url=self.delete_annotation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("AnotationDelete", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_annotation.metadata = {"url": "/v3/annotations/{id}"}  
    def batch_create_annotations(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "[AnnotationCreate]")

        request = build_batch_create_annotations_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_create_annotations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Annotation]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    batch_create_annotations.metadata = {"url": "/v3/annotations/batch_create"}  
    def batch_update_annotations(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "[AnnotationBatchUpdate]")

        request = build_batch_update_annotations_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_update_annotations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Annotation]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    batch_update_annotations.metadata = {"url": "/v3/annotations/batch_update"}  
    def batch_delete_annotations(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "[int]")

        request = build_batch_delete_annotations_request(
            content_type=content_type,
            json=_json,
            template_url=self.batch_delete_annotations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("BatchDeleteAnnotationsResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    batch_delete_annotations.metadata = {"url": "/v3/annotations/batch_delete"}  
    def create_mapping_data_source(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "MappingDataSourceCreate")

        request = build_create_mapping_data_source_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_mapping_data_source.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("MappingDataSource", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_mapping_data_source.metadata = {"url": "/v3/mapping_data_sources"}  
    def list_mapping_data_sources(
        self,
        offset=None,          limit=None,          name=None,          organization=None,          workspace=None,          identifier=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_list_mapping_data_sources_request(
            offset=offset,
            limit=limit,
            name=name,
            organization=organization,
            workspace=workspace,
            identifier=identifier,
            template_url=self.list_mapping_data_sources.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_mapping_data_sources.metadata = {"url": "/v3/mapping_data_sources"}  
    def get_mapping_data_source(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_mapping_data_source_request(
            identifier=identifier,
            template_url=self.get_mapping_data_source.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("MappingDataSource", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_mapping_data_source.metadata = {"url": "/v3/mapping_data_sources/{identifier}"}  
    def delete_mapping_data_source(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_mapping_data_source_request(
            identifier=identifier,
            template_url=self.delete_mapping_data_source.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mapping_data_source.metadata = {"url": "/v3/mapping_data_sources/{identifier}"}  
    def list_mapping_data_source_values(
        self,
        identifier,          limit=None,          offset=None,          search=None,          annotation=None,          document=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_list_mapping_data_source_values_request(
            identifier=identifier,
            limit=limit,
            offset=offset,
            search=search,
            annotation=annotation,
            document=document,
            template_url=self.list_mapping_data_source_values.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_mapping_data_source_values.metadata = {
        "url": "/v3/mapping_data_sources/{identifier}/values"
    }  
    def replace_mapping_data_source_values(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "[object]")

        request = build_replace_mapping_data_source_values_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.replace_mapping_data_source_values.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[object]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    replace_mapping_data_source_values.metadata = {
        "url": "/v3/mapping_data_sources/{identifier}/values"
    }  
    def add_mapping_data_source_value(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "object")

        request = build_add_mapping_data_source_value_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.add_mapping_data_source_value.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    add_mapping_data_source_value.metadata = {
        "url": "/v3/mapping_data_sources/{identifier}/values"
    }  
    def get_mapping_data_source_value(
        self,
        identifier,          value,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_mapping_data_source_value_request(
            identifier=identifier,
            value=value,
            template_url=self.get_mapping_data_source_value.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_mapping_data_source_value.metadata = {
        "url": "/v3/mapping_data_sources/{identifier}/values/{value}"
    }  
    def update_mapping_data_source_value(
        self,
        identifier,          value,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "object")

        request = build_update_mapping_data_source_value_request(
            identifier=identifier,
            value=value,
            content_type=content_type,
            json=_json,
            template_url=self.update_mapping_data_source_value.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_mapping_data_source_value.metadata = {
        "url": "/v3/mapping_data_sources/{identifier}/values/{value}"
    }  
    def delete_mapping_data_source_value(          self,
        identifier,          value,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_mapping_data_source_value_request(
            identifier=identifier,
            value=value,
            template_url=self.delete_mapping_data_source_value.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mapping_data_source_value.metadata = {
        "url": "/v3/mapping_data_sources/{identifier}/values/{value}"
    }  
    def create_mapping(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "MappingCreate")

        request = build_create_mapping_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_mapping.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Mapping", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_mapping.metadata = {"url": "/v3/mappings"}  
    def list_mappings(
        self,
        mapping_data_source,          offset=None,          limit=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_list_mappings_request(
            mapping_data_source=mapping_data_source,
            offset=offset,
            limit=limit,
            template_url=self.list_mappings.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema", pipeline_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_mappings.metadata = {"url": "/v3/mappings"}  
    def get_mapping(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_mapping_request(
            identifier=identifier,
            template_url=self.get_mapping.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Mapping", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_mapping.metadata = {"url": "/v3/mappings/{identifier}"}  
    def delete_mapping(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_mapping_request(
            identifier=identifier,
            template_url=self.delete_mapping.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mapping.metadata = {"url": "/v3/mappings/{identifier}"}  
    def update_mapping(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "MappingUpdate")

        request = build_update_mapping_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_mapping.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Mapping", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_mapping.metadata = {"url": "/v3/mappings/{identifier}"}  
    def get_all_tags(
        self,
        limit=None,          offset=None,          workspace=None,          name=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_tags_request(
            limit=limit,
            offset=offset,
            workspace=workspace,
            name=name,
            template_url=self.get_all_tags.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Tag]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_tags.metadata = {"url": "/v3/tags"}  
    def create_tag(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "TagCreate")

        request = build_create_tag_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_tag.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Tag", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_tag.metadata = {"url": "/v3/tags"}  
    def get_tag(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_tag_request(
            id=id,
            template_url=self.get_tag.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Tag", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_tag.metadata = {"url": "/v3/tags/{id}"}  
    def update_tag(
        self,
        id,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "TagUpdate")

        request = build_update_tag_request(
            id=id,
            content_type=content_type,
            json=_json,
            template_url=self.update_tag.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Tag", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_tag.metadata = {"url": "/v3/tags/{id}"}  
    def delete_tag(          self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_tag_request(
            id=id,
            template_url=self.delete_tag.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_tag.metadata = {"url": "/v3/tags/{id}"}  
    def get_document_types(
        self,
        organization=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_document_types_request(
            organization=organization,
            template_url=self.get_document_types.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[DocumentType]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_document_types.metadata = {"url": "/v3/document_types"}  
    def create_document_type(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DocumentTypeCreate")

        request = build_create_document_type_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_document_type.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize("DocumentType", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_document_type.metadata = {"url": "/v3/document_types"}  
    def get_document_type(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_document_type_request(
            identifier=identifier,
            template_url=self.get_document_type.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("DocumentType", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_document_type.metadata = {"url": "/v3/document_types/{identifier}"}  
    def update_document_type(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "DocumentTypeUpdate")

        request = build_update_document_type_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_document_type.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("DocumentType", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_document_type.metadata = {"url": "/v3/document_types/{identifier}"}  
    def delete_document_type(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_document_type_request(
            identifier=identifier,
            template_url=self.delete_document_type.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_document_type.metadata = {"url": "/v3/document_types/{identifier}"}  
    def get_all_organizations(
        self,
        **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_organizations_request(
            template_url=self.get_all_organizations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[Organization]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_organizations.metadata = {"url": "/v3/organizations"}  
    def create_organization(
        self,
        name,          avatar=None,          resthook_signature_key=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))          cls = kwargs.pop("cls", None)  
                _files = {
            "name": name,
            "avatar": avatar,
            "resthookSignatureKey": resthook_signature_key,
        }

        request = build_create_organization_request(
            content_type=content_type,
            files=_files,
            template_url=self.create_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request, _files)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization.metadata = {"url": "/v3/organizations"}  
    def get_organization(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_organization_request(
            identifier=identifier,
            template_url=self.get_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization.metadata = {"url": "/v3/organizations/{identifier}"}  
    def update_organization(
        self,
        identifier,          name=None,          avatar=None,          resthook_signature_key=None,          validation_tool_config=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))          cls = kwargs.pop("cls", None)  
                _files = {
            "name": name,
            "avatar": avatar,
            "resthookSignatureKey": resthook_signature_key,
            "validationToolConfig": validation_tool_config,
        }

        request = build_update_organization_request(
            identifier=identifier,
            content_type=content_type,
            files=_files,
            template_url=self.update_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request, _files)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization.metadata = {"url": "/v3/organizations/{identifier}"}  
    def delete_organization(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_organization_request(
            identifier=identifier,
            template_url=self.delete_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_organization.metadata = {"url": "/v3/organizations/{identifier}"}  
    def get_all_organization_memberships(
        self,
        offset=None,          limit=None,          organization=None,          role=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_organization_memberships_request(
            offset=offset,
            limit=limit,
            organization=organization,
            role=role,
            template_url=self.get_all_organization_memberships.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_organization_memberships.metadata = {"url": "/v3/organization_memberships"}  
    def get_organization_membership(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_organization_membership_request(
            identifier=identifier,
            template_url=self.get_organization_membership.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("OrganizationMembership", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_membership.metadata = {"url": "/v3/organization_memberships/{identifier}"}  
    def update_organization_membership(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "OrganizationMembershipUpdate")

        request = build_update_organization_membership_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_organization_membership.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("OrganizationMembership", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization_membership.metadata = {"url": "/v3/organization_memberships/{identifier}"}  
    def delete_organization_membership(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_organization_membership_request(
            identifier=identifier,
            template_url=self.delete_organization_membership.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_organization_membership.metadata = {"url": "/v3/organization_memberships/{identifier}"}  
    def get_all_invitations(
        self,
        offset=None,          limit=None,          organization=None,          status=None,          role=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_invitations_request(
            offset=offset,
            limit=limit,
            organization=organization,
            status=status,
            role=role,
            template_url=self.get_all_invitations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_invitations.metadata = {"url": "/v3/invitations"}  
    def create_invitation(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "InvitationCreate")

        request = build_create_invitation_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_invitation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Invitation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_invitation.metadata = {"url": "/v3/invitations"}  
    def get_invitation(
        self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_invitation_request(
            identifier=identifier,
            template_url=self.get_invitation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Invitation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_invitation.metadata = {"url": "/v3/invitations/{identifier}"}  
    def update_invitation(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "InvitationUpdate")

        request = build_update_invitation_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.update_invitation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Invitation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_invitation.metadata = {"url": "/v3/invitations/{identifier}"}  
    def delete_invitation(          self,
        identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_invitation_request(
            identifier=identifier,
            template_url=self.delete_invitation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_invitation.metadata = {"url": "/v3/invitations/{identifier}"}  
    def get_invitation_by_token(
        self,
        token,          **kwargs,      ):
                
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_invitation_by_token_request(
            token=token,
            template_url=self.get_invitation_by_token.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Invitation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_invitation_by_token.metadata = {"url": "/v3/invitations/token/{token}"}  
    def respond_to_invitation(
        self,
        token,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "InvitationResponse")

        request = build_respond_to_invitation_request(
            token=token,
            content_type=content_type,
            json=_json,
            template_url=self.respond_to_invitation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Invitation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    respond_to_invitation.metadata = {"url": "/v3/invitations/token/{token}"}  
    def get_all_api_users(
        self,
        organization=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_api_users_request(
            organization=organization,
            template_url=self.get_all_api_users.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema", pipeline_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_api_users.metadata = {"url": "/v3/api_users"}  
    def create_api_user(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ApiUserCreate")

        request = build_create_api_user_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_api_user.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ApiUserWithKey", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_api_user.metadata = {"url": "/v3/api_users"}  
    def get_api_user(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_api_user_request(
            id=id,
            template_url=self.get_api_user.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ApiUserWithoutKey", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_api_user.metadata = {"url": "/v3/api_users/{id}"}  
    def update_api_user(
        self,
        id,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ApiUserUpdate")

        request = build_update_api_user_request(
            id=id,
            content_type=content_type,
            json=_json,
            template_url=self.update_api_user.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ApiUserWithoutKey", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_api_user.metadata = {"url": "/v3/api_users/{id}"}  
    def delete_api_user(          self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_api_user_request(
            id=id,
            template_url=self.delete_api_user.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_api_user.metadata = {"url": "/v3/api_users/{id}"}  
    def regenerate_api_key_for_api_user(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_regenerate_api_key_for_api_user_request(
            id=id,
            template_url=self.regenerate_api_key_for_api_user.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ApiUserWithKey", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    regenerate_api_key_for_api_user.metadata = {"url": "/v3/api_users/{id}/regenerate_api_key"}  
    def get_all_resthook_subscriptions(
        self,
        offset=None,          limit=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_resthook_subscriptions_request(
            offset=offset,
            limit=limit,
            template_url=self.get_all_resthook_subscriptions.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_resthook_subscriptions.metadata = {"url": "/v3/resthook_subscriptions"}  
    def create_resthook_subscription(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ResthookSubscriptionCreate")

        request = build_create_resthook_subscription_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_resthook_subscription.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResthookSubscription", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_resthook_subscription.metadata = {"url": "/v3/resthook_subscriptions"}  
    def get_resthook_subscription(
        self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_resthook_subscription_request(
            id=id,
            template_url=self.get_resthook_subscription.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResthookSubscription", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_resthook_subscription.metadata = {"url": "/v3/resthook_subscriptions/{id}"}  
    def update_resthook_subscription(
        self,
        id,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ResthookSubscriptionUpdate")

        request = build_update_resthook_subscription_request(
            id=id,
            content_type=content_type,
            json=_json,
            template_url=self.update_resthook_subscription.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResthookSubscription", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_resthook_subscription.metadata = {"url": "/v3/resthook_subscriptions/{id}"}  
    def delete_resthook_subscription(          self,
        id,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_resthook_subscription_request(
            id=id,
            template_url=self.delete_resthook_subscription.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_resthook_subscription.metadata = {"url": "/v3/resthook_subscriptions/{id}"}  
    def activate_resthook_subscription(
        self,
        x_hook_secret,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_activate_resthook_subscription_request(
            x_hook_secret=x_hook_secret,
            template_url=self.activate_resthook_subscription.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResthookSubscription", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    activate_resthook_subscription.metadata = {"url": "/v3/resthook_subscriptions/activate"}  
    def list_occupation_groups(
        self,
        **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_list_occupation_groups_request(
            template_url=self.list_occupation_groups.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[OccupationGroup]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    list_occupation_groups.metadata = {"url": "/v3/occupation_groups"}  
    def create_resume_search(
        self,
        body,          offset=None,          limit=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ResumeSearchParameters")

        request = build_create_resume_search_request(
            content_type=content_type,
            json=_json,
            offset=offset,
            limit=limit,
            template_url=self.create_resume_search.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResumeSearch", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_resume_search.metadata = {"url": "/v3/resume_search"}  
    def get_resume_search_detail(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ResumeSearchParameters")

        request = build_get_resume_search_detail_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.get_resume_search_detail.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResumeSearchDetail", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_resume_search_detail.metadata = {"url": "/v3/resume_search/details/{identifier}"}  
    def get_resume_search_config(
        self,
        **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_resume_search_config_request(
            template_url=self.get_resume_search_config.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResumeSearchConfig", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_resume_search_config.metadata = {"url": "/v3/resume_search/config"}  
    def update_resume_search_config(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "ResumeSearchConfig")

        request = build_update_resume_search_config_request(
            content_type=content_type,
            json=_json,
            template_url=self.update_resume_search_config.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResumeSearchConfig", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_resume_search_config.metadata = {"url": "/v3/resume_search/config"}  
    def create_resume_search_embed_url(
        self,
        body=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        if body is not None:
            _json = self._serialize.body(
                body, "Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema"
            )
        else:
            _json = None

        request = build_create_resume_search_embed_url_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_resume_search_embed_url.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResumeSearchEmbed", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_resume_search_embed_url.metadata = {"url": "/v3/resume_search/embed"}  
    def get_resume_search_match(
        self,
        resume,          job_description,          index=None,          search_expression=None,          job_titles_weight=None,          years_experience_weight=None,          locations_weight=None,          languages_weight=None,          skills_weight=None,          education_weight=None,          search_expression_weight=None,          soc_codes_weight=None,          management_level_weight=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_resume_search_match_request(
            resume=resume,
            job_description=job_description,
            index=index,
            search_expression=search_expression,
            job_titles_weight=job_titles_weight,
            years_experience_weight=years_experience_weight,
            locations_weight=locations_weight,
            languages_weight=languages_weight,
            skills_weight=skills_weight,
            education_weight=education_weight,
            search_expression_weight=search_expression_weight,
            soc_codes_weight=soc_codes_weight,
            management_level_weight=management_level_weight,
            template_url=self.get_resume_search_match.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ResumeSearchMatch", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_resume_search_match.metadata = {"url": "/v3/resume_search/match"}  
    def get_resume_search_suggestion_job_title(
        self,
        job_titles,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_resume_search_suggestion_job_title_request(
            job_titles=job_titles,
            template_url=self.get_resume_search_suggestion_job_title.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[str]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_resume_search_suggestion_job_title.metadata = {
        "url": "/v3/resume_search/suggestion_job_title"
    }  
    def get_resume_search_suggestion_skill(
        self,
        skills,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_resume_search_suggestion_skill_request(
            skills=skills,
            template_url=self.get_resume_search_suggestion_skill.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[str]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_resume_search_suggestion_skill.metadata = {"url": "/v3/resume_search/suggestion_skill"}  
    def create_job_description_search(
        self,
        body,          offset=None,          limit=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "JobDescriptionSearchParameters")

        request = build_create_job_description_search_request(
            content_type=content_type,
            json=_json,
            offset=offset,
            limit=limit,
            template_url=self.create_job_description_search.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("JobDescriptionSearch", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_job_description_search.metadata = {"url": "/v3/job_description_search"}  
    def get_job_description_search_detail(
        self,
        identifier,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "JobDescriptionSearchParameters")

        request = build_get_job_description_search_detail_request(
            identifier=identifier,
            content_type=content_type,
            json=_json,
            template_url=self.get_job_description_search_detail.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("JobDescriptionSearchDetail", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_job_description_search_detail.metadata = {
        "url": "/v3/job_description_search/details/{identifier}"
    }  
    def get_job_description_search_config(
        self,
        **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_job_description_search_config_request(
            template_url=self.get_job_description_search_config.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("JobDescriptionSearchConfig", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_job_description_search_config.metadata = {"url": "/v3/job_description_search/config"}  
    def update_job_description_search_config(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "JobDescriptionSearchConfig")

        request = build_update_job_description_search_config_request(
            content_type=content_type,
            json=_json,
            template_url=self.update_job_description_search_config.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("JobDescriptionSearchConfig", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_job_description_search_config.metadata = {"url": "/v3/job_description_search/config"}  
    def create_job_description_search_embed_url(
        self,
        body=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        if body is not None:
            _json = self._serialize.body(
                body,
                "PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema",
            )
        else:
            _json = None

        request = build_create_job_description_search_embed_url_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_job_description_search_embed_url.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("JobDescriptionSearchEmbed", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_job_description_search_embed_url.metadata = {"url": "/v3/job_description_search/embed"}  
    def get_all_indexes(
        self,
        offset=None,          limit=None,          document_type=None,          name=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_indexes_request(
            offset=offset,
            limit=limit,
            document_type=document_type,
            name=name,
            template_url=self.get_all_indexes.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema", pipeline_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_indexes.metadata = {"url": "/v3/index"}  
    def create_index(
        self,
        body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "IndexCreate")

        request = build_create_index_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_index.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Index", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_index.metadata = {"url": "/v3/index"}  
    def update_index(
        self,
        name,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(body, "IndexUpdate")

        request = build_update_index_request(
            name=name,
            content_type=content_type,
            json=_json,
            template_url=self.update_index.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Index", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_index.metadata = {"url": "/v3/index/{name}"}  
    def delete_index(          self,
        name,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_index_request(
            name=name,
            template_url=self.delete_index.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_index.metadata = {"url": "/v3/index/{name}"}  
    def get_all_index_documents(
        self,
        name,          offset=None,          limit=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_all_index_documents_request(
            name=name,
            offset=offset,
            limit=limit,
            template_url=self.get_all_index_documents.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_all_index_documents.metadata = {"url": "/v3/index/{name}/documents"}  
    def create_index_document(
        self,
        name,          body,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))          cls = kwargs.pop("cls", None)  
        _json = self._serialize.body(
            body, "PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema"
        )

        request = build_create_index_document_request(
            name=name,
            content_type=content_type,
            json=_json,
            template_url=self.create_index_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize(
            "PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema",
            pipeline_response,
        )

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_index_document.metadata = {"url": "/v3/index/{name}/documents"}  
    def delete_index_document(          self,
        name,          identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_delete_index_document_request(
            name=name,
            identifier=identifier,
            template_url=self.delete_index_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_index_document.metadata = {"url": "/v3/index/{name}/documents/{identifier}"}  
    def re_index_document(          self,
        name,          identifier,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_re_index_document_request(
            name=name,
            identifier=identifier,
            template_url=self.re_index_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    re_index_document.metadata = {"url": "/v3/index/{name}/documents/{identifier}/re_index"}  }
affinda-python-master\affinda\operations _patch.py{from typing import TYPE_CHECKING

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest

from .. import models as _models  from .._vendor import _convert_request  
if TYPE_CHECKING:
        from typing import Any, Callable, Dict, Optional, TypeVar, Union  
    T = TypeVar("T")
    ClsType = Optional[
        Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]
    ]

from ._affinda_api_operations import (
    AffindaAPIOperationsMixin as AffindaAPIOperationsMixinGenerated,
)
from ._affinda_api_operations import build_get_document_request


class AffindaAPIOperationsMixin(AffindaAPIOperationsMixinGenerated):
            def get_document(
        self,
        identifier,          format=None,          compact=None,          **kwargs,      ):
                
        error_map = {
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
            401: lambda response: ClientAuthenticationError(
                response=response, model=self._deserialize(_models.RequestError, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  
        request = build_get_document_request(
            identifier=identifier,
            format=format,
            compact=compact,
            template_url=self.get_document.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  
        pipeline_response = self._client._pipeline.run(              request, stream=False, **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code != 200:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.RequestError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        else:
            deserialized = self._deserialize("Document", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_document.metadata = {"url": "/v3/documents/{identifier}"}  

__all__ = [
    "AffindaAPIOperationsMixin",
]


def patch_sdk():
    
}


affinda-python-master\affinda\aio __init__.py{
from ._affinda_api import AffindaAPI

try:
    from ._patch import __all__ as _patch_all
    from ._patch import *  except ImportError:
    _patch_all = []
from ._patch import patch_sdk as _patch_sdk

__all__ = ["AffindaAPI"]
__all__.extend([p for p in _patch_all if p not in __all__])

_patch_sdk()
}
affinda-python-master\affinda\aio _patch.py{
from typing import TYPE_CHECKING

from azure.core import AsyncPipelineClient
from azure.core.pipeline import PipelineRequest
from azure.core.pipeline.policies import AsyncBearerTokenCredentialPolicy
from msrest import Deserializer, Serializer

from .. import models
from ._affinda_api import AffindaAPI as AffindaAPIGenerated
from ._configuration import AffindaAPIConfiguration
from .token_credential import AsyncTokenCredential

if TYPE_CHECKING:
    pass


class AsyncBearerTokenWithoutTLSEnforcementPolicy(AsyncBearerTokenCredentialPolicy):
    

    async def on_request(self, request: PipelineRequest):
        request.context.options["enforce_https"] = False
        return await super().on_request(request)


class AffindaAPI(AffindaAPIGenerated):
    def __init__(
        self,
        credential,          region="api",          **kwargs,      ):
        if "base_url" not in kwargs:
            _base_url = "https://{region}.affinda.com"
        else:
            _base_url = kwargs.pop("base_url")

        if "authentication_policy" not in kwargs:
            kwargs["authentication_policy"] = AsyncBearerTokenWithoutTLSEnforcementPolicy(
                credential
            )

        self._config = AffindaAPIConfiguration(credential=credential, region=region, **kwargs)
        self._client = AsyncPipelineClient(base_url=_base_url, config=self._config, **kwargs)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)
        self._serialize.client_side_validation = False


__all__ = ["AffindaAPI", "AsyncTokenCredential"]


def patch_sdk():
    
}
affinda-python-master\affinda\aio _affinda_api.py{
from copy import deepcopy
from typing import Any, Awaitable, TYPE_CHECKING, Union

from msrest import Deserializer, Serializer

from azure.core import AsyncPipelineClient
from azure.core.rest import AsyncHttpResponse, HttpRequest

from .. import models
from ._configuration import AffindaAPIConfiguration
from .operations import AffindaAPIOperationsMixin

if TYPE_CHECKING:
        from azure.core.credentials_async import AsyncTokenCredential


class AffindaAPI(AffindaAPIOperationsMixin):
    

    def __init__(
        self,
        credential: "AsyncTokenCredential",
        region: Union[str, "_models.Region"] = "api",
        **kwargs: Any,
    ) -> None:
        _base_url = "https://{region}.affinda.com"
        self._config = AffindaAPIConfiguration(credential=credential, region=region, **kwargs)
        self._client = AsyncPipelineClient(base_url=_base_url, config=self._config, **kwargs)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)
        self._serialize.client_side_validation = False

    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
        

        request_copy = deepcopy(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }

        request_copy.url = self._client.format_url(request_copy.url, **path_format_arguments)
        return self._client.send_request(request_copy, **kwargs)

    async def close(self) -> None:
        await self._client.close()

    async def __aenter__(self) -> "AffindaAPI":
        await self._client.__aenter__()
        return self

    async def __aexit__(self, *exc_details) -> None:
        await self._client.__aexit__(*exc_details)
}
affinda-python-master\affinda\aio _configuration.py{
from typing import Any, TYPE_CHECKING, Union

from azure.core.configuration import Configuration
from azure.core.pipeline import policies

from .._version import VERSION

if TYPE_CHECKING:
        from azure.core.credentials_async import AsyncTokenCredential


class AffindaAPIConfiguration(Configuration):      

    def __init__(
        self,
        credential: "AsyncTokenCredential",
        region: Union[str, "_models.Region"] = "api",
        **kwargs: Any,
    ) -> None:
        super(AffindaAPIConfiguration, self).__init__(**kwargs)
        if credential is None:
            raise ValueError("Parameter 'credential' must not be None.")
        if region is None:
            raise ValueError("Parameter 'region' must not be None.")

        self.credential = credential
        self.region = region
        self.credential_scopes = kwargs.pop(
            "credential_scopes", ["https://management.azure.com/.default"]
        )
        kwargs.setdefault("sdk_moniker", "affinda/{}".format(VERSION))
        self._configure(**kwargs)

    def _configure(self, **kwargs: Any) -> None:
        self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(
            **kwargs
        )
        self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
        self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
        self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(
            **kwargs
        )
        self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(
            **kwargs
        )
        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
        self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(
            **kwargs
        )
        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(
            **kwargs
        )
        self.authentication_policy = kwargs.get("authentication_policy")
        if self.credential and not self.authentication_policy:
            self.authentication_policy = policies.AsyncBearerTokenCredentialPolicy(
                self.credential, *self.credential_scopes, **kwargs
            )
}
affinda-python-master\affinda\aio token_credential.py{from azure.core.credentials import AccessToken


class AsyncTokenCredential:
    

    def __init__(self, token: str, expires_on: int = 0):
        self.token = token
        self.expires_on = expires_on

    async def get_token(self, *scopes, **kwargs):
        return AccessToken(self.token, self.expires_on)
}

















affinda-python-master\affinda __init__.py{from ._patch import AffindaAPI
from ._version import VERSION
from .token_credential import TokenCredential

__version__ = VERSION
__all__ = ["AffindaAPI", "TokenCredential"]

try:
    from ._patch import patch_sdk  
    patch_sdk()
except ImportError:
    pass
}
affinda-python-master\affinda _version.py{VERSION = "4.27.0"}
affinda-python-master\affinda _vendor.py{from azure.core.pipeline.transport import HttpRequest


def _convert_request(request, files=None):
    data = request.content if not files else None
    request = HttpRequest(
        method=request.method, url=request.url, headers=request.headers, data=data
    )
    if files:
        request.set_formdata_body(files)
    return request


def _format_url_section(template, **kwargs):
    components = template.split("/")
    while components:
        try:
            return template.format(**kwargs)
        except KeyError as key:
            formatted_components = template.split("/")
            components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
            template = "/".join(components)
}
affinda-python-master\affinda _patch.py{
from azure.core import PipelineClient
from azure.core.pipeline import PipelineRequest
from azure.core.pipeline.policies import BearerTokenCredentialPolicy
from msrest import Deserializer, Serializer

from . import models
from ._affinda_api import AffindaAPI as AffindaAPIGenerated
from ._configuration import AffindaAPIConfiguration


class BearerTokenWithoutTLSEnforcementPolicy(BearerTokenCredentialPolicy):
    

    def on_request(self, request: PipelineRequest):
        request.context.options["enforce_https"] = False
        return super().on_request(request)


class AffindaAPI(AffindaAPIGenerated):
    def __init__(
        self,
        credential,          **kwargs,      ):
        if "base_url" not in kwargs:
            _base_url = "https://{region}.affinda.com"
        else:
            _base_url = kwargs.pop("base_url")

        if "authentication_policy" not in kwargs:
            kwargs["authentication_policy"] = BearerTokenWithoutTLSEnforcementPolicy(credential)

        self._config = AffindaAPIConfiguration(credential=credential, **kwargs)
        self._client = PipelineClient(base_url=_base_url, config=self._config, **kwargs)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)
        self._serialize.client_side_validation = False


__all__ = ["AffindaAPI"]


def patch_sdk():
    
}
affinda-python-master\affinda _configuration.py{
from typing import TYPE_CHECKING

from azure.core.configuration import Configuration
from azure.core.pipeline import policies

from ._version import VERSION

if TYPE_CHECKING:
        from typing import Any, Union

    from azure.core.credentials import TokenCredential


class AffindaAPIConfiguration(Configuration):      

    def __init__(
        self,
        credential,          region="api",          **kwargs,      ):
                super(AffindaAPIConfiguration, self).__init__(**kwargs)
        if credential is None:
            raise ValueError("Parameter 'credential' must not be None.")
        if region is None:
            raise ValueError("Parameter 'region' must not be None.")

        self.credential = credential
        self.region = region
        self.credential_scopes = kwargs.pop(
            "credential_scopes", ["https://management.azure.com/.default"]
        )
        kwargs.setdefault("sdk_moniker", "affinda/{}".format(VERSION))
        self._configure(**kwargs)

    def _configure(
        self,
        **kwargs,      ):
                self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(
            **kwargs
        )
        self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
        self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
        self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(
            **kwargs
        )
        self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(
            **kwargs
        )
        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
        self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(
            **kwargs
        )
        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
        self.authentication_policy = kwargs.get("authentication_policy")
        if self.credential and not self.authentication_policy:
            self.authentication_policy = policies.BearerTokenCredentialPolicy(
                self.credential, *self.credential_scopes, **kwargs
            )
}
affinda-python-master\affinda _affinda_api.py{
from copy import deepcopy
from typing import TYPE_CHECKING

from msrest import Deserializer, Serializer

from azure.core import PipelineClient

from . import models
from ._configuration import AffindaAPIConfiguration
from .operations import AffindaAPIOperationsMixin

if TYPE_CHECKING:
        from typing import Any, Union

    from azure.core.credentials import TokenCredential
    from azure.core.rest import HttpRequest, HttpResponse


class AffindaAPI(AffindaAPIOperationsMixin):
    

    def __init__(
        self,
        credential,          region="api",          **kwargs,      ):
                _base_url = "https://{region}.affinda.com"
        self._config = AffindaAPIConfiguration(credential=credential, region=region, **kwargs)
        self._client = PipelineClient(base_url=_base_url, config=self._config, **kwargs)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)
        self._serialize.client_side_validation = False

    def _send_request(
        self,
        request,          **kwargs,      ):
                

        request_copy = deepcopy(request)
        path_format_arguments = {
            "region": self._serialize.url("self._config.region", self._config.region, "str"),
        }

        request_copy.url = self._client.format_url(request_copy.url, **path_format_arguments)
        return self._client.send_request(request_copy, **kwargs)

    def close(self):
                self._client.close()

    def __enter__(self):
                self._client.__enter__()
        return self

    def __exit__(self, *exc_details):
                self._client.__exit__(*exc_details)
}
affinda-python-master\affinda token_credential.py{from azure.core.credentials import AccessToken


class TokenCredential:
    

    def __init__(self, token: str, expires_on: int = 0):
        self.token = token
        self.expires_on = expires_on

    def get_token(self, *scopes, **kwargs):
        return AccessToken(self.token, self.expires_on)
}


affinda-python-master __init__.py{}

affinda-python-master setup.py{from setuptools import setup

setup()
}



